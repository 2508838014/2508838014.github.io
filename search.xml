<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C#继承学习-学习日志（2）</title>
      <link href="/2022/09/05/c-ji-cheng-xue-xi-xue-xi-ri-zhi-2/"/>
      <url>/2022/09/05/c-ji-cheng-xue-xi-xue-xi-ri-zhi-2/</url>
      
        <content type="html"><![CDATA[<p>学习继承<br>面向对象的三大特性，封装继承多态</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的好处"><a href="#继承的好处" class="headerlink" title="继承的好处"></a>继承的好处</h2><ol><li>优化代码结构</li><li>提高代码的复用性</li><li>为多态提供前提</li></ol><h2 id="继承语法格式"><a href="#继承语法格式" class="headerlink" title="继承语法格式"></a>继承语法格式</h2><p>子类继承父类，用用”：“冒号关键字符<br>class 子类：父类<br>{<br>    //类成员<br>}<br>This关键字表示当前类<br>Base是上传到父类来处理</p><pre class="line-numbers language-none"><code class="language-none">//父类class Hero{private string heroName;private inr attack;//父类的构造方法public Hero () {}public Hero (string m_heroName.int m_attack){this.heroName=m_heroName;this.attack=m_attack;}//父类的方法public string HeroName{get {return HeroName;}set {heroName=value;}}public int Attack{get {return Attack;}set {attack=value;}}}//子类class Luka:Hero{public Luka(){}public Luka(string m_heroName.int m_attack):base(string m_heroName.int m_attack){}public void Suishidaji(){Console.WriteLine("随时打击");}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="子类继承父类的关系"><a href="#子类继承父类的关系" class="headerlink" title="子类继承父类的关系"></a>子类继承父类的关系</h2><p>父类中的字段，用private修饰的字段，我们在子类中无法访问<br>public修饰，子类可以访问。通过<em>base.字段名</em>的方式访问<br>大部分（80%是private）<br>父类中的属性，用private修饰的属性，我们在子类中无法访问<br>public修饰，子类可以访问。通过<em>base.属性名</em>的方式访问<br>大部分（80%是public）<br>父类中的普通方法，用private修饰的普通方法，我们在子类中无法访问<br>public修饰，子类可以访问。通过<em>base.方法名</em>的方式访问  </p><p>父类中的构造方法，用private修饰的字段，我们在子类中无法访问<br>public修饰，子类可以访问。通过<em>base（）</em>的方式访问<br>大部分（99%是public）</p>]]></content>
      
      
      <categories>
          
          <category> -C# -日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -C# -基础学习 -类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Basler语法学习</title>
      <link href="/2022/09/05/basler-yu-fa-xue-xi/"/>
      <url>/2022/09/05/basler-yu-fa-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>Basler语法学习</p><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="基础设备"><a href="#基础设备" class="headerlink" title="基础设备"></a>基础设备</h2><h3 id="basler设备的查找"><a href="#basler设备的查找" class="headerlink" title="basler设备的查找"></a>basler设备的查找</h3><h3 id="第一个设备的操作"><a href="#第一个设备的操作" class="headerlink" title="第一个设备的操作"></a>第一个设备的操作</h3><pre class="line-numbers language-none"><code class="language-none"> //声明一个设备  PYLON_DEVICE_HANDLE hDev = new PYLON_DEVICE_HANDLE();          /* Handle for the pylon device. */  try            {                uint numDevices;    /* Number of devices available. */#if DEBUG                /* This is a special debug setting needed only for GigE cameras.                See 'Building Applications with pylon' in the programmer's guide. */                Environment.SetEnvironmentVariable("PYLON_GIGE_HEARTBEAT", "300000" /*ms*/);#endif                /* Before using any pylon methods, the pylon runtime must be initialized. */                //Pylon初始化                Pylon.Initialize();                /* Enumerate all camera devices. You must call                Pylon.EnumerateDevices() before creating a device.                  枚举设备获得设备数量*/                numDevices = Pylon.EnumerateDevices();                if (0 == numDevices)                {                    throw new Exception("No devices found.");                }                /*hDev设为第一个设备的引用 Get a handle for the first device found.  */                hDev = Pylon.CreateDeviceByIndex(0);                /*在使用设备前打开此设备                 cPylonAccessModeControl==1 Write access to device features is allowed.                cPylonAccessModeStream = 2 Stream grabber access is allowed.                 ´Ë´¦Ê¹ÓÃÎ»»òÔËËã£¬¸ù¾ÝÔËËãµÄ½á¹ûµÃµ½ÏàÓ¦µÄÄ£Ê½¡£                PYLONC_ACCESS_MODE_CONTROL - Allows to read or write camera parameters to configure the camera.                 PYLONC_ACCESS_MODE_STREAM - Allows to read image data from the camera's stream grabber object.                 PYLONC_ACCESS_MODE_EVENT - Allows to read event data from the camera's stream grabber object.                 PYLONC_ACCESS_MODE_EXCLUSIVE - Allows exclusive access. When this flag is specified no other application may access the camera.                 PYLONC_ACCESS_MODE_MONITOR - Allows only read access. This flag cannot be combined with any other flags.                 It is typically used in Multicast/Broadcast applications with GigE cameras. You can pass one or more flags.                 If you pass more than one flag you can combine them using the 'or' operator.                 Before using the device, it must be opened. Open it for configuring                parameters and for grabbing images. */                Pylon.DeviceOpen(hDev, Pylon.cPylonAccessModeControl | Pylon.cPylonAccessModeStream);                /* Print out the name of the camera we are using. */                {                    bool isReadable;                    isReadable = Pylon.DeviceFeatureIsReadable(hDev, "DeviceModelName");                    if (isReadable)                    {                        string name = Pylon.DeviceFeatureToString(hDev, "DeviceModelName");                        Console.WriteLine("Using camera {0}", name);                    }                }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多个设备的批量设置"><a href="#多个设备的批量设置" class="headerlink" title="多个设备的批量设置"></a>多个设备的批量设置</h3><pre class="line-numbers language-none"><code class="language-none">        const uint MAX_NUM_DEVICES = 2;        const uint NUM_BUFFERS = 1;        /* Number of buffers used for grabbing. */        const uint GIGE_PACKET_SIZE = 1500; /* Size of one Ethernet packet. */        const uint GIGE_PROTOCOL_OVERHEAD = 36;   /* Total number of bytes of protocol overhead. */        const uint AllGroupMask = 0xffffffff;       /// &lt;summary&gt;        /// The main entry point for the application.        /// &lt;/summary&gt;        static void Main()        {            /* Use a random number as the device key. */            uint DeviceKey = (uint)(new Random()).Next(int.MaxValue);            /* In this sample all cameras belong to the same group. */            const uint GroupKey = 0x24;            PYLON_DEVICE_HANDLE[] hDev = new PYLON_DEVICE_HANDLE[MAX_NUM_DEVICES];        /* Handles for the pylon devices. */            for (int deviceIndex = 0; deviceIndex &lt; MAX_NUM_DEVICES; ++deviceIndex)            {                hDev[deviceIndex] = new PYLON_DEVICE_HANDLE();            }            try            {                uint numDevicesEnumerated;    /* Number of the devices connected to this PC. */                uint numDevicesToUse;         /* Number of the devices to use in this sample. */                bool isAvail;                 /* Used for checking feature availability. */                bool isReady;                 /* Used as an output parameter. */                int i;                        /* Counter. */                uint deviceIndex;             /* Index of device used in the following variables. */                PYLON_WAITOBJECTS_HANDLE wos; /* Wait objects. */                /* These are camera specific variables: */                PYLON_STREAMGRABBER_HANDLE[] hGrabber = new PYLON_STREAMGRABBER_HANDLE[MAX_NUM_DEVICES]; /* Handle for the pylon stream grabber. */                PYLON_WAITOBJECT_HANDLE[]    hWait = new PYLON_WAITOBJECT_HANDLE[MAX_NUM_DEVICES];       /* Handle used for waiting for a grab to be finished. */                uint[]                       payloadSize = new uint[MAX_NUM_DEVICES];                    /* Size of an image frame in bytes. */                uint[]                       nStreams = new uint[MAX_NUM_DEVICES];                       /* The number of streams provided by the device. */                PYLON_STREAMBUFFER_HANDLE[]  hBuffer = new PYLON_STREAMBUFFER_HANDLE[MAX_NUM_DEVICES];                PylonBuffer&lt;Byte&gt;[]          buffer = new PylonBuffer&lt;Byte&gt;[MAX_NUM_DEVICES];#if DEBUG                /* This is a special debug setting needed only for GigE cameras.                See 'Building Applications with pylon' in the Programmer's Guide. */                Environment.SetEnvironmentVariable("PYLON_GIGE_HEARTBEAT", "300000" /*ms*/);#endif                /* Before using any pylon methods, the pylon runtime must be initialized. */                Pylon.Initialize();                /* Enumerate all camera devices. You must call                PylonEnumerateDevices() before creating a device. */                numDevicesEnumerated = Pylon.EnumerateDevices();                if (numDevicesEnumerated == 0)                {                    Pylon.Terminate();                    Console.Error.WriteLine("No devices found!");                    Console.Error.WriteLine("\nPress enter to exit.");                    Console.ReadLine();                    return;                }                /* Create wait objects. This must be done outside of the loop. */                wos = Pylon.WaitObjectsCreate();                /* Open cameras and set parameter */                deviceIndex = 0;                for (uint enumeratedDeviceIndex = 0; enumeratedDeviceIndex &lt; numDevicesEnumerated; ++enumeratedDeviceIndex)                {                    /* only open GigE devices */                    PYLON_DEVICE_INFO_HANDLE hDI = Pylon.GetDeviceInfoHandle(enumeratedDeviceIndex);                    if (Pylon.DeviceInfoGetPropertyValueByName(hDI, Pylon.cPylonDeviceInfoDeviceClassKey) != "BaslerGigE")                    {                        continue;                    }                    /* Get handles for the devices. */                    hDev[deviceIndex] = Pylon.CreateDeviceByIndex((uint)enumeratedDeviceIndex);                    /* Before using the device, it must be opened. Open it for configuring                    parameters and for grabbing images. */                    Pylon.DeviceOpen(hDev[deviceIndex], Pylon.cPylonAccessModeControl | Pylon.cPylonAccessModeStream);                    /* Print out the name of the camera we are using. */                    Console.WriteLine("Using camera '{0}'", Pylon.DeviceInfoGetPropertyValueByName(hDI, Pylon.cPylonDeviceInfoModelNameKey));                    isAvail = Pylon.DeviceFeatureIsReadable(hDev[deviceIndex], "ActionControl");                    if (!isAvail)                    {                        throw new Exception("Device doesn't support the Action Command");                    }                    /* Configure the first action */                    Pylon.DeviceSetIntegerFeature(hDev[deviceIndex], "ActionSelector", 1);                    Pylon.DeviceSetIntegerFeature(hDev[deviceIndex], "ActionDeviceKey", DeviceKey);                    Pylon.DeviceSetIntegerFeature(hDev[deviceIndex], "ActionGroupKey", GroupKey);                    Pylon.DeviceSetIntegerFeature(hDev[deviceIndex], "ActionGroupMask", AllGroupMask);                    /* Set the pixel format to Mono8, where gray values will be output as 8 bit values for each pixel. */                    /* ... Check first to see if the device supports the Mono8 format. */                    isAvail = Pylon.DeviceFeatureIsAvailable(hDev[deviceIndex], "EnumEntry_PixelFormat_Mono8");                    if (!isAvail)                    {                        /* Feature is not available. */                        throw new Exception("Device doesn't support the Mono8 pixel format.");                    }                    /* ... Set the pixel format to Mono8. */                    Pylon.DeviceFeatureFromString(hDev[deviceIndex], "PixelFormat", "Mono8");                    /* Disable acquisition start trigger if available */                    isAvail = Pylon.DeviceFeatureIsAvailable(hDev[deviceIndex], "EnumEntry_TriggerSelector_AcquisitionStart");                    if (isAvail)                    {                        Pylon.DeviceFeatureFromString(hDev[deviceIndex], "TriggerSelector", "AcquisitionStart");                        Pylon.DeviceFeatureFromString(hDev[deviceIndex], "TriggerMode", "Off");                    }                    /* Disable line1 trigger if available */                    isAvail = Pylon.DeviceFeatureIsAvailable(hDev[deviceIndex], "EnumEntry_TriggerSelector_Line1");                    if (isAvail)                    {                        Pylon.DeviceFeatureFromString(hDev[deviceIndex], "TriggerSelector", "Line1");                        Pylon.DeviceFeatureFromString(hDev[deviceIndex], "TriggerMode", "Off");                    }                    /* Enable frame start trigger with first action */                    Pylon.DeviceFeatureFromString(hDev[deviceIndex], "TriggerSelector", "FrameStart");                    Pylon.DeviceFeatureFromString(hDev[deviceIndex], "TriggerMode", "On");                    Pylon.DeviceFeatureFromString(hDev[deviceIndex], "TriggerSource", "Action1");                    /* For GigE cameras, we recommend increasing the packet size for better                        performance. When the network adapter supports jumbo frames, set the packet                        size to a value &gt; 1500, e.g., to 8192. In this sample, we only set the packet size                        to 1500.                        We also set the Inter-Packet and the Frame Transmission delay                        so the switch can line up packets better.                    */                    Pylon.DeviceSetIntegerFeature(hDev[deviceIndex], "GevSCPSPacketSize", GIGE_PACKET_SIZE);                    Pylon.DeviceSetIntegerFeature(hDev[deviceIndex], "GevSCPD", (GIGE_PACKET_SIZE + GIGE_PROTOCOL_OVERHEAD) * (MAX_NUM_DEVICES - 1));                    Pylon.DeviceSetIntegerFeature(hDev[deviceIndex], "GevSCFTD", (GIGE_PACKET_SIZE + GIGE_PROTOCOL_OVERHEAD) * deviceIndex);                    /* one device opened */                    ++deviceIndex;                }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="显示设备名称"><a href="#显示设备名称" class="headerlink" title="显示设备名称"></a>显示设备名称</h3><p> 显示设备的名称</p><pre class="line-numbers language-none"><code class="language-none">/* Print out the name of the camera we are using. */               {                   bool isReadable;                   isReadable = Pylon.DeviceFeatureIsReadable(hDev, "DeviceModelName");                   if (isReadable)                   {                       string name = Pylon.DeviceFeatureToString(hDev, "DeviceModelName");                       Console.WriteLine("Using camera {0}", name);                   }               }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置拍摄图片模式"><a href="#设置拍摄图片模式" class="headerlink" title="设置拍摄图片模式"></a>设置拍摄图片模式</h3><pre class="line-numbers language-none"><code class="language-none">/* Set the pixel format to Mono8, where gray values will be output as 8 bit values for each pixel. */                /* ... Check first to see if the device supports the Mono8 format. */                isAvail = Pylon.DeviceFeatureIsAvailable(hDev, "EnumEntry_PixelFormat_Mono8");                if (!isAvail)                {                    /* Feature is not available. */                    throw new Exception("Device doesn't support the Mono8 pixel format.");                }                /* ... Set the pixel format to Mono8. */                Pylon.DeviceFeatureFromString(hDev, "PixelFormat", "Mono8");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置拍摄采集模式"><a href="#设置拍摄采集模式" class="headerlink" title="设置拍摄采集模式"></a>设置拍摄采集模式</h3><pre class="line-numbers language-none"><code class="language-none">/* Check the available camera trigger mode(s) to select the appropriate one: acquisition start trigger mode (used by previous cameras;                do not confuse with acquisition start command) or frame start trigger mode (equivalent to previous acquisition start trigger mode). */                isAvailAcquisitionStart = Pylon.DeviceFeatureIsAvailable(hDev, "EnumEntry_TriggerSelector_AcquisitionStart");                isAvailFrameStart = Pylon.DeviceFeatureIsAvailable(hDev, "EnumEntry_TriggerSelector_FrameStart");                /* Check to see if the camera implements the acquisition start trigger mode only.                优先是frame start （此时只有在半双工的时候才能打开frame burst帧突发），其次选择Acquisition Start。两种模式不能并存                */                if (isAvailAcquisitionStart &amp;&amp; !isAvailFrameStart)                {                    /* Camera uses the acquisition start trigger as the only trigger mode. */                    Pylon.DeviceFeatureFromString(hDev, "TriggerSelector", "AcquisitionStart");                    Pylon.DeviceFeatureFromString(hDev, "TriggerMode", "On");                    triggerSelectorValue = "AcquisitionStart";                }                else                {                    /* Camera may have the acquisition start trigger mode and the frame start trigger mode implemented.                    In this case, the acquisition trigger mode must be switched off. */                    if (isAvailAcquisitionStart)                    {                        Pylon.DeviceFeatureFromString(hDev, "TriggerSelector", "AcquisitionStart");                        Pylon.DeviceFeatureFromString(hDev, "TriggerMode", "Off");                    }                    /* Disable frame burst start trigger if available */                    isAvail = Pylon.DeviceFeatureIsAvailable(hDev, "EnumEntry_TriggerSelector_FrameBurstStart");                    if (isAvail)                    {                        Pylon.DeviceFeatureFromString(hDev, "TriggerSelector", "FrameBurstStart");                        Pylon.DeviceFeatureFromString(hDev, "TriggerMode", "Off");                    }                    /* To trigger each single frame by software or external hardware trigger: Enable the frame start trigger mode. */                    Pylon.DeviceFeatureFromString(hDev, "TriggerSelector", "FrameStart");                    Pylon.DeviceFeatureFromString(hDev, "TriggerMode", "On");                }                /* Note: the trigger selector must be set to the appropriate trigger mode                before setting the trigger source or issuing software triggers.                Frame start trigger mode for newer cameras, acquisition start trigger mode for previous cameras.                 软件触发*/                Pylon.DeviceFeatureFromString(hDev, "TriggerSelector", triggerSelectorValue);                /* Enable software triggering.                 持续采集*/                /* ... Select the software trigger as the trigger source. */                Pylon.DeviceFeatureFromString(hDev, "TriggerSource", "Software");                /* When using software triggering, the Continuous frame mode should be used. Once                   acquisition is started, the camera sends one image each time a software trigger is                   issued. */                Pylon.DeviceFeatureFromString(hDev, "AcquisitionMode", "Continuous");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置拍摄数据包大小"><a href="#设置拍摄数据包大小" class="headerlink" title="设置拍摄数据包大小"></a>设置拍摄数据包大小</h3><pre class="line-numbers language-none"><code class="language-none">/* For GigE cameras, we recommend increasing the packet size for better   performance. If the network adapter supports jumbo frames, set the packet   size to a value &gt; 1500, e.g., to 8192. In this sample, we only set the packet size   to 1500. *//* ... Check first to see if the GigE camera packet size parameter is supported and if it is writable. */isAvail = Pylon.DeviceFeatureIsWritable(hDev, "GevSCPSPacketSize");if (isAvail){    /* ... The device supports the packet size feature. Set a value. */    Pylon.DeviceSetIntegerFeature(hDev, "GevSCPSPacketSize", 1500);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置拍摄块"><a href="#设置拍摄块" class="headerlink" title="设置拍摄块"></a>设置拍摄块</h3><p>摄像机可以生成关于每个图像的特定信息，例如帧</p><p>计数器、时间戳和CRC校验和，作为数据“块”附加到图像数据。此示例演示了如何启用块功能，以及如何获取</p><p>以及如何处理附加数据。当相机处于块模式时，它传输数据块</p><p>其被划分成块。第一块总是图像数据。当块特征被启用时，</p><p>图像数据块之后是包含由块特征生成的信息的块。<br>本示例还演示了如何使用软件触发器。使用两个缓冲器。一旦缓冲器被填充，</p><p>在处理接收到的缓冲器之前触发下一帧的获取。这种方法允许：</p><p>在前一图像的处理进行的同时执行图像获取。</p><pre class="line-numbers language-none"><code class="language-none">/* Before enabling individual chunks, the chunk mode in general must be activated. */isAvail = Pylon.DeviceFeatureIsWritable(hDev, "ChunkModeActive");if (!isAvail){    throw new Exception("The device doesn't support the chunk mode.");}/* Activate the chunk mode. */Pylon.DeviceSetBooleanFeature(hDev, "ChunkModeActive", true);/* Enable some individual chunks... *//* ... The frame counter chunk feature. *//* Is the chunk feature available? */isAvail = Pylon.DeviceFeatureIsAvailable(hDev, "EnumEntry_ChunkSelector_Framecounter");if (isAvail){    /* Select the frame counter chunk feature. */    Pylon.DeviceFeatureFromString(hDev, "ChunkSelector", "Framecounter");    /* Can the chunk feature be activated? */    isAvail = Pylon.DeviceFeatureIsWritable(hDev, "ChunkEnable");    if (isAvail)    {        /* Activate the chunk feature. */        Pylon.DeviceSetBooleanFeature(hDev, "ChunkEnable", true);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="设置块chunks的内容"><a href="#设置块chunks的内容" class="headerlink" title="设置块chunks的内容"></a>设置块chunks的内容</h4><pre class="line-numbers language-none"><code class="language-none">//设置循环冗余校验（Cyclic Redundancy Check， CRC）是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种信道编码技术，主要用来检测或校验数据传输或者保存后可能出现的错误。它是利用除法及余数的原理来作错误侦测的。                /* ... The CRC checksum chunk feature. */                /*  Note: Enabling the CRC checksum chunk feature is not a prerequisite for using                   chunks. Chunks can also be handled when the CRC checksum chunk feature is disabled. */                isAvail = Pylon.DeviceFeatureIsAvailable(hDev, "EnumEntry_ChunkSelector_PayloadCRC16");                if (isAvail)                {                    /* Select the CRC checksum chunk feature. */                    Pylon.DeviceFeatureFromString(hDev, "ChunkSelector", "PayloadCRC16");                    /* Can the chunk feature be activated? */                    isAvail = Pylon.DeviceFeatureIsWritable(hDev, "ChunkEnable");                    if (isAvail)                    {                        /* Activate the chunk feature. */                        Pylon.DeviceSetBooleanFeature(hDev, "ChunkEnable", true);                    }                }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="设置块解析器chunk-parser"><a href="#设置块解析器chunk-parser" class="headerlink" title="设置块解析器chunk parser"></a>设置块解析器chunk parser</h4><pre class="line-numbers language-none"><code class="language-none">/* The data block containing the image chunk and the other chunks has a self-descriptive layout.   A chunk parser is used to extract the appended chunk data from the grabbed image frame.   Create a chunk parser. */hChunkParser = Pylon.DeviceCreateChunkParser(hDev);if (!hChunkParser.IsValid){    /* The transport layer doesn't provide a chunk parser. */    throw new Exception("No chunk parser available.");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="设置并分配拍摄流与缓冲区"><a href="#设置并分配拍摄流与缓冲区" class="headerlink" title="设置并分配拍摄流与缓冲区"></a>设置并分配拍摄流与缓冲区</h4><pre class="line-numbers language-none"><code class="language-none">/* Image grabbing is done using a stream grabber.                  A device may be able to provide different streams. A separate stream grabber must                  be used for each stream. In this sample, we create a stream grabber for the default                  stream, i.e., the first stream ( index == 0 ).                  */                /* Get the number of streams supported by the device and the transport layer. */                nStreams = Pylon.DeviceGetNumStreamGrabberChannels(hDev);                if (nStreams &lt; 1)                {                    throw new Exception("The transport layer doesn't support image streams.");                }                /* Create and open a stream grabber for the first channel. */                hGrabber = Pylon.DeviceGetStreamGrabber(hDev, 0);                Pylon.StreamGrabberOpen(hGrabber);                /* Get a handle for the stream grabber's wait object. The wait object                   allows waiting for buffers to be filled with grabbed data. */                hWait = Pylon.StreamGrabberGetWaitObject(hGrabber);                /* Determine the required size of the grab buffer. Since activating chunks will increase the                   payload size and thus the required buffer size, do this after enabling the chunks. */                payloadSize = checked((uint)Pylon.DeviceGetIntegerFeature(hDev, "PayloadSize"));                /* We must tell the stream grabber the number and size of the buffers                    we are using. */                /* .. We will not use more than NUM_BUFFERS for grabbing. */                Pylon.StreamGrabberSetMaxNumBuffer(hGrabber, NUM_BUFFERS);                /* .. We will not use buffers bigger than payloadSize bytes. */                Pylon.StreamGrabberSetMaxBufferSize(hGrabber, payloadSize);                /*  Allocate the resources required for grabbing. After this, critical parameters                    that impact the payload size must not be changed until FinishGrab() is called. */                Pylon.StreamGrabberPrepareGrab(hGrabber);                 /*                将缓冲区输入流抓取器的输入队列。对于每个缓冲区，API允许传递整数作为附加上下文信息。                抓取完成后，该整数将返回不变。在我们的示例中，我们使用缓冲区的索引作为上下文信息。                Before using the buffers for grabbing, they must be registered at                   the stream grabber. For each registered buffer, a buffer handle                   is returned. After registering, these handles are used instead of the                   buffer objects pointers. The buffer objects are held in a dictionary,                   that provides access to the buffer using a handle as key.                 */                buffers = new Dictionary&lt;PYLON_STREAMBUFFER_HANDLE, PylonBuffer&lt;Byte&gt;&gt;();                for (i = 0; i &lt; NUM_BUFFERS; ++i)                {                    PylonBuffer&lt;Byte&gt; buffer = new PylonBuffer&lt;byte&gt;(payloadSize, true);                    PYLON_STREAMBUFFER_HANDLE handle = Pylon.StreamGrabberRegisterBuffer(hGrabber, ref buffer);                    buffers.Add(handle, buffer);                }                /* Feed the buffers into the stream grabber's input queue. For each buffer, the API                   allows passing in an integer as additional context information. This integer                   will be returned unchanged when the grab is finished. In our example, we use the index of the                   buffer as context information. */                i = 0;                foreach (KeyValuePair&lt;PYLON_STREAMBUFFER_HANDLE, PylonBuffer&lt;Byte&gt;&gt; pair in buffers)                {                    Pylon.StreamGrabberQueueBuffer(hGrabber, pair.Key, i++);                }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> -Basler -.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -basler -.NET -c# -基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#基础学习-1</title>
      <link href="/2022/09/04/c-ji-chu-xue-xi-1/"/>
      <url>/2022/09/04/c-ji-chu-xue-xi-1/</url>
      
        <content type="html"><![CDATA[<p>前言：<br>自己真正的编写自己的学习博客</p><h1 id="方法的类型"><a href="#方法的类型" class="headerlink" title="方法的类型"></a>方法的类型</h1><h2 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h2><p>方法就是函数。普通方法就是函数。在类中就是对于方法的“行为”进行描述。<br></p><h3 id="普通方法的语法格式"><a href="#普通方法的语法格式" class="headerlink" title="普通方法的语法格式"></a>普通方法的语法格式</h3><p>访问修饰符 返回值 方法名（参数列表）<br><br>{<br>    方法的具体功能<br>}  </p><pre class="line-numbers language-none"><code class="language-none">class Person{private string name;private int age;public string Name{get{return name};set{name=value};}//后面都可以使用Name进行取值与赋值}Person p1=new Person();p1.Name="zhangsan";name2=p1.Name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>构造方法可以队实例化出来的对象进行初始化<br></p><h3 id="构造方法的语法格式"><a href="#构造方法的语法格式" class="headerlink" title="构造方法的语法格式"></a>构造方法的语法格式</h3><p>public 类名()<br><br>{<br>    构造函数代码<br>}  </p><ol><li>构造方法要用public修饰  </li><li>构造方法没有返回值，切连void也不能写  </li><li>构造方法的方法名必须与类名一样  </li><li>构造方法可以有重载  </li><li>构造方法如果没有编写过会自动增加一个空的构造方法，但是手动编写有参或者无参数的构造方法后就不会自动添加了<pre class="line-numbers language-none"><code class="language-none">class Person{//无参数的构造方法public Person(){zhanwei}//两个参数的构造方法public Person(string name,int age){this.name=name;this.age=atge;}}//如何使用Person p2=new Person();Person p3=new Person("monkey",18);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="This关键字"><a href="#This关键字" class="headerlink" title="This关键字"></a>This关键字</h3><p>this 表示类内部的那个变量</p><h2 id="析构方法"><a href="#析构方法" class="headerlink" title="析构方法"></a>析构方法</h2><p>析构方法是常常用于清理一个对象与构造方法差不多是相反的东西</p><h3 id="析构方法的语法"><a href="#析构方法的语法" class="headerlink" title="析构方法的语法"></a>析构方法的语法</h3><p>～类名()<br>{<br>    析构方法代码体;<br>}  </p><ol><li>析构方法没有任何参数</li><li>析构方法没有返回值与访问修饰符</li><li>析构方法由系统自动调用</li><li>析构方法可以不屑。<pre class="line-numbers language-none"><code class="language-none">//构造语法//以后补充<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> -C# -日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -C# -基础学习 -类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>diyi</title>
      <link href="/2022/08/21/diyi/"/>
      <url>/2022/08/21/diyi/</url>
      
        <content type="html"><![CDATA[<p>自己完成的第一篇博客的认证<br>下面来测试一下各种markdown的基本语法</p><h1 id="第一部分-level-1"><a href="#第一部分-level-1" class="headerlink" title="第一部分 level 1"></a>第一部分 level 1</h1><p>输入 “mdi + tab” 会自动插入下面的图片标记<br>输入 “mdl + tab” 会自动生成下面的链接标记<br>是需要自己保存才会用自动改变吧  </p><p>怎么感觉使用有点卡顿吧<br>能够确定是需要保存才会展现出来,<br><br>两边的反应速度好像基本一致  </p><h2 id="倾斜-level-2"><a href="#倾斜-level-2" class="headerlink" title="倾斜 level 2"></a>倾斜 level 2</h2><p>展现<em>新的</em>一行<br></p><h2 id="加粗-level-2"><a href="#加粗-level-2" class="headerlink" title="加粗 level 2"></a>加粗 level 2</h2><p>新的<strong>展现</strong>一行</p><h2 id="引用语法-level-2"><a href="#引用语法-level-2" class="headerlink" title="引用语法 level 2"></a>引用语法 level 2</h2><blockquote><p>yinyong<br>deiwfh</p><blockquote><p>bfejsbf</p><blockquote><p>kdfe<br>dwad<br>fkefb<br>fbrehk<br>dfbjhwe</p></blockquote></blockquote></blockquote><h2 id="代码块展示-level-2"><a href="#代码块展示-level-2" class="headerlink" title="代码块展示 level 2"></a>代码块展示 level 2</h2><p>`</p>            nishuoyiwoshuoyi    `  <h2 id="围栏式代码块展示-level-2"><a href="#围栏式代码块展示-level-2" class="headerlink" title="围栏式代码块展示 level 2"></a>围栏式代码块展示 level 2</h2><pre class="line-numbers language-none"><code class="language-none">&lt;html&gt;    &lt;head&gt;    nishuoyiwoshuoyi    &lt;/head&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>这是一类分割线前</p><hr><p>这是一类分割线后，二类分割线后</p><hr><p>二类分割线后</p><h2 id="列表语法"><a href="#列表语法" class="headerlink" title="列表语法"></a>列表语法</h2><ol><li>Cheiese</li><li>English</li><li>France</li></ol><h2 id="链接语法"><a href="#链接语法" class="headerlink" title="链接语法"></a>链接语法</h2><p>这是一个链接<a href="https://zh.wikipedia.org/zh-tw/%E5%88%9D%E9%9F%B3%E6%9C%AA%E4%BE%86" title="miku殿下来了">守护最好的殿下</a></p><h2 id="图片语法"><a href="#图片语法" class="headerlink" title="图片语法"></a>图片语法</h2><p>一个带链接的图片（!<a href="%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5" title="图片title">图片alt</a>）<br><a href="https://markdown.com.cn/"><img src="/assets/img/shiprock.jpg" alt="沙漠中的岩石图片" title="Shiprock"></a></p><p>##最后友情提示可以直接使用html的语法</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
