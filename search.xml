<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C#事件学习-学习日志（1）</title>
      <link href="/2022/09/21/c-shi-jian-xue-xi-xue-xi-ri-zhi-1/"/>
      <url>/2022/09/21/c-shi-jian-xue-xi-xue-xi-ri-zhi-1/</url>
      
        <content type="html"><![CDATA[<h2 id="事件模型的五个组成部分"><a href="#事件模型的五个组成部分" class="headerlink" title="事件模型的五个组成部分"></a>事件模型的五个组成部分</h2><ol><li>事件的拥有者（event source,对象）</li><li>事件成员（event，成员）</li><li>事件的响应者（event subscriber，对象）</li><li>事件处理器（event handle，成员）——-本质上是一个回调方法</li><li>事件订阅–把事件处理器与事件关联在一起，本质上是一种以委托类型为基础的“约定”。</li></ol><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>事件处理器是成员方法</li><li>挂接事件处理器的时候，可以使用委托实例，也可以直接使用方法名，这是个“语法糖”</li><li>事件处理器对事件的订阅不是随意的，匹配与否由生命事件时所使用的委托类型来检测</li><li>事件可以是同步调用也可以是异步调用。</li></ol><p>事件的几种情况</p><h1 id="当时间的拥有者与事件的响应者不同的时候"><a href="#当时间的拥有者与事件的响应者不同的时候" class="headerlink" title="当时间的拥有者与事件的响应者不同的时候"></a>当时间的拥有者与事件的响应者不同的时候</h1><p>示例代码<br>这个代码主要是使用了Timer类中的timer.elapsed作为事件的成员，作用是在一定的事件后触发事件处理器<br>最后需要加一个ReadLine不然会直接退出。<br>Intercal属性的作用是设置事件触发的间隔时间，这里设置的一秒钟。<br>主体部分</p><pre class="line-numbers language-none"><code class="language-none">internal class Program{    static void Main(string[] args)    {        Timer timer = new Timer();        timer.Interval = 1000;        Boy boy = new Boy();        timer.Elapsed += Boy.Action;        timer.Start();        Console.ReadLine();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Boy类</p><pre class="line-numbers language-none"><code class="language-none">internal class Boy{    public Boy()    {    }    internal static void Action(object sender, ElapsedEventArgs e)    {        Console.WriteLine("jack");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一种的形式的实现</p><pre class="line-numbers language-none"><code class="language-none">static void Main(string[] args){    //# region 事件的拥有者与响应者不同    //Timer timer = new Timer();    //timer.Interval = 1000;    //Boy boy = new Boy();    //timer.Elapsed += Boy.Action;    //timer.Start();    //Console.ReadLine();    //# endregion    #region 事件的处理者是事件的拥有者字段    Form form = new Form();    Controller controller = new Controller(form);    form.ShowDialog();    #endregion}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>事件的拥有者</p><pre class="line-numbers language-none"><code class="language-none">class Controller {    private Form from;    public Controller(Form form)    {        if (form != null)        {            from = form;            this.from.Click += this.fromClicked;        }    }    private void fromClicked(object sender, EventArgs e)    {        this.from.Text = DateTime.Now.ToString();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="当事件的处理者与事件的拥有者是同一个"><a href="#当事件的处理者与事件的拥有者是同一个" class="headerlink" title="当事件的处理者与事件的拥有者是同一个"></a>当事件的处理者与事件的拥有者是同一个</h1><pre class="line-numbers language-none"><code class="language-none">static void Main(string[] args){    #region 事件的处理者是事件的拥有者字段    MyForm form = new MyForm();    form.Click += form.FormClicked;    form.ShowDialog();    #endregion}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>事件的拥有者与响应者都是form，此处选择继承的原因是form类是微软写死的，自己无法构成事件的相应，<br>但是你可以通过将继承，然后修改自己继承后的类，实现之前没有实现的功能。</p><pre class="line-numbers language-none"><code class="language-none">internal class Program{    static void Main(string[] args)    {        //# region 事件的拥有者与响应者不同        //Timer timer = new Timer();        //timer.Interval = 1000;        //Boy boy = new Boy();        //timer.Elapsed += Boy.Action;        //timer.Start();        //Console.ReadLine();        //# endregion        #region 事件的处理者是事件的拥有者字段        MyForm form = new MyForm();        form.Click += form.FormClicked;        form.ShowDialog();        #endregion    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="事件的响应者是事件的拥有者某个成员"><a href="#事件的响应者是事件的拥有者某个成员" class="headerlink" title="事件的响应者是事件的拥有者某个成员"></a>事件的响应者是事件的拥有者某个成员</h1><p>此处的例子中事件的响应者是按钮，事件的拥有者是form</p><pre class="line-numbers language-none"><code class="language-none">static void Main(string[] args){    #region 事件的处理者是事件的拥有者字段    MyForm form = new MyForm();    form.Click += form.FormClicked;    form.ShowDialog();    #endregion}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是对应的form的设计</p><pre class="line-numbers language-none"><code class="language-none">internal class MyForm:Form{    private TextBox textBox;    private Button button;    public MyForm()    {        this.textBox = new TextBox();        this.button = new Button();        this.Controls.Add(this.textBox);        this.Controls.Add(this.button);        this.button.Click += this.ButtonCliked;        this.button.Top = 20;    }    private void ButtonCliked(object sender, EventArgs e)    {        this.Text = DateTime.Now.ToString();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">```<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>```</p>]]></content>
      
      
      <categories>
          
          <category> -C# -日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -C# -基础学习 -事件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>耦合与内聚学习-学习日志（4）</title>
      <link href="/2022/09/14/c-yu-fa-xue-xi-xue-xi-ri-zhi-4/"/>
      <url>/2022/09/14/c-yu-fa-xue-xi-xue-xi-ri-zhi-4/</url>
      
        <content type="html"><![CDATA[<p>软件要做到高内聚，低耦合。<br>内聚就是一个模块内部各成分之间相关联的成都的度量<br>耦合就是程序结构中哥哥模块的相互关联的度量  </p><h2 id="内聚的分类：由高到低"><a href="#内聚的分类：由高到低" class="headerlink" title="内聚的分类：由高到低"></a>内聚的分类：由高到低</h2><p>内聚的分类：由高到低<br>功能内聚：知模块内的所有元素共同作用完成一个功能，缺一不可。<br>顺序内聚：一个模块中的哥哥处理元素都密切像关于同一个功能且必须顺序执行，迁移功能元素的输出就是下一个功能元素的输入。<br>通信内聚：模块内所有处理元素都在同一个数据结构中。<br>过程内聚：一个模块完成多个任务，这些任务必须按照指定的过程执行。<br>瞬时内聚：把需要同时执行的任务或者动作组合在一起（例如初始化模块）<br>逻辑内聚：模块完成逻辑上相关的一组任务。<br>偶然内聚：一个模块内的各个处理元素之间没有任何联系或者有松散的联系  </p><h2 id="耦合的分类：由高到低"><a href="#耦合的分类：由高到低" class="headerlink" title="耦合的分类：由高到低"></a>耦合的分类：由高到低</h2><p>耦合的分类：由高到低<br>内容耦合：一个模块直接使用另一个模块的内部数据，或者通过非正常入口转入另个一模块内部是，这种耦合关系叫做内容耦合<br>公共耦合:一组模块访问一个公共的数据环境，如全局数据变量<br>外部耦合：一组模块访问一个公共变量，这里指的是基本数据类型而不是数据结构躲着说是对象。<br>控制耦合：一个模块调用另一个模块的时候，传递的是控制变量，被调用模块通过该控制变量的值选择执行模块内莫伊功能，那么也就是说被调用的模块应该具有多个功能。<br>标记耦合：耦合模块之间以数据结构传递（比如在java中，传递就是一个对象）<br>数据耦合：耦合模块之间有调用关系，传递的是简单数据类型的值。<br>无直接耦合：两个模块之间没有直接的关系，他们从属于不同模块的控制与调用，它们之间不传递任何信息。  </p>]]></content>
      
      
      <categories>
          
          <category> -日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -基础学习 -软件工程 -内聚 -耦合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#语法学习-学习日志（3）</title>
      <link href="/2022/09/12/c-yu-fa-xue-xi-xue-xi-ri-zhi-3/"/>
      <url>/2022/09/12/c-yu-fa-xue-xi-xue-xi-ri-zhi-3/</url>
      
        <content type="html"><![CDATA[<p>前言，此处代码使用VS2022，。net6的模式，全部都是在主函数的个实例，所以可以直接实例化一些类。<br>一些工作中遇见的不懂得语法进行学习<br>主要分为1.反射，2.特性，3.委托，4.？？与？。等，5.where<br>6.class类一些基础特点，7.as的作用。</p><h1 id="一、委托"><a href="#一、委托" class="headerlink" title="一、委托"></a>一、委托</h1><p>委托两类：C#类提供的，自定义委托</p><h2 id="C-提供的委托（参数可有可无与返回值一定没有）action"><a href="#C-提供的委托（参数可有可无与返回值一定没有）action" class="headerlink" title="C#提供的委托（参数可有可无与返回值一定没有）action"></a>C#提供的委托（参数可有可无与返回值一定没有）action</h2><p>自定义个类与方法</p><pre class="line-numbers language-none"><code class="language-none">class Calculator{public void Report(){Console.WriteLinr("I have 3 methods");}public int ADD(int a,int b){int result = a+b;return result;}public int SUB(int a,int b){int result = a-b;return result;}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用方法<br>三种调用结果相同<br>第一种没有使用委托<br>后两种可以是基本相同</p><pre class="line-numbers language-none"><code class="language-none">static void Main(string {} args){Calulator calculator new Calculator();//acton只想方法Action action = new Action(calculator.Report);//以下三种方法调用结果相同//直接调用calculator.Report();//使用委托间接调用action.Invoke();//Invoke也可以省略掉action();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C-提供的委托（有参数与返回值）function"><a href="#C-提供的委托（有参数与返回值）function" class="headerlink" title="C#提供的委托（有参数与返回值）function"></a>C#提供的委托（有参数与返回值）function</h2><p>调用方法</p><pre class="line-numbers language-none"><code class="language-none">static void Main(string {} args){Calulator calculator new Calculator();Func&lt;int,int,int&gt; fun1 = new Fun&lt;int,int,int&gt;(calculator.ADD);Func&lt;int,int,int&gt; fun2 = new Fun&lt;int,int,int&gt;(calculator.AUB);int x=100;int y = 200;int z = 0;z = fun1(x,y);Console.WriteLine(z);z=fun2(x,y);Console.WriteLine(z);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C-自定义委托"><a href="#C-自定义委托" class="headerlink" title="C#自定义委托"></a>C#自定义委托</h2><p>委托就是一种类<br>注意声明委托的位置（一般写在命名空间下），可能会引起嵌套类<br>委托与所封装的方法必须“类型兼容”<br>返回值与参数列表的数据类型需要一致<br>以下是委托的声明</p><pre class="line-numbers language-none"><code class="language-none">public delegate int Calc(int x, int y);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以下是实现委托的类  </p><pre class="line-numbers language-none"><code class="language-none">clas Calculator{public int Add(int a, int b){retutn a+b;}public int Sub(int a,int b){return a-b;}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下是委托的具体实现<br>具不具有Invoke都是一样的。 </p><pre class="line-numbers language-none"><code class="language-none">class Program{static void Main(string[] args){Calculator calculator = new Calculator():Calc calc1= new Calc(calculator.Add(int a,int b));Calc calc2= new Calc(calculator.Sub(int a,int b));int a=10;int b=30;int c=0;c=calc1.Invoke(a,b);Console.WriteLine(c);c=calc2.Invoke(a,b);Console.WriteLine(c);c=calc2(a,b);Console.WriteLine(c);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="委托的一般使用"><a href="#委托的一般使用" class="headerlink" title="委托的一般使用"></a>委托的一般使用</h2><p>一般使用方法把方法当作参数传给另一个方法<br>这又可以分为两种用法<br>方法1 模板方法<br>借用指定的外部方法来产生结果</p><ol><li>相当于“填空题”</li><li>常位于代码中部</li><li>常用于委托有返回值<br>方法2 回调方法（callback），调用指定的外部方法</li><li>相当于“流水线”</li><li>常位于代码末尾</li><li>常委托无返回值</li></ol><h3 id="模板方法的例子"><a href="#模板方法的例子" class="headerlink" title="模板方法的例子"></a>模板方法的例子</h3><pre class="line-numbers language-none"><code class="language-none">/*这个部分主要是对于委托的一些使用测试， * 四个类，产品类product-具有产品的名称属性 * 包装类box-将产品包装起来，返回一个产品类的参数 * 进行包装类warrybox-具有一个方法wProduct 参数（是一个返回类型为Product类型的，参数为空的方法），返回值是（box类型） * 产品工厂类ProductFactory-具有两个无参数，返回类型为product类型的方法； * 主函数中引用了两个func1，func2分别采用两个方法。 *///此处是实例化两个类的实例，他们都是一个非静态函数，需要实例化才能调用对应的方法。虽然好像没有真的使用，但是可能真的指示//也是需要的。WaryProduct a=new WaryProduct();ProductFactory b = new ProductFactory();Func&lt;Product&gt; fun1 = new Func&lt;Product&gt;(b.Pizza);Func&lt;Product&gt; fun2 = new Func&lt;Product&gt;(b.Cola);Box box1 = a.wProduct(fun1);Console.WriteLine(box1.product.name);Box box2 = a.wProduct(fun2);Console.WriteLine(box2.product.name);class Product{    public string name { get; set; }}class Box{    public Product product { get; set; }}class WaryProduct{    public Box wProduct(Func&lt;Product&gt; getProduct)    {        Product product = getProduct();        Box box = new Box();        box.product = product;        return box;    }}class ProductFactory{    public Product Pizza()    {        Product product = new Product();        product.name = "pizza";        return product;    }    public Product Cola()    {        Product product = new Product();        product.name = "Cola";        return product;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="回调方法的使用"><a href="#回调方法的使用" class="headerlink" title="回调方法的使用"></a>回调方法的使用</h3><p>对比上一种的使用，回调方法主要是在某种情况下的调用，例如pizza的价格大于50时，执行回调方法。</p><pre class="line-numbers language-none"><code class="language-none">// See https://aka.ms/new-console-template for more information/*这个部分主要是对于委托的一些使用测试， * 四个类，产品类product-具有产品的名称属性 * 包装类box-将产品包装起来，返回一个产品类的参数 * 进行包装类warrybox-具有一个方法wProduct 参数（是一个返回类型为Product类型的，参数为空的方法），返回值是（box类型） * 产品工厂类ProductFactory-具有两个无参数，返回类型为product类型的方法； * 主函数中引用了两个func1，func2分别采用两个方法。 *///此处是实例化两个类的实例，他们都是一个非静态函数，需要实例化才能调用对应的方法。虽然好像没有真的使用，但是可能真的指示//也是需要的。WaryProduct a=new WaryProduct();ProductFactory b = new ProductFactory();Logger c = new Logger();Func&lt;Product&gt; fun1 = new Func&lt;Product&gt;(b.Pizza);Func&lt;Product&gt; fun2 = new Func&lt;Product&gt;(b.Cola);Action&lt;Product&gt; fun3 = new Action&lt;Product&gt;(c.Log);Box box1 = a.wProduct(fun1, fun3);Console.WriteLine(box1.product.name);Box box2 = a.wProduct(fun2, fun3);Console.WriteLine(box2.product.name);class Product{    public string name { get; set; }    public int price { get; set; }}class Box{    public Product product { get; set; }}class Logger{    public void Log(Product product)    {        Console.WriteLine("Product {0} is created at {1} ,its price is {2}"            , product.name, DateTime.UtcNow, product.price);    }}class WaryProduct{    public Box wProduct(Func&lt;Product&gt; getProduct,Action&lt;Product&gt; LogCallBack)    {        Product product = getProduct();        Box box = new Box();        box.product = product;        if (box.product.price &gt; 50)            LogCallBack(box.product);        return box;    }}class ProductFactory{    public Product Pizza()    {        Product product = new Product();        product.name = "pizza";        product.price = 60;        return product;    }    public Product Cola()    {        Product product = new Product();        product.name = "Cola";        product.price=40;        return product;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="多播委托"><a href="#多播委托" class="headerlink" title="多播委托"></a>多播委托</h2><p>MulticastDelegate<br>多播委托就是用一个委托执行多个委托，执行顺序是根据添加顺序<br>单播委托就是普通形态<br>例如下面这种代码  </p><pre class="line-numbers language-none"><code class="language-none">// See https://aka.ms/new-console-template for more informationStudent stu1 = new Student() { Id = 1, PenColor = ConsoleColor.Yellow };Student stu2 = new Student() { Id = 2, PenColor = ConsoleColor.Green };Student stu3 = new Student() { Id = 3, PenColor = ConsoleColor.Red };Action action1 = new Action(stu1.DoHomeWork);Action action2 = new Action(stu2.DoHomeWork);Action action3 = new Action(stu3.DoHomeWork);action1.Invoke();action2.Invoke();action3.Invoke();class Student{    public int Id { get; set; }    public ConsoleColor PenColor { get; set; }    public void DoHomeWork()    {        Console.ForegroundColor = this.PenColor;        for(int i = 0; i &lt; 5; i++)        {            Console.WriteLine("Student {0} doing homework {1} hour(s)",this.Id,i);            Thread.Sleep(1000);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多播委托举例  </p><pre class="line-numbers language-none"><code class="language-none">// See https://aka.ms/new-console-template for more informationStudent stu1 = new Student() { Id = 1, PenColor = ConsoleColor.Yellow };Student stu2 = new Student() { Id = 2, PenColor = ConsoleColor.Green };Student stu3 = new Student() { Id = 3, PenColor = ConsoleColor.Red };Action action1 = new Action(stu1.DoHomeWork);Action action2 = new Action(stu2.DoHomeWork);Action action3 = new Action(stu3.DoHomeWork);action1 += action2;action1 += action3;action1();class Student{    public int Id { get; set; }    public ConsoleColor PenColor { get; set; }    public void DoHomeWork()    {        Console.ForegroundColor = this.PenColor;        for(int i = 0; i &lt; 5; i++)        {            Console.WriteLine("Student {0} doing homework {1} hour(s)",this.Id,i);            Thread.Sleep(1000);        }            }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="委托的高级使用-隐式异步调用"><a href="#委托的高级使用-隐式异步调用" class="headerlink" title="委托的高级使用-隐式异步调用"></a>委托的高级使用-隐式异步调用</h2><p>每一个运行的程序都是一个进程<br>每一个进程可以有一个或者多个线程（therd）<br>同步调用是在同一个线程内<br>异步调用的底层机理是多线程<br>串行==同步==单线程，并行==异步==多线程<br>同步调用可以是间接调用，也可以是直接调用。上面这个例子就是间接调用，属于同步调用。<br>BegunInvoke(param1,param2)<br>param1是回调函数，第二个参数通常为null<br>此处运行失败，好像是这个版本VS不支持隐式的异步调用。  </p><pre class="line-numbers language-none"><code class="language-none">Student stu1 = new Student() { Id = 1, PenColor = ConsoleColor.Yellow };Student stu2 = new Student() { Id = 2, PenColor = ConsoleColor.Green };Student stu3 = new Student() { Id = 3, PenColor = ConsoleColor.Red };Action action1 = new Action(stu1.DoHomeWork);Action action2 = new Action(stu2.DoHomeWork);Action action3 = new Action(stu3.DoHomeWork);action1.BeginInvoke(null,null);class Student{    public int Id { get; set; }    public ConsoleColor PenColor { get; set; }    public void DoHomeWork()    {        Console.ForegroundColor = this.PenColor;        for(int i = 0; i &lt; 5; i++)        {            Console.WriteLine("Student {0} doing homework {1} hour(s)",this.Id,i);            Thread.Sleep(1000);        }            }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="委托的高级使用-显式异步调用Thread"><a href="#委托的高级使用-显式异步调用Thread" class="headerlink" title="委托的高级使用-显式异步调用Thread"></a>委托的高级使用-显式异步调用Thread</h2><pre class="line-numbers language-none"><code class="language-none">// See https://aka.ms/new-console-template for more informationStudent stu1 = new Student() { Id = 1, PenColor = ConsoleColor.Yellow };Student stu2 = new Student() { Id = 2, PenColor = ConsoleColor.Green };Student stu3 = new Student() { Id = 3, PenColor = ConsoleColor.Red };Thread thread1 = new Thread(new ThreadStart(stu1.DoHomeWork));Thread thread2 = new Thread(new ThreadStart(stu2.DoHomeWork));Thread thread3 = new Thread(new ThreadStart(stu3.DoHomeWork));thread1.Start();thread2.Start();thread3.Start();class Student{    public int Id { get; set; }    public ConsoleColor PenColor { get; set; }    public void DoHomeWork()    {        Console.ForegroundColor = this.PenColor;        for(int i = 0; i &lt; 5; i++)        {            Console.WriteLine("Student {0} doing homework {1} hour(s)",this.Id,i);            Thread.Sleep(1000);        }            }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="委托的高级使用-显式异步调用Task"><a href="#委托的高级使用-显式异步调用Task" class="headerlink" title="委托的高级使用-显式异步调用Task"></a>委托的高级使用-显式异步调用Task</h2><pre class="line-numbers language-none"><code class="language-none">// See https://aka.ms/new-console-template for more informationStudent stu1 = new Student() { Id = 1, PenColor = ConsoleColor.Yellow };Student stu2 = new Student() { Id = 2, PenColor = ConsoleColor.Green };Student stu3 = new Student() { Id = 3, PenColor = ConsoleColor.Red };Task task1 = new Task(new Action(stu1.DoHomeWork));Task task2 = new Task(new Action(stu2.DoHomeWork));Task task3 = new Task(new Action(stu3.DoHomeWork));task1.Start();task2.Start();task3.Start();class Student{    public int Id { get; set; }    public ConsoleColor PenColor { get; set; }    public void DoHomeWork()    {        Console.ForegroundColor = this.PenColor;        for(int i = 0; i &lt; 5; i++)        {            Console.WriteLine("Student {0} doing homework {1} hour(s)",this.Id,i);            Thread.Sleep(1000);        }            }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h1><p>Datetime.now与Datetime.Utcnow的区别在于前一个带有时区  </p><h2 id="委托的缺陷"><a href="#委托的缺陷" class="headerlink" title="委托的缺陷"></a>委托的缺陷</h2><ol><li>方法级别的紧耦合，工作中要慎之又慎</li><li>使可读性下降，debug的难度增加</li><li>把委托回调，异步调用和多线程纠缠在一起，会让代码变得难以维护与阅读</li><li>委托使用不当有可能造成内存泄漏和程序性能下降</li></ol><h2 id="接口在一定的层次上代替委托"><a href="#接口在一定的层次上代替委托" class="headerlink" title="接口在一定的层次上代替委托"></a>接口在一定的层次上代替委托</h2><p>java没有委托，但是具有接口。依旧可以完成所有任务。接口比委托更加使用的上舒服  </p><h1 id="二、反射"><a href="#二、反射" class="headerlink" title="二、反射"></a>二、反射</h1><h1 id="三、特性"><a href="#三、特性" class="headerlink" title="三、特性"></a>三、特性</h1><p>delegate——-相当于函数指针的升级版</p><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="一、类class"><a href="#一、类class" class="headerlink" title="一、类class"></a>一、类class</h1><p>class.fun()———-这个是调用使用了方法<br>class.fun ———–指示到这个方法</p>]]></content>
      
      
      <categories>
          
          <category> -C# -日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -C# -基础学习 -委托 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#继承学习-学习日志（2）</title>
      <link href="/2022/09/05/c-ji-cheng-xue-xi-xue-xi-ri-zhi-2/"/>
      <url>/2022/09/05/c-ji-cheng-xue-xi-xue-xi-ri-zhi-2/</url>
      
        <content type="html"><![CDATA[<p>学习继承<br>面向对象的三大特性，封装继承多态</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的好处"><a href="#继承的好处" class="headerlink" title="继承的好处"></a>继承的好处</h2><ol><li>优化代码结构</li><li>提高代码的复用性</li><li>为多态提供前提</li></ol><h2 id="继承语法格式"><a href="#继承语法格式" class="headerlink" title="继承语法格式"></a>继承语法格式</h2><p>子类继承父类，用用”：“冒号关键字符<br>class 子类：父类<br>{<br>    //类成员<br>}<br>This关键字表示当前类<br>Base是上传到父类来处理</p><pre class="line-numbers language-none"><code class="language-none">//父类class Hero{private string heroName;private inr attack;//父类的构造方法public Hero () {}public Hero (string m_heroName.int m_attack){this.heroName=m_heroName;this.attack=m_attack;}//父类的方法public string HeroName{get {return HeroName;}set {heroName=value;}}public int Attack{get {return Attack;}set {attack=value;}}}//子类class Luka:Hero{public Luka(){}public Luka(string m_heroName.int m_attack):base(string m_heroName.int m_attack){}public void Suishidaji(){Console.WriteLine("随时打击");}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="子类继承父类的关系"><a href="#子类继承父类的关系" class="headerlink" title="子类继承父类的关系"></a>子类继承父类的关系</h2><p>父类中的字段，用private修饰的字段，我们在子类中无法访问<br>public修饰，子类可以访问。通过<em>base.字段名</em>的方式访问<br>大部分（80%是private）<br>父类中的属性，用private修饰的属性，我们在子类中无法访问<br>public修饰，子类可以访问。通过<em>base.属性名</em>的方式访问<br>大部分（80%是public）<br>父类中的普通方法，用private修饰的普通方法，我们在子类中无法访问<br>public修饰，子类可以访问。通过<em>base.方法名</em>的方式访问  </p><p>父类中的构造方法，用private修饰的字段，我们在子类中无法访问<br>public修饰，子类可以访问。通过<em>base（）</em>的方式访问<br>大部分（99%是public）</p>]]></content>
      
      
      <categories>
          
          <category> -C# -日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -C# -基础学习 -类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Basler语法学习</title>
      <link href="/2022/09/05/basler-yu-fa-xue-xi/"/>
      <url>/2022/09/05/basler-yu-fa-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>Basler语法学习</p><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="基础设备"><a href="#基础设备" class="headerlink" title="基础设备"></a>基础设备</h2><h3 id="basler设备的查找"><a href="#basler设备的查找" class="headerlink" title="basler设备的查找"></a>basler设备的查找</h3><h3 id="第一个设备的操作"><a href="#第一个设备的操作" class="headerlink" title="第一个设备的操作"></a>第一个设备的操作</h3><pre class="line-numbers language-none"><code class="language-none"> //声明一个设备  PYLON_DEVICE_HANDLE hDev = new PYLON_DEVICE_HANDLE();          /* Handle for the pylon device. */  try            {                uint numDevices;    /* Number of devices available. */#if DEBUG                /* This is a special debug setting needed only for GigE cameras.                See 'Building Applications with pylon' in the programmer's guide. */                Environment.SetEnvironmentVariable("PYLON_GIGE_HEARTBEAT", "300000" /*ms*/);#endif                /* Before using any pylon methods, the pylon runtime must be initialized. */                //Pylon初始化                Pylon.Initialize();                /* Enumerate all camera devices. You must call                Pylon.EnumerateDevices() before creating a device.                  枚举设备获得设备数量*/                numDevices = Pylon.EnumerateDevices();                if (0 == numDevices)                {                    throw new Exception("No devices found.");                }                /*hDev设为第一个设备的引用 Get a handle for the first device found.  */                hDev = Pylon.CreateDeviceByIndex(0);                /*在使用设备前打开此设备                 cPylonAccessModeControl==1 Write access to device features is allowed.                cPylonAccessModeStream = 2 Stream grabber access is allowed.                 ´Ë´¦Ê¹ÓÃÎ»»òÔËËã£¬¸ù¾ÝÔËËãµÄ½á¹ûµÃµ½ÏàÓ¦µÄÄ£Ê½¡£                PYLONC_ACCESS_MODE_CONTROL - Allows to read or write camera parameters to configure the camera.                 PYLONC_ACCESS_MODE_STREAM - Allows to read image data from the camera's stream grabber object.                 PYLONC_ACCESS_MODE_EVENT - Allows to read event data from the camera's stream grabber object.                 PYLONC_ACCESS_MODE_EXCLUSIVE - Allows exclusive access. When this flag is specified no other application may access the camera.                 PYLONC_ACCESS_MODE_MONITOR - Allows only read access. This flag cannot be combined with any other flags.                 It is typically used in Multicast/Broadcast applications with GigE cameras. You can pass one or more flags.                 If you pass more than one flag you can combine them using the 'or' operator.                 Before using the device, it must be opened. Open it for configuring                parameters and for grabbing images. */                Pylon.DeviceOpen(hDev, Pylon.cPylonAccessModeControl | Pylon.cPylonAccessModeStream);                /* Print out the name of the camera we are using. */                {                    bool isReadable;                    isReadable = Pylon.DeviceFeatureIsReadable(hDev, "DeviceModelName");                    if (isReadable)                    {                        string name = Pylon.DeviceFeatureToString(hDev, "DeviceModelName");                        Console.WriteLine("Using camera {0}", name);                    }                }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多个设备的批量设置"><a href="#多个设备的批量设置" class="headerlink" title="多个设备的批量设置"></a>多个设备的批量设置</h3><pre class="line-numbers language-none"><code class="language-none">        const uint MAX_NUM_DEVICES = 2;        const uint NUM_BUFFERS = 1;        /* Number of buffers used for grabbing. */        const uint GIGE_PACKET_SIZE = 1500; /* Size of one Ethernet packet. */        const uint GIGE_PROTOCOL_OVERHEAD = 36;   /* Total number of bytes of protocol overhead. */        const uint AllGroupMask = 0xffffffff;       /// &lt;summary&gt;        /// The main entry point for the application.        /// &lt;/summary&gt;        static void Main()        {            /* Use a random number as the device key. */            uint DeviceKey = (uint)(new Random()).Next(int.MaxValue);            /* In this sample all cameras belong to the same group. */            const uint GroupKey = 0x24;            PYLON_DEVICE_HANDLE[] hDev = new PYLON_DEVICE_HANDLE[MAX_NUM_DEVICES];        /* Handles for the pylon devices. */            for (int deviceIndex = 0; deviceIndex &lt; MAX_NUM_DEVICES; ++deviceIndex)            {                hDev[deviceIndex] = new PYLON_DEVICE_HANDLE();            }            try            {                uint numDevicesEnumerated;    /* Number of the devices connected to this PC. */                uint numDevicesToUse;         /* Number of the devices to use in this sample. */                bool isAvail;                 /* Used for checking feature availability. */                bool isReady;                 /* Used as an output parameter. */                int i;                        /* Counter. */                uint deviceIndex;             /* Index of device used in the following variables. */                PYLON_WAITOBJECTS_HANDLE wos; /* Wait objects. */                /* These are camera specific variables: */                PYLON_STREAMGRABBER_HANDLE[] hGrabber = new PYLON_STREAMGRABBER_HANDLE[MAX_NUM_DEVICES]; /* Handle for the pylon stream grabber. */                PYLON_WAITOBJECT_HANDLE[]    hWait = new PYLON_WAITOBJECT_HANDLE[MAX_NUM_DEVICES];       /* Handle used for waiting for a grab to be finished. */                uint[]                       payloadSize = new uint[MAX_NUM_DEVICES];                    /* Size of an image frame in bytes. */                uint[]                       nStreams = new uint[MAX_NUM_DEVICES];                       /* The number of streams provided by the device. */                PYLON_STREAMBUFFER_HANDLE[]  hBuffer = new PYLON_STREAMBUFFER_HANDLE[MAX_NUM_DEVICES];                PylonBuffer&lt;Byte&gt;[]          buffer = new PylonBuffer&lt;Byte&gt;[MAX_NUM_DEVICES];#if DEBUG                /* This is a special debug setting needed only for GigE cameras.                See 'Building Applications with pylon' in the Programmer's Guide. */                Environment.SetEnvironmentVariable("PYLON_GIGE_HEARTBEAT", "300000" /*ms*/);#endif                /* Before using any pylon methods, the pylon runtime must be initialized. */                Pylon.Initialize();                /* Enumerate all camera devices. You must call                PylonEnumerateDevices() before creating a device. */                numDevicesEnumerated = Pylon.EnumerateDevices();                if (numDevicesEnumerated == 0)                {                    Pylon.Terminate();                    Console.Error.WriteLine("No devices found!");                    Console.Error.WriteLine("\nPress enter to exit.");                    Console.ReadLine();                    return;                }                /* Create wait objects. This must be done outside of the loop. */                wos = Pylon.WaitObjectsCreate();                /* Open cameras and set parameter */                deviceIndex = 0;                for (uint enumeratedDeviceIndex = 0; enumeratedDeviceIndex &lt; numDevicesEnumerated; ++enumeratedDeviceIndex)                {                    /* only open GigE devices */                    PYLON_DEVICE_INFO_HANDLE hDI = Pylon.GetDeviceInfoHandle(enumeratedDeviceIndex);                    if (Pylon.DeviceInfoGetPropertyValueByName(hDI, Pylon.cPylonDeviceInfoDeviceClassKey) != "BaslerGigE")                    {                        continue;                    }                    /* Get handles for the devices. */                    hDev[deviceIndex] = Pylon.CreateDeviceByIndex((uint)enumeratedDeviceIndex);                    /* Before using the device, it must be opened. Open it for configuring                    parameters and for grabbing images. */                    Pylon.DeviceOpen(hDev[deviceIndex], Pylon.cPylonAccessModeControl | Pylon.cPylonAccessModeStream);                    /* Print out the name of the camera we are using. */                    Console.WriteLine("Using camera '{0}'", Pylon.DeviceInfoGetPropertyValueByName(hDI, Pylon.cPylonDeviceInfoModelNameKey));                    isAvail = Pylon.DeviceFeatureIsReadable(hDev[deviceIndex], "ActionControl");                    if (!isAvail)                    {                        throw new Exception("Device doesn't support the Action Command");                    }                    /* Configure the first action */                    Pylon.DeviceSetIntegerFeature(hDev[deviceIndex], "ActionSelector", 1);                    Pylon.DeviceSetIntegerFeature(hDev[deviceIndex], "ActionDeviceKey", DeviceKey);                    Pylon.DeviceSetIntegerFeature(hDev[deviceIndex], "ActionGroupKey", GroupKey);                    Pylon.DeviceSetIntegerFeature(hDev[deviceIndex], "ActionGroupMask", AllGroupMask);                    /* Set the pixel format to Mono8, where gray values will be output as 8 bit values for each pixel. */                    /* ... Check first to see if the device supports the Mono8 format. */                    isAvail = Pylon.DeviceFeatureIsAvailable(hDev[deviceIndex], "EnumEntry_PixelFormat_Mono8");                    if (!isAvail)                    {                        /* Feature is not available. */                        throw new Exception("Device doesn't support the Mono8 pixel format.");                    }                    /* ... Set the pixel format to Mono8. */                    Pylon.DeviceFeatureFromString(hDev[deviceIndex], "PixelFormat", "Mono8");                    /* Disable acquisition start trigger if available */                    isAvail = Pylon.DeviceFeatureIsAvailable(hDev[deviceIndex], "EnumEntry_TriggerSelector_AcquisitionStart");                    if (isAvail)                    {                        Pylon.DeviceFeatureFromString(hDev[deviceIndex], "TriggerSelector", "AcquisitionStart");                        Pylon.DeviceFeatureFromString(hDev[deviceIndex], "TriggerMode", "Off");                    }                    /* Disable line1 trigger if available */                    isAvail = Pylon.DeviceFeatureIsAvailable(hDev[deviceIndex], "EnumEntry_TriggerSelector_Line1");                    if (isAvail)                    {                        Pylon.DeviceFeatureFromString(hDev[deviceIndex], "TriggerSelector", "Line1");                        Pylon.DeviceFeatureFromString(hDev[deviceIndex], "TriggerMode", "Off");                    }                    /* Enable frame start trigger with first action */                    Pylon.DeviceFeatureFromString(hDev[deviceIndex], "TriggerSelector", "FrameStart");                    Pylon.DeviceFeatureFromString(hDev[deviceIndex], "TriggerMode", "On");                    Pylon.DeviceFeatureFromString(hDev[deviceIndex], "TriggerSource", "Action1");                    /* For GigE cameras, we recommend increasing the packet size for better                        performance. When the network adapter supports jumbo frames, set the packet                        size to a value &gt; 1500, e.g., to 8192. In this sample, we only set the packet size                        to 1500.                        We also set the Inter-Packet and the Frame Transmission delay                        so the switch can line up packets better.                    */                    Pylon.DeviceSetIntegerFeature(hDev[deviceIndex], "GevSCPSPacketSize", GIGE_PACKET_SIZE);                    Pylon.DeviceSetIntegerFeature(hDev[deviceIndex], "GevSCPD", (GIGE_PACKET_SIZE + GIGE_PROTOCOL_OVERHEAD) * (MAX_NUM_DEVICES - 1));                    Pylon.DeviceSetIntegerFeature(hDev[deviceIndex], "GevSCFTD", (GIGE_PACKET_SIZE + GIGE_PROTOCOL_OVERHEAD) * deviceIndex);                    /* one device opened */                    ++deviceIndex;                }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="显示设备名称"><a href="#显示设备名称" class="headerlink" title="显示设备名称"></a>显示设备名称</h3><p> 显示设备的名称</p><pre class="line-numbers language-none"><code class="language-none">/* Print out the name of the camera we are using. */               {                   bool isReadable;                   isReadable = Pylon.DeviceFeatureIsReadable(hDev, "DeviceModelName");                   if (isReadable)                   {                       string name = Pylon.DeviceFeatureToString(hDev, "DeviceModelName");                       Console.WriteLine("Using camera {0}", name);                   }               }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置拍摄图片模式"><a href="#设置拍摄图片模式" class="headerlink" title="设置拍摄图片模式"></a>设置拍摄图片模式</h3><pre class="line-numbers language-none"><code class="language-none">/* Set the pixel format to Mono8, where gray values will be output as 8 bit values for each pixel. */                /* ... Check first to see if the device supports the Mono8 format. */                isAvail = Pylon.DeviceFeatureIsAvailable(hDev, "EnumEntry_PixelFormat_Mono8");                if (!isAvail)                {                    /* Feature is not available. */                    throw new Exception("Device doesn't support the Mono8 pixel format.");                }                /* ... Set the pixel format to Mono8. */                Pylon.DeviceFeatureFromString(hDev, "PixelFormat", "Mono8");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置拍摄采集模式"><a href="#设置拍摄采集模式" class="headerlink" title="设置拍摄采集模式"></a>设置拍摄采集模式</h3><pre class="line-numbers language-none"><code class="language-none">/* Check the available camera trigger mode(s) to select the appropriate one: acquisition start trigger mode (used by previous cameras;                do not confuse with acquisition start command) or frame start trigger mode (equivalent to previous acquisition start trigger mode). */                isAvailAcquisitionStart = Pylon.DeviceFeatureIsAvailable(hDev, "EnumEntry_TriggerSelector_AcquisitionStart");                isAvailFrameStart = Pylon.DeviceFeatureIsAvailable(hDev, "EnumEntry_TriggerSelector_FrameStart");                /* Check to see if the camera implements the acquisition start trigger mode only.                优先是frame start （此时只有在半双工的时候才能打开frame burst帧突发），其次选择Acquisition Start。两种模式不能并存                */                if (isAvailAcquisitionStart &amp;&amp; !isAvailFrameStart)                {                    /* Camera uses the acquisition start trigger as the only trigger mode. */                    Pylon.DeviceFeatureFromString(hDev, "TriggerSelector", "AcquisitionStart");                    Pylon.DeviceFeatureFromString(hDev, "TriggerMode", "On");                    triggerSelectorValue = "AcquisitionStart";                }                else                {                    /* Camera may have the acquisition start trigger mode and the frame start trigger mode implemented.                    In this case, the acquisition trigger mode must be switched off. */                    if (isAvailAcquisitionStart)                    {                        Pylon.DeviceFeatureFromString(hDev, "TriggerSelector", "AcquisitionStart");                        Pylon.DeviceFeatureFromString(hDev, "TriggerMode", "Off");                    }                    /* Disable frame burst start trigger if available */                    isAvail = Pylon.DeviceFeatureIsAvailable(hDev, "EnumEntry_TriggerSelector_FrameBurstStart");                    if (isAvail)                    {                        Pylon.DeviceFeatureFromString(hDev, "TriggerSelector", "FrameBurstStart");                        Pylon.DeviceFeatureFromString(hDev, "TriggerMode", "Off");                    }                    /* To trigger each single frame by software or external hardware trigger: Enable the frame start trigger mode. */                    Pylon.DeviceFeatureFromString(hDev, "TriggerSelector", "FrameStart");                    Pylon.DeviceFeatureFromString(hDev, "TriggerMode", "On");                }                /* Note: the trigger selector must be set to the appropriate trigger mode                before setting the trigger source or issuing software triggers.                Frame start trigger mode for newer cameras, acquisition start trigger mode for previous cameras.                 软件触发*/                Pylon.DeviceFeatureFromString(hDev, "TriggerSelector", triggerSelectorValue);                /* Enable software triggering.                 持续采集*/                /* ... Select the software trigger as the trigger source. */                Pylon.DeviceFeatureFromString(hDev, "TriggerSource", "Software");                /* When using software triggering, the Continuous frame mode should be used. Once                   acquisition is started, the camera sends one image each time a software trigger is                   issued. */                Pylon.DeviceFeatureFromString(hDev, "AcquisitionMode", "Continuous");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置拍摄数据包大小"><a href="#设置拍摄数据包大小" class="headerlink" title="设置拍摄数据包大小"></a>设置拍摄数据包大小</h3><pre class="line-numbers language-none"><code class="language-none">/* For GigE cameras, we recommend increasing the packet size for better   performance. If the network adapter supports jumbo frames, set the packet   size to a value &gt; 1500, e.g., to 8192. In this sample, we only set the packet size   to 1500. *//* ... Check first to see if the GigE camera packet size parameter is supported and if it is writable. */isAvail = Pylon.DeviceFeatureIsWritable(hDev, "GevSCPSPacketSize");if (isAvail){    /* ... The device supports the packet size feature. Set a value. */    Pylon.DeviceSetIntegerFeature(hDev, "GevSCPSPacketSize", 1500);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置拍摄块"><a href="#设置拍摄块" class="headerlink" title="设置拍摄块"></a>设置拍摄块</h3><p>摄像机可以生成关于每个图像的特定信息，例如帧</p><p>计数器、时间戳和CRC校验和，作为数据“块”附加到图像数据。此示例演示了如何启用块功能，以及如何获取</p><p>以及如何处理附加数据。当相机处于块模式时，它传输数据块</p><p>其被划分成块。第一块总是图像数据。当块特征被启用时，</p><p>图像数据块之后是包含由块特征生成的信息的块。<br>本示例还演示了如何使用软件触发器。使用两个缓冲器。一旦缓冲器被填充，</p><p>在处理接收到的缓冲器之前触发下一帧的获取。这种方法允许：</p><p>在前一图像的处理进行的同时执行图像获取。</p><pre class="line-numbers language-none"><code class="language-none">/* Before enabling individual chunks, the chunk mode in general must be activated. */isAvail = Pylon.DeviceFeatureIsWritable(hDev, "ChunkModeActive");if (!isAvail){    throw new Exception("The device doesn't support the chunk mode.");}/* Activate the chunk mode. */Pylon.DeviceSetBooleanFeature(hDev, "ChunkModeActive", true);/* Enable some individual chunks... *//* ... The frame counter chunk feature. *//* Is the chunk feature available? */isAvail = Pylon.DeviceFeatureIsAvailable(hDev, "EnumEntry_ChunkSelector_Framecounter");if (isAvail){    /* Select the frame counter chunk feature. */    Pylon.DeviceFeatureFromString(hDev, "ChunkSelector", "Framecounter");    /* Can the chunk feature be activated? */    isAvail = Pylon.DeviceFeatureIsWritable(hDev, "ChunkEnable");    if (isAvail)    {        /* Activate the chunk feature. */        Pylon.DeviceSetBooleanFeature(hDev, "ChunkEnable", true);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="设置块chunks的内容"><a href="#设置块chunks的内容" class="headerlink" title="设置块chunks的内容"></a>设置块chunks的内容</h4><pre class="line-numbers language-none"><code class="language-none">//设置循环冗余校验（Cyclic Redundancy Check， CRC）是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种信道编码技术，主要用来检测或校验数据传输或者保存后可能出现的错误。它是利用除法及余数的原理来作错误侦测的。                /* ... The CRC checksum chunk feature. */                /*  Note: Enabling the CRC checksum chunk feature is not a prerequisite for using                   chunks. Chunks can also be handled when the CRC checksum chunk feature is disabled. */                isAvail = Pylon.DeviceFeatureIsAvailable(hDev, "EnumEntry_ChunkSelector_PayloadCRC16");                if (isAvail)                {                    /* Select the CRC checksum chunk feature. */                    Pylon.DeviceFeatureFromString(hDev, "ChunkSelector", "PayloadCRC16");                    /* Can the chunk feature be activated? */                    isAvail = Pylon.DeviceFeatureIsWritable(hDev, "ChunkEnable");                    if (isAvail)                    {                        /* Activate the chunk feature. */                        Pylon.DeviceSetBooleanFeature(hDev, "ChunkEnable", true);                    }                }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="设置块解析器chunk-parser"><a href="#设置块解析器chunk-parser" class="headerlink" title="设置块解析器chunk parser"></a>设置块解析器chunk parser</h4><pre class="line-numbers language-none"><code class="language-none">/* The data block containing the image chunk and the other chunks has a self-descriptive layout.   A chunk parser is used to extract the appended chunk data from the grabbed image frame.   Create a chunk parser. */hChunkParser = Pylon.DeviceCreateChunkParser(hDev);if (!hChunkParser.IsValid){    /* The transport layer doesn't provide a chunk parser. */    throw new Exception("No chunk parser available.");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="设置并分配拍摄流与缓冲区"><a href="#设置并分配拍摄流与缓冲区" class="headerlink" title="设置并分配拍摄流与缓冲区"></a>设置并分配拍摄流与缓冲区</h4><pre class="line-numbers language-none"><code class="language-none">/* Image grabbing is done using a stream grabber.                  A device may be able to provide different streams. A separate stream grabber must                  be used for each stream. In this sample, we create a stream grabber for the default                  stream, i.e., the first stream ( index == 0 ).                  */                /* Get the number of streams supported by the device and the transport layer. */                nStreams = Pylon.DeviceGetNumStreamGrabberChannels(hDev);                if (nStreams &lt; 1)                {                    throw new Exception("The transport layer doesn't support image streams.");                }                /* Create and open a stream grabber for the first channel. */                hGrabber = Pylon.DeviceGetStreamGrabber(hDev, 0);                Pylon.StreamGrabberOpen(hGrabber);                /* Get a handle for the stream grabber's wait object. The wait object                   allows waiting for buffers to be filled with grabbed data. */                hWait = Pylon.StreamGrabberGetWaitObject(hGrabber);                /* Determine the required size of the grab buffer. Since activating chunks will increase the                   payload size and thus the required buffer size, do this after enabling the chunks. */                payloadSize = checked((uint)Pylon.DeviceGetIntegerFeature(hDev, "PayloadSize"));                /* We must tell the stream grabber the number and size of the buffers                    we are using. */                /* .. We will not use more than NUM_BUFFERS for grabbing. */                Pylon.StreamGrabberSetMaxNumBuffer(hGrabber, NUM_BUFFERS);                /* .. We will not use buffers bigger than payloadSize bytes. */                Pylon.StreamGrabberSetMaxBufferSize(hGrabber, payloadSize);                /*  Allocate the resources required for grabbing. After this, critical parameters                    that impact the payload size must not be changed until FinishGrab() is called. */                Pylon.StreamGrabberPrepareGrab(hGrabber);                 /*                将缓冲区输入流抓取器的输入队列。对于每个缓冲区，API允许传递整数作为附加上下文信息。                抓取完成后，该整数将返回不变。在我们的示例中，我们使用缓冲区的索引作为上下文信息。                Before using the buffers for grabbing, they must be registered at                   the stream grabber. For each registered buffer, a buffer handle                   is returned. After registering, these handles are used instead of the                   buffer objects pointers. The buffer objects are held in a dictionary,                   that provides access to the buffer using a handle as key.                 */                buffers = new Dictionary&lt;PYLON_STREAMBUFFER_HANDLE, PylonBuffer&lt;Byte&gt;&gt;();                for (i = 0; i &lt; NUM_BUFFERS; ++i)                {                    PylonBuffer&lt;Byte&gt; buffer = new PylonBuffer&lt;byte&gt;(payloadSize, true);                    PYLON_STREAMBUFFER_HANDLE handle = Pylon.StreamGrabberRegisterBuffer(hGrabber, ref buffer);                    buffers.Add(handle, buffer);                }                /* Feed the buffers into the stream grabber's input queue. For each buffer, the API                   allows passing in an integer as additional context information. This integer                   will be returned unchanged when the grab is finished. In our example, we use the index of the                   buffer as context information. */                i = 0;                foreach (KeyValuePair&lt;PYLON_STREAMBUFFER_HANDLE, PylonBuffer&lt;Byte&gt;&gt; pair in buffers)                {                    Pylon.StreamGrabberQueueBuffer(hGrabber, pair.Key, i++);                }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> -Basler -.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -basler -.NET -c# -基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#基础学习-1</title>
      <link href="/2022/09/04/c-ji-chu-xue-xi-1/"/>
      <url>/2022/09/04/c-ji-chu-xue-xi-1/</url>
      
        <content type="html"><![CDATA[<p>前言：<br>自己真正的编写自己的学习博客</p><h1 id="方法的类型"><a href="#方法的类型" class="headerlink" title="方法的类型"></a>方法的类型</h1><h2 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h2><p>方法就是函数。普通方法就是函数。在类中就是对于方法的“行为”进行描述。<br></p><h3 id="普通方法的语法格式"><a href="#普通方法的语法格式" class="headerlink" title="普通方法的语法格式"></a>普通方法的语法格式</h3><p>访问修饰符 返回值 方法名（参数列表）<br><br>{<br>    方法的具体功能<br>}  </p><p>class Person<br>{<br>    private string name;<br>    private int age;<br>    public string Name<br>    {<br>        get{return name};<br>        set{name=value};<br>    }<br>    //后面都可以使用Name进行取值与赋值<br>}<br>Person p1=new Person();<br>p1.Name=”zhangsan”;<br>name2=p1.Name;</p><pre class="line-numbers language-none"><code class="language-none">## 构造方法构造方法可以队实例化出来的对象进行初始化&lt;br&gt;### 构造方法的语法格式public 类名()&lt;br&gt;{  构造函数代码  }  1. 构造方法要用public修饰  2. 构造方法没有返回值，切连void也不能写  3. 构造方法的方法名必须与类名一样  4. 构造方法可以有重载  5. 构造方法如果没有编写过会自动增加一个空的构造方法，但是手动编写有参或者无参数的构造方法后就不会自动添加了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>class Person<br>{<br>    //无参数的构造方法<br>    public Person()<br>    {<br>        zhanwei<br>    }<br>    //两个参数的构造方法<br>    public Person(string name,int age)<br>    {<br>        this.name=name;<br>        this.age=atge;<br>    }<br>}<br>//如何使用<br>Person p2=new Person();<br>Person p3=new Person(“monkey”,18);</p><pre class="line-numbers language-none"><code class="language-none">### This关键字this 表示类内部的那个变量## 析构方法析构方法是常常用于清理一个对象与构造方法差不多是相反的东西### 析构方法的语法～类名()  {  析构方法代码体;  }  1. 析构方法没有任何参数2. 析构方法没有返回值与访问修饰符3. 析构方法由系统自动调用4. 析构方法可以不屑。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>//构造语法<br>//以后补充</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> -C# -日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -C# -基础学习 -类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>diyi</title>
      <link href="/2022/08/21/diyi/"/>
      <url>/2022/08/21/diyi/</url>
      
        <content type="html"><![CDATA[<p>自己完成的第一篇博客的认证<br>下面来测试一下各种markdown的基本语法</p><h1 id="第一部分-level-1"><a href="#第一部分-level-1" class="headerlink" title="第一部分 level 1"></a>第一部分 level 1</h1><p>输入 “mdi + tab” 会自动插入下面的图片标记<br>输入 “mdl + tab” 会自动生成下面的链接标记<br>是需要自己保存才会用自动改变吧  </p><p>怎么感觉使用有点卡顿吧<br>能够确定是需要保存才会展现出来,<br><br>两边的反应速度好像基本一致  </p><h2 id="倾斜-level-2"><a href="#倾斜-level-2" class="headerlink" title="倾斜 level 2"></a>倾斜 level 2</h2><p>展现<em>新的</em>一行<br></p><h2 id="加粗-level-2"><a href="#加粗-level-2" class="headerlink" title="加粗 level 2"></a>加粗 level 2</h2><p>新的<strong>展现</strong>一行</p><h2 id="引用语法-level-2"><a href="#引用语法-level-2" class="headerlink" title="引用语法 level 2"></a>引用语法 level 2</h2><blockquote><p>yinyong<br>deiwfh</p><blockquote><p>bfejsbf</p><blockquote><p>kdfe<br>dwad<br>fkefb<br>fbrehk<br>dfbjhwe</p></blockquote></blockquote></blockquote><h2 id="代码块展示-level-2"><a href="#代码块展示-level-2" class="headerlink" title="代码块展示 level 2"></a>代码块展示 level 2</h2><p>`</p>            nishuoyiwoshuoyi    `  <h2 id="围栏式代码块展示-level-2"><a href="#围栏式代码块展示-level-2" class="headerlink" title="围栏式代码块展示 level 2"></a>围栏式代码块展示 level 2</h2><pre class="line-numbers language-none"><code class="language-none">&lt;html&gt;    &lt;head&gt;    nishuoyiwoshuoyi    &lt;/head&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>这是一类分割线前</p><hr><p>这是一类分割线后，二类分割线后</p><hr><p>二类分割线后</p><h2 id="列表语法"><a href="#列表语法" class="headerlink" title="列表语法"></a>列表语法</h2><ol><li>Cheiese</li><li>English</li><li>France</li></ol><h2 id="链接语法"><a href="#链接语法" class="headerlink" title="链接语法"></a>链接语法</h2><p>这是一个链接<a href="https://zh.wikipedia.org/zh-tw/%E5%88%9D%E9%9F%B3%E6%9C%AA%E4%BE%86" title="miku殿下来了">守护最好的殿下</a></p><h2 id="图片语法"><a href="#图片语法" class="headerlink" title="图片语法"></a>图片语法</h2><p>一个带链接的图片（!<a href="%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5" title="图片title">图片alt</a>）<br><a href="https://markdown.com.cn/"><img src="/assets/img/shiprock.jpg" alt="沙漠中的岩石图片" title="Shiprock"></a></p><p>##最后友情提示可以直接使用html的语法</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
