<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Form操作-TextBox仅数字等输入，离开检测</title>
      <link href="/2022/10/09/form-cao-zuo-textbox-jin-shu-zi-deng-shu-ru-chi-kai-jian-ce/"/>
      <url>/2022/10/09/form-cao-zuo-textbox-jin-shu-zi-deng-shu-ru-chi-kai-jian-ce/</url>
      
        <content type="html"><![CDATA[<h1 id="仅支持数字等输入"><a href="#仅支持数字等输入" class="headerlink" title="仅支持数字等输入"></a>仅支持数字等输入</h1><p>有的时候我们对于一些控件，希望它仅仅支持部分文档的输入。比如端口号应该只有数字或者分隔符。因此在有了在界面中设置仅支持某种输入的方法。</p><pre class="line-numbers language-none"><code class="language-none">/// &lt;summary&gt;/// 设置Port只能输入数字与回车/// &lt;/summary&gt;/// &lt;param name="sender"&gt;&lt;/param&gt;/// &lt;param name="e"&gt;&lt;/param&gt;private void PortTextBox_KeyPress(object sender, KeyPressEventArgs e){    if (!((e.KeyChar &gt;= 48 &amp;&amp; e.KeyChar &lt;= 57) || e.KeyChar == 8))    {        e.Handled = true;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="离开或者输入时的检测"><a href="#离开或者输入时的检测" class="headerlink" title="离开或者输入时的检测"></a>离开或者输入时的检测</h1><p>想了下好像没有必要<br>那就提一嘴，主要就是在控件的事件，在可视化界面中，放在属性旁边的选项，能够帮助实现部分的功能。<br>比如离开，进入，按键等。</p>]]></content>
      
      
      <categories>
          
          <category> Form操作 </category>
          
          <category> 工作小技巧 </category>
          
          <category> TextBox </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Form操作 </tag>
            
            <tag> 日常学习 </tag>
            
            <tag> TextBox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XML-RPC</title>
      <link href="/2022/10/09/xml-rpc/"/>
      <url>/2022/10/09/xml-rpc/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">https://blog.csdn.net/qq_39024280/article/details/120861419?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-120861419-blog-95950589.pc_relevant_multi_platform_whitelistv3&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-120861419-blog-95950589.pc_relevant_multi_platform_whitelistv3&amp;utm_relevant_index=1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个博客内容可以直接使用<br>一些使用心得<br>尝试了一下封装在系统类中，完全可以  </p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> XML-RPC </category>
          
          <category> 工作技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 工作技巧 </tag>
            
            <tag> XML-RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Form操作-MessageBox</title>
      <link href="/2022/10/09/form-cao-zuo-messagebox/"/>
      <url>/2022/10/09/form-cao-zuo-messagebox/</url>
      
        <content type="html"><![CDATA[<p>参考文章<br><a href="https://blog.csdn.net/qq_44793656/article/details/124509495">https://blog.csdn.net/qq_44793656/article/details/124509495</a></p><pre class="line-numbers language-none"><code class="language-none">https://blog.csdn.net/qq_44793656/article/details/124509495<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Form操作 </category>
          
          <category> 工作技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Form操作 </tag>
            
            <tag> MessageBox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Form操作-二次确认弹窗</title>
      <link href="/2022/10/09/form-cao-zuo-er-ci-que-ren-dan-chuang/"/>
      <url>/2022/10/09/form-cao-zuo-er-ci-que-ren-dan-chuang/</url>
      
        <content type="html"><![CDATA[<p>在一些比较关键的功能上可以让进行二次确认，避免因为误操作而导致的损失。<br>示例代码是用于二次确认用户的界面关闭，可以在此基础上进行修改。 </p><pre class="line-numbers language-none"><code class="language-none">private void frmMain_FormClosing(object sender, FormClosingEventArgs e){    DialogResult Result = MessageBox.Show("程序将被关闭，请确认是否继续","警告", MessageBoxButtons.OKCancel);    if (Result == DialogResult.Cancel)    {        e.Cancel = true;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Form操作 </category>
          
          <category> 工作技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作技巧 </tag>
            
            <tag> Form操作 </tag>
            
            <tag> 二次确认 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP设置</title>
      <link href="/2022/10/09/ip-she-zhi/"/>
      <url>/2022/10/09/ip-she-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="IP校验"><a href="#IP校验" class="headerlink" title="IP校验"></a>IP校验</h1><p>检查输入是否符合IP格式，建议与IP是否未空混合使用</p><pre class="line-numbers language-none"><code class="language-none">public static bool IPCheck(string IP){    return Regex.IsMatch(IP, @"^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="获取设备当前IP"><a href="#获取设备当前IP" class="headerlink" title="获取设备当前IP"></a>获取设备当前IP</h1><p>获取当前设备的ip</p><pre class="line-numbers language-none"><code class="language-none">public string GetAddressIP(){    string AddressIP = string.Empty;    foreach (IPAddress _IPAddress in Dns.GetHostEntry(Dns.GetHostName()).AddressList)    {        if (_IPAddress.AddressFamily.ToString() == "InterNetwork")        {            AddressIP = _IPAddress.ToString();        }    }    return AddressIP;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> 工作技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 工作技巧 </tag>
            
            <tag> IP设置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Form操作-菜单栏与下拉框</title>
      <link href="/2022/10/09/form-cao-zuo-cai-dan-lan-yu-xia-la-kuang/"/>
      <url>/2022/10/09/form-cao-zuo-cai-dan-lan-yu-xia-la-kuang/</url>
      
        <content type="html"><![CDATA[<p>窗口上端的菜单栏<br>MenuItemInstallService<br>记得添加一个menuScrip属性的控件<br>设置之后依次添加，见天click事件也是可以的。<br>下拉框<br>combox<br>Combox.selectIndex表示当前所选择的值的编号<br>combox.index表示编号从0开始计数，0，1，2，3，4…  </p>]]></content>
      
      
      <categories>
          
          <category> Form操作 </category>
          
          <category> 工作技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Form操作 </tag>
            
            <tag> 菜单栏 </tag>
            
            <tag> 下拉框 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Form操作-TextBox显示服务状态</title>
      <link href="/2022/10/09/form-cao-zuo-textbox-xian-shi-fu-wu-zhuang-tai/"/>
      <url>/2022/10/09/form-cao-zuo-textbox-xian-shi-fu-wu-zhuang-tai/</url>
      
        <content type="html"><![CDATA[<h1 id="TextBox显示状态（status）"><a href="#TextBox显示状态（status）" class="headerlink" title="TextBox显示状态（status）"></a>TextBox显示状态（status）</h1><p>在界面张添加timer控件，<br>设置enable=true这个属性是是否启用，<br>interval=1000此处单位为毫秒，这个属性是时间间隔<br>然后在事件中选择tick，绑定需要执行的方法。<br>状态文本可以显示在TextBox。Text中，可以将TextBox.Enable=false这样界面中文本框就不能显示了。</p>]]></content>
      
      
      <categories>
          
          <category> Form操作 </category>
          
          <category> 工作技巧 </category>
          
          <category> TextBox </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Form操作 </tag>
            
            <tag> 日常学习 </tag>
            
            <tag> TextBox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>管理员权限运行程序</title>
      <link href="/2022/10/09/guan-li-yuan-quan-xian-yun-xing-cheng-xu/"/>
      <url>/2022/10/09/guan-li-yuan-quan-xian-yun-xing-cheng-xu/</url>
      
        <content type="html"><![CDATA[<p>在工作中由于使用的系统进程，这个需要管理员权限才可以实现对于进程的访问。因此打包出来的程序也是需要系统权限的验证。  </p><h1 id="两种方案"><a href="#两种方案" class="headerlink" title="两种方案"></a>两种方案</h1><h2 id="方案1-通过应用程序服务清单进行权限设置"><a href="#方案1-通过应用程序服务清单进行权限设置" class="headerlink" title="方案1-通过应用程序服务清单进行权限设置"></a>方案1-通过应用程序服务清单进行权限设置</h2><p>这个设置会在exe上有管理员标志。运行程序时会索取管理员权限。需要注意的的是添加应用程序服务清单是在你的启动program，如果在别的program中添加不起作用。  </p><pre class="line-numbers language-none"><code class="language-none">&lt;!-- UAC 清单选项     如果想要更改 Windows 用户帐户控制级别，请使用     以下节点之一替换 requestedExecutionLevel 节点。n&lt;requestedExecutionLevel  level="asInvoker" uiAccess="false" /&gt;&lt;requestedExecutionLevel  level="requireAdministrator" uiAccess="false" /&gt;&lt;requestedExecutionLevel  level="highestAvailable" uiAccess="false" /&gt;    指定 requestedExecutionLevel 元素将禁用文件和注册表虚拟化。    如果你的应用程序需要此虚拟化来实现向后兼容性，则删除此    元素。--&gt;&lt;requestedExecutionLevel level="requireAdministrator" uiAccess="false" /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方案2-手动索取管理员权限"><a href="#方案2-手动索取管理员权限" class="headerlink" title="方案2-手动索取管理员权限"></a>方案2-手动索取管理员权限</h2><p>此方案是在程序启动时检查是否管理员权限启动，如果不是就提示用户需要管理员权限启动，然后关闭程序。如果时管理员权限启动，则正常启动程序。<br>这里提供了一种如何在程序即将运行时，申请管理员权限的方案。  </p><pre class="line-numbers language-none"><code class="language-none">using System;using System.Collections.Generic;using System.Diagnostics;using System.Linq;using System.Reflection;using System.Security.Principal;using System.ServiceProcess;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;namespace XmlRpcApp{    static class Program    {        [STAThread]        static void Main()        {            var wi = WindowsIdentity.GetCurrent();            var wp = new WindowsPrincipal(wi);            bool runAsAdmin = wp.IsInRole(WindowsBuiltInRole.Administrator);            if (!runAsAdmin)            {                // It is not possible to launch a ClickOnce app as administrator directly,                // so instead we launch the app as administrator in a new process.                var processInfo = new ProcessStartInfo(Assembly.GetExecutingAssembly().CodeBase);                // The following properties run the new process as administrator                processInfo.UseShellExecute = true;                processInfo.Verb = "runas";                // Start the new process                try                {                    Process.Start(processInfo);                }                catch (Exception)                {                    // The user did not allow the application to run as administrator                    MessageBox.Show("This program requires administrator privileges to run");                }                // Shut down the current process                Application.Exit();            }            else            {                // We are running as administrator                Application.EnableVisualStyles();                Application.SetCompatibleTextRenderingDefault(false);                Application.Run(new ClientApp());            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考文章链接如下所示</p>]]></content>
      
      
      <categories>
          
          <category> 工作技巧 </category>
          
          <category> 管理员权限 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 工作技巧 </tag>
            
            <tag> 管理员权限程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改命名空间</title>
      <link href="/2022/10/09/xiu-gai-ming-ming-kong-jian/"/>
      <url>/2022/10/09/xiu-gai-ming-ming-kong-jian/</url>
      
        <content type="html"><![CDATA[<p>参考链接<br><a href="https://www.jb51.net/article/252677.htm">https://www.jb51.net/article/252677.htm</a></p><pre class="line-numbers language-none"><code class="language-none">https://www.jb51.net/article/252677.htm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 工作技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 修改命名空间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>批处理.bat返回上一层目录</title>
      <link href="/2022/10/09/pi-chu-li-bat-fan-hui-shang-yi-ceng-mu-lu/"/>
      <url>/2022/10/09/pi-chu-li-bat-fan-hui-shang-yi-ceng-mu-lu/</url>
      
        <content type="html"><![CDATA[<p>批处理目前看到的应用只有win的。bat文件中<br>这次遇见的问题是我文件自动导出到下一层，但是我需要使用上一层的某个exe，这个就是需要对于批处理文件的路径有一定的认识<br>我需要C：\ batch \路径。我如何才能获得这条道路？ 它工作正常如果我给绝对路径 -  </p><pre class="line-numbers language-none"><code class="language-none">%windir%\Microsoft.NET\Framework\v4.0.30319\InstallUtil.exe C:\batch\bin\ERecruitGenerateReportsWindowsService.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>您尝试使用%<del>1在目录结构中上升一级是创造性的并且语法完全无效。正确的语法同样简单 - 使用..\。 由于%</del>dp0以\结尾，因此不需要前导\。</p><pre class="line-numbers language-none"><code class="language-none">%windir%\Microsoft.NET\Framework\v4.0.30319\InstallUtil.exe %~dp0..\bin\ERecruitGenerateReportsWindowsService.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> 工作技巧 </category>
          
          <category> 批处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 工作技巧 </tag>
            
            <tag> 批处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AutoResetEvent与Waitone与set</title>
      <link href="/2022/10/09/autoresetevent-yu-waitone-yu-set/"/>
      <url>/2022/10/09/autoresetevent-yu-waitone-yu-set/</url>
      
        <content type="html"><![CDATA[<p>AutoResetEvent a1 = new AutoResetEvent(false);<br>不传入false默认为true，不会阻塞线程，所以必须传false。<br>WaitOne(int)； WaitOne(int,bool)； WaitOne(timespan,bool)；<br>第二个参数传true代表超时后由set()设置不阻塞线程，如果传入false，如:WaitOne(2000,false);当超过两秒后线程就解除阻塞了，也就是等第二次在进入此线程时候会直接执行并不会阻塞线程。<br>WaitOne返回值为true代表当前线程不阻塞，返回为false代表当前线程被阻塞。<br>WaitOne第二个参数：如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它(需要其他地方调用Set方法)，则为 true；否则为 false。<br>原文链接：<a href="https://blog.csdn.net/Liumotor/article/details/107085239">https://blog.csdn.net/Liumotor/article/details/107085239</a>  </p><pre class="line-numbers language-none"><code class="language-none">https://blog.csdn.net/Liumotor/article/details/107085239<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>仔细想了下为什么会用到这个知识。应该是面对不能够确定处理时间，但是事件的触发又是不受到控制的。在用户去手动处理一些内容的时候，避免用户再次接到新的弹窗，影响用户的操作。因此需要阻塞当前线程，然后去处理之前线程提出的问题，等到问题处理完毕之后，恢复线程的运行。很巧妙的设定。  </p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> AutoResetEvent </category>
          
          <category> waitone </category>
          
          <category> set </category>
          
          <category> 工作技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> AutoResetEvent </tag>
            
            <tag> waitone </tag>
            
            <tag> set </tag>
            
            <tag> 工作技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何获取列的构造方法以及对应的参数列表</title>
      <link href="/2022/10/09/ru-he-huo-qu-lie-de-gou-zao-fang-fa-yi-ji-dui-ying-de-can-shu-lie-biao/"/>
      <url>/2022/10/09/ru-he-huo-qu-lie-de-gou-zao-fang-fa-yi-ji-dui-ying-de-can-shu-lie-biao/</url>
      
        <content type="html"><![CDATA[<p>顾名思义，仅仅知道类的名字的时候去构造函数会很困难，通过这种方法可以获取对应的构造函数。</p><pre class="line-numbers language-none"><code class="language-none">Type type = typeof(MethodTest);// 输入参数：BindingFlags.Public，获取所有公开的构造函数Console.WriteLine("输入参数：BindingFlags.Public | BindingFlags.NonPublic，获取所有公开yu的构造函数：");ConstructorInfo[] infoArray2 = type.GetConstructors(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);foreach (ConstructorInfo info in infoArray2){    Console.WriteLine("这是一个公开的构造方法{0}", info.IsPublic);    Console.WriteLine("这是一个静态的构造方法{0}", info.IsStatic);    foreach(ParameterInfo a in info.GetParameters())    {        Console.WriteLine(a.ParameterType.ToString());    }    }Console.WriteLine();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面是对应的关键代码，下面是完整代码，演示如何去实现。</p><pre class="line-numbers language-none"><code class="language-none">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Reflection;using System.Runtime.InteropServices;using System.Threading.Tasks;using UnderAutomation.UniversalRobots.XmlRpc;namespace ReflectMethod{    class Program    {        static void Main(string[] args)        {            Type type = typeof(MethodTest);            // 输入参数：BindingFlags.Public，获取所有公开的构造函数            Console.WriteLine("输入参数：BindingFlags.Public | BindingFlags.NonPublic，获取所有公开yu的构造函数：");            ConstructorInfo[] infoArray2 = type.GetConstructors(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);            foreach (ConstructorInfo info in infoArray2)            {                Console.WriteLine("这是一个公开的构造方法{0}", info.IsPublic);                Console.WriteLine("这是一个静态的构造方法{0}", info.IsStatic);                foreach(ParameterInfo a in info.GetParameters())                {                    Console.WriteLine(a.ParameterType.ToString());                }                            }            Console.WriteLine();            //// 输入参数：BindingFlags.Public，获取所有公开的构造函数            //Console.WriteLine("输入参数：BindingFlags.Public | BindingFlags.Instance，获取所有公开的构造函数：");            //ConstructorInfo[] infoArray3 = type.GetConstructors(BindingFlags.Public | BindingFlags.Instance);            //foreach (ConstructorInfo info in infoArray3)            //{            //    Console.Write(info.IsStatic);            //    Console.Write(info.GetParameters().ToString());            //}            //Console.WriteLine();            //Console.WriteLine("输入参数：BindingFlags.Static | BindingFlags.NonPublic，获取所有静态的构造函数：");            //ConstructorInfo[] infoArray4 = type.GetConstructors(BindingFlags.Static | BindingFlags.NonPublic);            //foreach (ConstructorInfo info in infoArray4)            //{            //    Console.Write(info.IsStatic);            //    Console.Write(info.GetParameters().ToString());            //}            //Console.WriteLine();            //Console.WriteLine("输入参数：BindingFlags.NonPublic | BindingFlags.Instance，获取所有非公开的构造函数：");            //ConstructorInfo[] infoArray5 = type.GetConstructors(BindingFlags.NonPublic | BindingFlags.Instance);            //foreach (ConstructorInfo info in infoArray5)            //{            //    Console.Write(info.IsStatic);            //    Console.Write(info.GetParameters().ToString());            //}            Console.ReadKey();                    ////反射获取 命名空间+类名            //string className = "ReflectMethod.MethodTest";            //string methodName = "Sleep";            //int a;            //a = 10;            ////Type[] types = { typeof(string), typeof(string) };            //Type[] types = new Type[a];            ////传递参数            //Object[] paras = new Object[] { "name","18" };            //Type t = Type.GetType(className);            //object obj = Activator.CreateInstance(t);            ////直接调用            //MethodInfo method = t.GetMethod(methodName,types);            //method.Invoke(obj, paras);        }    }    class MethodTest    {        string name;        public MethodTest(string name)        {            this.name = name;        }        int age;        public MethodTest(int age)        {            this.age = age;        }        public void Sleep(string name,int age)        {            Console.WriteLine($"You have bean man,you must sleep alone,{name}");        }        public void Sleep(string name, string age)        {            Console.WriteLine($"You have bean {age} old,you must sleep alone,{name}");        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一些参数的说明<br>暂时掠过<br>通过方法名与参数获取对应的方法，不调用  </p><pre class="line-numbers language-none"><code class="language-none">//传递参数string className = "ConsoleApp2.ClassSample";string methodName = request.MethodName;var t = Type.GetType(className);object obj = Activator.CreateInstance(t);try{    #region 查找对应方法    MethodInfo[] info = t.GetMethods();    for (int i = 0; i &lt; info.Length; i++)    {        var md = info[i];        //方法名        string mothodName = md.Name;        //参数集合        ParameterInfo[] paramInfos = md.GetParameters();        //方法名相同且参数个数一样        if (mothodName == methodName &amp;&amp; paramInfos.Length == paras.Length)        {            md.Invoke(obj, paras);        }    }    #endregion}catch (Exception ex){    throw ex;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> 工作技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 工作技巧 </tag>
            
            <tag> 类的构造函数与参数列表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win服务的创建与卸载</title>
      <link href="/2022/10/09/win-fu-wu-de-chuang-jian-yu-xie-zai/"/>
      <url>/2022/10/09/win-fu-wu-de-chuang-jian-yu-xie-zai/</url>
      
        <content type="html"><![CDATA[<p>win服务的创建，参考链接  </p><pre class="line-numbers language-none"><code class="language-none">https://www.cnblogs.com/xiketang/p/16518053.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://www.cnblogs.com/xiketang/p/16518053.html">https://www.cnblogs.com/xiketang/p/16518053.html</a><br>可以参考这个链接中的环境配置  </p><pre class="line-numbers language-none"><code class="language-none">https://blog.csdn.net/weixin_43783990/article/details/123001345<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://blog.csdn.net/weixin_43783990/article/details/123001345">https://blog.csdn.net/weixin_43783990/article/details/123001345</a><br>win服务的删除，参考方法<br>第一种：通过Dos命令来 删除/卸载服务  </p><ol><li>开始 - 运行 -“cmd”。  </li><li>进入Dos命令行，输入命令：<br>sc delete VMUSBArbService<br>注意：VMUSBArbService是服务名称。<br>当然：也可以通过：sc –help 查看sc命令参数等信息等。<br>第二种方法：直接修改注册表 删除/卸载服务  </li><li>开始 - 运行 - “regedit”。  </li><li>在“HKEY_LOCAL_MACHINESYSTEMCurrentControlSetServices”中删除相应的 键值   即可！<br>额外的小tips<br>win+r cmd  services.msc<br>查看目前正在运行的服务<br>安装的目录文件路径<br>C:\Windows\Microsoft.NET\Framework\v4.0.30319</li></ol><p>在新建项目中选择，Windows服务<br>在service.cs中添加两个服务，一个serviceProcessInstaller<br>一个是serviceInstall,<br>然后设置他们对应的属性。<br>servicePrcessInstaller主要是设置Account，设置成为LocalSystem<br>这个比较重要<br>serviceInstall设置ServiceName，这个是服务名称<br>DisplayName，这个是展示的名称<br>StartType这个是触发方式<br>1.Description：表示服务说明（描述服务是干什么的）；<br>2.DisplayName：表示友好名称，可以理解为服务名的别名；<br>3.ServiceName：表示服务名，此为真正的服务名，与DisplayName是有区别的哦，是系统识别的依据；<br>这三个属性在WIN7及更高版本操作系统中，同属性但表示却不同：<br>本地服务列表中：（即：services.msc）<br>名称列显示的是DisplayName，<br>描述列显示的是Description。  </p><p>在WINDOWS任务管理器中的服务选项卡列表中：<br>名称列显示的是ServiceName，<br>描述列显示的是DisplayName。<br>本人之前就是被这三个属性给搞混了，出现安装成功，在任务管理器的服务列表中可以看到，但在服务列表中怎么也找不到，其实是将ServiceName与DisplayName搞错了。  </p><p>在生成的Onstart与Onclose中填入你想要开始与结束的时候触发的方法。<br>tips：服务需要结合管理员权限一节，这样运行不会出现因为管理员权限方面的问题。<br>还有如果是在path地方出现问题，考虑是因为自己的运行的城西x64或者x86的环境的问题。  </p>]]></content>
      
      
      <categories>
          
          <category> 工作技巧 </category>
          
          <category> Win服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作技巧 </tag>
            
            <tag> Win服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>根据方法名与参数列表调用对应方法</title>
      <link href="/2022/10/09/gen-ju-fang-fa-ming-yu-can-shu-lie-biao-diao-yong-dui-ying-fang-fa/"/>
      <url>/2022/10/09/gen-ju-fang-fa-ming-yu-can-shu-lie-biao-diao-yong-dui-ying-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>顾名思义，有的时候会使用RPC技术来实现一些方法的远程调用。有时候因为是使用其他人编写好的方法，让自己不能像xmlrpc.net描述的那种进行直接调用，但是可以获得需要调用的方法名称与参数列表，以及对应的值。面对这样的情况，就有了以下的代码。<br>这里是主要的实现方法<br>值得注意的点有  </p><ol><li>getmethod后面如果不设置types那样如果面对有重载的函数就会直接报错</li><li>activator。createInstanc（），第一个参数是类的名称，后面的参数是实例化类所需要的参数。<pre class="line-numbers language-none"><code class="language-none">//反射获取 命名空间+类名string className = "ReflectMethod.MethodTest";string methodName = "Sleep";Type[] types = { typeof(string), typeof(string) };//Type[] types = new Type[a];//传递参数Object[] paras = new Object[] { "name", "18" };Type t = Type.GetType(className);object obj = Activator.CreateInstance(t,1);//直接调用MethodInfo method = t.GetMethod(methodName, types);method.Invoke(obj, paras);Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>下面是用于验证的方法。<br>验证上面的方案是否成功。<pre class="line-numbers language-none"><code class="language-none">class MethodTest{    string name;    public MethodTest(string name)    {        this.name = name;    }    int age;    public MethodTest(int age)    {        this.age = age;    }    public void Sleep(string name,int age)    {        Console.WriteLine($"You have bean man,you must sleep alone,{name}");    }    public void Sleep(string name, string age)    {        Console.WriteLine($"You have bean {age} old,you must sleep alone,{name}");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> -实用小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -C# -部分内容的总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Navicat破解</title>
      <link href="/2022/10/09/navicat-po-jie/"/>
      <url>/2022/10/09/navicat-po-jie/</url>
      
        <content type="html"><![CDATA[<p>参考文档：<br><a href="https://www.cnblogs.com/wjdzh/p/16523956.html#_label1">https://www.cnblogs.com/wjdzh/p/16523956.html#_label1</a><br>安装包我的百度网盘，经过实际体验可以破解。  </p>]]></content>
      
      
      <categories>
          
          <category> -破解软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -破解软件 -Navicat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OFFICE破解</title>
      <link href="/2022/10/09/office-po-jie/"/>
      <url>/2022/10/09/office-po-jie/</url>
      
        <content type="html"><![CDATA[<p>可以用过OFFICE tools进行下载office<br>然后通过HEUkms这个软件进行破解升级<br>实际效果win11升级激活码激活成功。</p>]]></content>
      
      
      <categories>
          
          <category> -破解软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -破解软件 -OFFICE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无法启动计算机.上的服务</title>
      <link href="/2022/10/09/wu-fa-qi-dong-ji-suan-ji-shang-de-fu-wu/"/>
      <url>/2022/10/09/wu-fa-qi-dong-ji-suan-ji-shang-de-fu-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述1"><a href="#问题描述1" class="headerlink" title="问题描述1"></a>问题描述1</h1><p>无法启动计算机”.”上的服务****<br>内部异常<br>Win32Exception:服务没有及时响应启动或控制请求。  </p><h2 id="问题发生场景"><a href="#问题发生场景" class="headerlink" title="问题发生场景"></a>问题发生场景</h2><p>创建win服务，安装与卸载正常，一旦点开start就会报错。<br>今天遇见了这个问题。花了两天时间排查了一遍。经过排查，寻找到了原因。<br>主要的原因就是系统类的start的时候首先要加载类本身。但是因为类本身具有的某个变量，实例化了，但是实例化的过程有错误。这就导致类的加载失败，引起启动服务异常。  </p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>将类中的实例改成仅仅声明，而不去实例。============觉得是符合代码规范的。实际上错误还在。需要结合下面的方案一起使用。</li><li>将原本的错误进行修改，实例化类的错误原因进行找出并修改，问题很有可能是空赋值即对于null属性进行操作而导致的问题。</li></ol><h1 id="问题描述2"><a href="#问题描述2" class="headerlink" title="问题描述2"></a>问题描述2</h1><p>Win服务start的时候快速打开然后立刻关闭。  </p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>这个与上面原因基本一致，只不过这个实例变量存在于start方法中，方法响应快速，将原本应该打开的实例化的类因为原来的代码错误，快速被清理掉，引起服务的快速关闭。</p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><p>将原本的错误进行修改，实例化类的错误原因进行找出并修改，问题很有可能是空赋值即对于null属性进行操作而导致的问题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>需要养成良好的编码习惯，在class中仅仅声明而不去实例化。<br>注意初始化类时的一些基本变量的赋值是否会为null，是否支持null。</li><li>初始化为空的问题一种表现形式：在开始的时候因为赋值为空，不能够执行，或者执行报错。<br>再经过某些操作后，如赋值等。问题不出现，程序运行正常。<br>再重新生成解决方案后，问题依旧存在。</li></ol>]]></content>
      
      
      <categories>
          
          <category> -C# -平时学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -C# -工作问题 -解决问题 -事件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#事件学习-学习日志（1）</title>
      <link href="/2022/09/21/c-shi-jian-xue-xi-xue-xi-ri-zhi-1/"/>
      <url>/2022/09/21/c-shi-jian-xue-xi-xue-xi-ri-zhi-1/</url>
      
        <content type="html"><![CDATA[<h2 id="事件模型的五个组成部分"><a href="#事件模型的五个组成部分" class="headerlink" title="事件模型的五个组成部分"></a>事件模型的五个组成部分</h2><ol><li>事件的拥有者（event source,对象）</li><li>事件成员（event，成员）</li><li>事件的响应者（event subscriber，对象）</li><li>事件处理器（event handle，成员）——-本质上是一个回调方法</li><li>事件订阅–把事件处理器与事件关联在一起，本质上是一种以委托类型为基础的“约定”。</li></ol><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>事件处理器是成员方法</li><li>挂接事件处理器的时候，可以使用委托实例，也可以直接使用方法名，这是个“语法糖”</li><li>事件处理器对事件的订阅不是随意的，匹配与否由生命事件时所使用的委托类型来检测</li><li>事件可以是同步调用也可以是异步调用。</li></ol><p>事件的几种情况</p><h1 id="当时间的拥有者与事件的响应者不同的时候"><a href="#当时间的拥有者与事件的响应者不同的时候" class="headerlink" title="当时间的拥有者与事件的响应者不同的时候"></a>当时间的拥有者与事件的响应者不同的时候</h1><p>示例代码<br>这个代码主要是使用了Timer类中的timer.elapsed作为事件的成员，作用是在一定的事件后触发事件处理器<br>最后需要加一个ReadLine不然会直接退出。<br>Intercal属性的作用是设置事件触发的间隔时间，这里设置的一秒钟。<br>主体部分</p><pre class="line-numbers language-none"><code class="language-none">internal class Program{    static void Main(string[] args)    {        Timer timer = new Timer();        timer.Interval = 1000;        Boy boy = new Boy();        timer.Elapsed += Boy.Action;        timer.Start();        Console.ReadLine();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Boy类</p><pre class="line-numbers language-none"><code class="language-none">internal class Boy{    public Boy()    {    }    internal static void Action(object sender, ElapsedEventArgs e)    {        Console.WriteLine("jack");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一种的形式的实现</p><pre class="line-numbers language-none"><code class="language-none">static void Main(string[] args){    //# region 事件的拥有者与响应者不同    //Timer timer = new Timer();    //timer.Interval = 1000;    //Boy boy = new Boy();    //timer.Elapsed += Boy.Action;    //timer.Start();    //Console.ReadLine();    //# endregion    #region 事件的处理者是事件的拥有者字段    Form form = new Form();    Controller controller = new Controller(form);    form.ShowDialog();    #endregion}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>事件的拥有者</p><pre class="line-numbers language-none"><code class="language-none">class Controller {    private Form from;    public Controller(Form form)    {        if (form != null)        {            from = form;            this.from.Click += this.fromClicked;        }    }    private void fromClicked(object sender, EventArgs e)    {        this.from.Text = DateTime.Now.ToString();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="当事件的处理者与事件的拥有者是同一个"><a href="#当事件的处理者与事件的拥有者是同一个" class="headerlink" title="当事件的处理者与事件的拥有者是同一个"></a>当事件的处理者与事件的拥有者是同一个</h1><pre class="line-numbers language-none"><code class="language-none">static void Main(string[] args){    #region 事件的处理者是事件的拥有者字段    MyForm form = new MyForm();    form.Click += form.FormClicked;    form.ShowDialog();    #endregion}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>事件的拥有者与响应者都是form，此处选择继承的原因是form类是微软写死的，自己无法构成事件的相应，<br>但是你可以通过将继承，然后修改自己继承后的类，实现之前没有实现的功能。</p><pre class="line-numbers language-none"><code class="language-none">internal class Program{    static void Main(string[] args)    {        //# region 事件的拥有者与响应者不同        //Timer timer = new Timer();        //timer.Interval = 1000;        //Boy boy = new Boy();        //timer.Elapsed += Boy.Action;        //timer.Start();        //Console.ReadLine();        //# endregion        #region 事件的处理者是事件的拥有者字段        MyForm form = new MyForm();        form.Click += form.FormClicked;        form.ShowDialog();        #endregion    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="事件的响应者是事件的拥有者某个成员"><a href="#事件的响应者是事件的拥有者某个成员" class="headerlink" title="事件的响应者是事件的拥有者某个成员"></a>事件的响应者是事件的拥有者某个成员</h1><p>此处的例子中事件的响应者是按钮，事件的拥有者是form</p><pre class="line-numbers language-none"><code class="language-none">static void Main(string[] args){    #region 事件的处理者是事件的拥有者字段    MyForm form = new MyForm();    form.Click += form.FormClicked;    form.ShowDialog();    #endregion}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是对应的form的设计</p><pre class="line-numbers language-none"><code class="language-none">internal class MyForm:Form{    private TextBox textBox;    private Button button;    public MyForm()    {        this.textBox = new TextBox();        this.button = new Button();        this.Controls.Add(this.textBox);        this.Controls.Add(this.button);        this.button.Click += this.ButtonCliked;        this.button.Top = 20;    }    private void ButtonCliked(object sender, EventArgs e)    {        this.Text = DateTime.Now.ToString();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">```<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>```</p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 基础学习 </tag>
            
            <tag> 事件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>耦合与内聚学习-学习日志（4）</title>
      <link href="/2022/09/14/c-yu-fa-xue-xi-xue-xi-ri-zhi-4/"/>
      <url>/2022/09/14/c-yu-fa-xue-xi-xue-xi-ri-zhi-4/</url>
      
        <content type="html"><![CDATA[<p>软件要做到高内聚，低耦合。<br>内聚就是一个模块内部各成分之间相关联的成都的度量<br>耦合就是程序结构中哥哥模块的相互关联的度量  </p><h2 id="内聚的分类：由高到低"><a href="#内聚的分类：由高到低" class="headerlink" title="内聚的分类：由高到低"></a>内聚的分类：由高到低</h2><p>内聚的分类：由高到低<br>功能内聚：知模块内的所有元素共同作用完成一个功能，缺一不可。<br>顺序内聚：一个模块中的哥哥处理元素都密切像关于同一个功能且必须顺序执行，迁移功能元素的输出就是下一个功能元素的输入。<br>通信内聚：模块内所有处理元素都在同一个数据结构中。<br>过程内聚：一个模块完成多个任务，这些任务必须按照指定的过程执行。<br>瞬时内聚：把需要同时执行的任务或者动作组合在一起（例如初始化模块）<br>逻辑内聚：模块完成逻辑上相关的一组任务。<br>偶然内聚：一个模块内的各个处理元素之间没有任何联系或者有松散的联系  </p><h2 id="耦合的分类：由高到低"><a href="#耦合的分类：由高到低" class="headerlink" title="耦合的分类：由高到低"></a>耦合的分类：由高到低</h2><p>耦合的分类：由高到低<br>内容耦合：一个模块直接使用另一个模块的内部数据，或者通过非正常入口转入另个一模块内部是，这种耦合关系叫做内容耦合<br>公共耦合:一组模块访问一个公共的数据环境，如全局数据变量<br>外部耦合：一组模块访问一个公共变量，这里指的是基本数据类型而不是数据结构躲着说是对象。<br>控制耦合：一个模块调用另一个模块的时候，传递的是控制变量，被调用模块通过该控制变量的值选择执行模块内莫伊功能，那么也就是说被调用的模块应该具有多个功能。<br>标记耦合：耦合模块之间以数据结构传递（比如在java中，传递就是一个对象）<br>数据耦合：耦合模块之间有调用关系，传递的是简单数据类型的值。<br>无直接耦合：两个模块之间没有直接的关系，他们从属于不同模块的控制与调用，它们之间不传递任何信息。  </p>]]></content>
      
      
      <categories>
          
          <category> -日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -基础学习 -软件工程 -内聚 -耦合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#语法学习-学习日志（3）</title>
      <link href="/2022/09/12/c-yu-fa-xue-xi-xue-xi-ri-zhi-3/"/>
      <url>/2022/09/12/c-yu-fa-xue-xi-xue-xi-ri-zhi-3/</url>
      
        <content type="html"><![CDATA[<p>前言，此处代码使用VS2022，。net6的模式，全部都是在主函数的个实例，所以可以直接实例化一些类。<br>一些工作中遇见的不懂得语法进行学习<br>主要分为1.反射，2.特性，3.委托，4.？？与？。等，5.where<br>6.class类一些基础特点，7.as的作用。</p><h1 id="一、委托"><a href="#一、委托" class="headerlink" title="一、委托"></a>一、委托</h1><p>委托两类：C#类提供的，自定义委托</p><h2 id="C-提供的委托（参数可有可无与返回值一定没有）action"><a href="#C-提供的委托（参数可有可无与返回值一定没有）action" class="headerlink" title="C#提供的委托（参数可有可无与返回值一定没有）action"></a>C#提供的委托（参数可有可无与返回值一定没有）action</h2><p>自定义个类与方法</p><pre class="line-numbers language-none"><code class="language-none">class Calculator{public void Report(){Console.WriteLinr("I have 3 methods");}public int ADD(int a,int b){int result = a+b;return result;}public int SUB(int a,int b){int result = a-b;return result;}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用方法<br>三种调用结果相同<br>第一种没有使用委托<br>后两种可以是基本相同</p><pre class="line-numbers language-none"><code class="language-none">static void Main(string {} args){Calulator calculator new Calculator();//acton只想方法Action action = new Action(calculator.Report);//以下三种方法调用结果相同//直接调用calculator.Report();//使用委托间接调用action.Invoke();//Invoke也可以省略掉action();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C-提供的委托（有参数与返回值）function"><a href="#C-提供的委托（有参数与返回值）function" class="headerlink" title="C#提供的委托（有参数与返回值）function"></a>C#提供的委托（有参数与返回值）function</h2><p>调用方法</p><pre class="line-numbers language-none"><code class="language-none">static void Main(string {} args){Calulator calculator new Calculator();Func&lt;int,int,int&gt; fun1 = new Fun&lt;int,int,int&gt;(calculator.ADD);Func&lt;int,int,int&gt; fun2 = new Fun&lt;int,int,int&gt;(calculator.AUB);int x=100;int y = 200;int z = 0;z = fun1(x,y);Console.WriteLine(z);z=fun2(x,y);Console.WriteLine(z);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C-自定义委托"><a href="#C-自定义委托" class="headerlink" title="C#自定义委托"></a>C#自定义委托</h2><p>委托就是一种类<br>注意声明委托的位置（一般写在命名空间下），可能会引起嵌套类<br>委托与所封装的方法必须“类型兼容”<br>返回值与参数列表的数据类型需要一致<br>以下是委托的声明</p><pre class="line-numbers language-none"><code class="language-none">public delegate int Calc(int x, int y);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以下是实现委托的类  </p><pre class="line-numbers language-none"><code class="language-none">clas Calculator{public int Add(int a, int b){retutn a+b;}public int Sub(int a,int b){return a-b;}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下是委托的具体实现<br>具不具有Invoke都是一样的。 </p><pre class="line-numbers language-none"><code class="language-none">class Program{static void Main(string[] args){Calculator calculator = new Calculator():Calc calc1= new Calc(calculator.Add(int a,int b));Calc calc2= new Calc(calculator.Sub(int a,int b));int a=10;int b=30;int c=0;c=calc1.Invoke(a,b);Console.WriteLine(c);c=calc2.Invoke(a,b);Console.WriteLine(c);c=calc2(a,b);Console.WriteLine(c);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="委托的一般使用"><a href="#委托的一般使用" class="headerlink" title="委托的一般使用"></a>委托的一般使用</h2><p>一般使用方法把方法当作参数传给另一个方法<br>这又可以分为两种用法<br>方法1 模板方法<br>借用指定的外部方法来产生结果</p><ol><li>相当于“填空题”</li><li>常位于代码中部</li><li>常用于委托有返回值<br>方法2 回调方法（callback），调用指定的外部方法</li><li>相当于“流水线”</li><li>常位于代码末尾</li><li>常委托无返回值</li></ol><h3 id="模板方法的例子"><a href="#模板方法的例子" class="headerlink" title="模板方法的例子"></a>模板方法的例子</h3><pre class="line-numbers language-none"><code class="language-none">/*这个部分主要是对于委托的一些使用测试， * 四个类，产品类product-具有产品的名称属性 * 包装类box-将产品包装起来，返回一个产品类的参数 * 进行包装类warrybox-具有一个方法wProduct 参数（是一个返回类型为Product类型的，参数为空的方法），返回值是（box类型） * 产品工厂类ProductFactory-具有两个无参数，返回类型为product类型的方法； * 主函数中引用了两个func1，func2分别采用两个方法。 *///此处是实例化两个类的实例，他们都是一个非静态函数，需要实例化才能调用对应的方法。虽然好像没有真的使用，但是可能真的指示//也是需要的。WaryProduct a=new WaryProduct();ProductFactory b = new ProductFactory();Func&lt;Product&gt; fun1 = new Func&lt;Product&gt;(b.Pizza);Func&lt;Product&gt; fun2 = new Func&lt;Product&gt;(b.Cola);Box box1 = a.wProduct(fun1);Console.WriteLine(box1.product.name);Box box2 = a.wProduct(fun2);Console.WriteLine(box2.product.name);class Product{    public string name { get; set; }}class Box{    public Product product { get; set; }}class WaryProduct{    public Box wProduct(Func&lt;Product&gt; getProduct)    {        Product product = getProduct();        Box box = new Box();        box.product = product;        return box;    }}class ProductFactory{    public Product Pizza()    {        Product product = new Product();        product.name = "pizza";        return product;    }    public Product Cola()    {        Product product = new Product();        product.name = "Cola";        return product;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="回调方法的使用"><a href="#回调方法的使用" class="headerlink" title="回调方法的使用"></a>回调方法的使用</h3><p>对比上一种的使用，回调方法主要是在某种情况下的调用，例如pizza的价格大于50时，执行回调方法。</p><pre class="line-numbers language-none"><code class="language-none">// See https://aka.ms/new-console-template for more information/*这个部分主要是对于委托的一些使用测试， * 四个类，产品类product-具有产品的名称属性 * 包装类box-将产品包装起来，返回一个产品类的参数 * 进行包装类warrybox-具有一个方法wProduct 参数（是一个返回类型为Product类型的，参数为空的方法），返回值是（box类型） * 产品工厂类ProductFactory-具有两个无参数，返回类型为product类型的方法； * 主函数中引用了两个func1，func2分别采用两个方法。 *///此处是实例化两个类的实例，他们都是一个非静态函数，需要实例化才能调用对应的方法。虽然好像没有真的使用，但是可能真的指示//也是需要的。WaryProduct a=new WaryProduct();ProductFactory b = new ProductFactory();Logger c = new Logger();Func&lt;Product&gt; fun1 = new Func&lt;Product&gt;(b.Pizza);Func&lt;Product&gt; fun2 = new Func&lt;Product&gt;(b.Cola);Action&lt;Product&gt; fun3 = new Action&lt;Product&gt;(c.Log);Box box1 = a.wProduct(fun1, fun3);Console.WriteLine(box1.product.name);Box box2 = a.wProduct(fun2, fun3);Console.WriteLine(box2.product.name);class Product{    public string name { get; set; }    public int price { get; set; }}class Box{    public Product product { get; set; }}class Logger{    public void Log(Product product)    {        Console.WriteLine("Product {0} is created at {1} ,its price is {2}"            , product.name, DateTime.UtcNow, product.price);    }}class WaryProduct{    public Box wProduct(Func&lt;Product&gt; getProduct,Action&lt;Product&gt; LogCallBack)    {        Product product = getProduct();        Box box = new Box();        box.product = product;        if (box.product.price &gt; 50)            LogCallBack(box.product);        return box;    }}class ProductFactory{    public Product Pizza()    {        Product product = new Product();        product.name = "pizza";        product.price = 60;        return product;    }    public Product Cola()    {        Product product = new Product();        product.name = "Cola";        product.price=40;        return product;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="多播委托"><a href="#多播委托" class="headerlink" title="多播委托"></a>多播委托</h2><p>MulticastDelegate<br>多播委托就是用一个委托执行多个委托，执行顺序是根据添加顺序<br>单播委托就是普通形态<br>例如下面这种代码  </p><pre class="line-numbers language-none"><code class="language-none">// See https://aka.ms/new-console-template for more informationStudent stu1 = new Student() { Id = 1, PenColor = ConsoleColor.Yellow };Student stu2 = new Student() { Id = 2, PenColor = ConsoleColor.Green };Student stu3 = new Student() { Id = 3, PenColor = ConsoleColor.Red };Action action1 = new Action(stu1.DoHomeWork);Action action2 = new Action(stu2.DoHomeWork);Action action3 = new Action(stu3.DoHomeWork);action1.Invoke();action2.Invoke();action3.Invoke();class Student{    public int Id { get; set; }    public ConsoleColor PenColor { get; set; }    public void DoHomeWork()    {        Console.ForegroundColor = this.PenColor;        for(int i = 0; i &lt; 5; i++)        {            Console.WriteLine("Student {0} doing homework {1} hour(s)",this.Id,i);            Thread.Sleep(1000);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多播委托举例  </p><pre class="line-numbers language-none"><code class="language-none">// See https://aka.ms/new-console-template for more informationStudent stu1 = new Student() { Id = 1, PenColor = ConsoleColor.Yellow };Student stu2 = new Student() { Id = 2, PenColor = ConsoleColor.Green };Student stu3 = new Student() { Id = 3, PenColor = ConsoleColor.Red };Action action1 = new Action(stu1.DoHomeWork);Action action2 = new Action(stu2.DoHomeWork);Action action3 = new Action(stu3.DoHomeWork);action1 += action2;action1 += action3;action1();class Student{    public int Id { get; set; }    public ConsoleColor PenColor { get; set; }    public void DoHomeWork()    {        Console.ForegroundColor = this.PenColor;        for(int i = 0; i &lt; 5; i++)        {            Console.WriteLine("Student {0} doing homework {1} hour(s)",this.Id,i);            Thread.Sleep(1000);        }            }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="委托的高级使用-隐式异步调用"><a href="#委托的高级使用-隐式异步调用" class="headerlink" title="委托的高级使用-隐式异步调用"></a>委托的高级使用-隐式异步调用</h2><p>每一个运行的程序都是一个进程<br>每一个进程可以有一个或者多个线程（therd）<br>同步调用是在同一个线程内<br>异步调用的底层机理是多线程<br>串行==同步==单线程，并行==异步==多线程<br>同步调用可以是间接调用，也可以是直接调用。上面这个例子就是间接调用，属于同步调用。<br>BegunInvoke(param1,param2)<br>param1是回调函数，第二个参数通常为null<br>此处运行失败，好像是这个版本VS不支持隐式的异步调用。  </p><pre class="line-numbers language-none"><code class="language-none">Student stu1 = new Student() { Id = 1, PenColor = ConsoleColor.Yellow };Student stu2 = new Student() { Id = 2, PenColor = ConsoleColor.Green };Student stu3 = new Student() { Id = 3, PenColor = ConsoleColor.Red };Action action1 = new Action(stu1.DoHomeWork);Action action2 = new Action(stu2.DoHomeWork);Action action3 = new Action(stu3.DoHomeWork);action1.BeginInvoke(null,null);class Student{    public int Id { get; set; }    public ConsoleColor PenColor { get; set; }    public void DoHomeWork()    {        Console.ForegroundColor = this.PenColor;        for(int i = 0; i &lt; 5; i++)        {            Console.WriteLine("Student {0} doing homework {1} hour(s)",this.Id,i);            Thread.Sleep(1000);        }            }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="委托的高级使用-显式异步调用Thread"><a href="#委托的高级使用-显式异步调用Thread" class="headerlink" title="委托的高级使用-显式异步调用Thread"></a>委托的高级使用-显式异步调用Thread</h2><pre class="line-numbers language-none"><code class="language-none">// See https://aka.ms/new-console-template for more informationStudent stu1 = new Student() { Id = 1, PenColor = ConsoleColor.Yellow };Student stu2 = new Student() { Id = 2, PenColor = ConsoleColor.Green };Student stu3 = new Student() { Id = 3, PenColor = ConsoleColor.Red };Thread thread1 = new Thread(new ThreadStart(stu1.DoHomeWork));Thread thread2 = new Thread(new ThreadStart(stu2.DoHomeWork));Thread thread3 = new Thread(new ThreadStart(stu3.DoHomeWork));thread1.Start();thread2.Start();thread3.Start();class Student{    public int Id { get; set; }    public ConsoleColor PenColor { get; set; }    public void DoHomeWork()    {        Console.ForegroundColor = this.PenColor;        for(int i = 0; i &lt; 5; i++)        {            Console.WriteLine("Student {0} doing homework {1} hour(s)",this.Id,i);            Thread.Sleep(1000);        }            }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="委托的高级使用-显式异步调用Task"><a href="#委托的高级使用-显式异步调用Task" class="headerlink" title="委托的高级使用-显式异步调用Task"></a>委托的高级使用-显式异步调用Task</h2><pre class="line-numbers language-none"><code class="language-none">// See https://aka.ms/new-console-template for more informationStudent stu1 = new Student() { Id = 1, PenColor = ConsoleColor.Yellow };Student stu2 = new Student() { Id = 2, PenColor = ConsoleColor.Green };Student stu3 = new Student() { Id = 3, PenColor = ConsoleColor.Red };Task task1 = new Task(new Action(stu1.DoHomeWork));Task task2 = new Task(new Action(stu2.DoHomeWork));Task task3 = new Task(new Action(stu3.DoHomeWork));task1.Start();task2.Start();task3.Start();class Student{    public int Id { get; set; }    public ConsoleColor PenColor { get; set; }    public void DoHomeWork()    {        Console.ForegroundColor = this.PenColor;        for(int i = 0; i &lt; 5; i++)        {            Console.WriteLine("Student {0} doing homework {1} hour(s)",this.Id,i);            Thread.Sleep(1000);        }            }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h1><p>Datetime.now与Datetime.Utcnow的区别在于前一个带有时区  </p><h2 id="委托的缺陷"><a href="#委托的缺陷" class="headerlink" title="委托的缺陷"></a>委托的缺陷</h2><ol><li>方法级别的紧耦合，工作中要慎之又慎</li><li>使可读性下降，debug的难度增加</li><li>把委托回调，异步调用和多线程纠缠在一起，会让代码变得难以维护与阅读</li><li>委托使用不当有可能造成内存泄漏和程序性能下降</li></ol><h2 id="接口在一定的层次上代替委托"><a href="#接口在一定的层次上代替委托" class="headerlink" title="接口在一定的层次上代替委托"></a>接口在一定的层次上代替委托</h2><p>java没有委托，但是具有接口。依旧可以完成所有任务。接口比委托更加使用的上舒服  </p><h1 id="二、反射"><a href="#二、反射" class="headerlink" title="二、反射"></a>二、反射</h1><h1 id="三、特性"><a href="#三、特性" class="headerlink" title="三、特性"></a>三、特性</h1><p>delegate——-相当于函数指针的升级版</p><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="一、类class"><a href="#一、类class" class="headerlink" title="一、类class"></a>一、类class</h1><p>class.fun()———-这个是调用使用了方法<br>class.fun ———–指示到这个方法</p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 基础学习 </tag>
            
            <tag> 委托 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#继承学习-学习日志（2）</title>
      <link href="/2022/09/05/c-ji-cheng-xue-xi-xue-xi-ri-zhi-2/"/>
      <url>/2022/09/05/c-ji-cheng-xue-xi-xue-xi-ri-zhi-2/</url>
      
        <content type="html"><![CDATA[<p>学习继承<br>面向对象的三大特性，封装继承多态</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的好处"><a href="#继承的好处" class="headerlink" title="继承的好处"></a>继承的好处</h2><ol><li>优化代码结构</li><li>提高代码的复用性</li><li>为多态提供前提</li></ol><h2 id="继承语法格式"><a href="#继承语法格式" class="headerlink" title="继承语法格式"></a>继承语法格式</h2><p>子类继承父类，用用”：“冒号关键字符<br>class 子类：父类<br>{<br>    //类成员<br>}<br>This关键字表示当前类<br>Base是上传到父类来处理</p><pre class="line-numbers language-none"><code class="language-none">//父类class Hero{private string heroName;private inr attack;//父类的构造方法public Hero () {}public Hero (string m_heroName.int m_attack){this.heroName=m_heroName;this.attack=m_attack;}//父类的方法public string HeroName{get {return HeroName;}set {heroName=value;}}public int Attack{get {return Attack;}set {attack=value;}}}//子类class Luka:Hero{public Luka(){}public Luka(string m_heroName.int m_attack):base(string m_heroName.int m_attack){}public void Suishidaji(){Console.WriteLine("随时打击");}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="子类继承父类的关系"><a href="#子类继承父类的关系" class="headerlink" title="子类继承父类的关系"></a>子类继承父类的关系</h2><p>父类中的字段，用private修饰的字段，我们在子类中无法访问<br>public修饰，子类可以访问。通过<em>base.字段名</em>的方式访问<br>大部分（80%是private）<br>父类中的属性，用private修饰的属性，我们在子类中无法访问<br>public修饰，子类可以访问。通过<em>base.属性名</em>的方式访问<br>大部分（80%是public）<br>父类中的普通方法，用private修饰的普通方法，我们在子类中无法访问<br>public修饰，子类可以访问。通过<em>base.方法名</em>的方式访问  </p><p>父类中的构造方法，用private修饰的字段，我们在子类中无法访问<br>public修饰，子类可以访问。通过<em>base（）</em>的方式访问<br>大部分（99%是public）</p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 基础学习 </tag>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Basler语法学习</title>
      <link href="/2022/09/05/basler-yu-fa-xue-xi/"/>
      <url>/2022/09/05/basler-yu-fa-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>Basler语法学习</p><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="基础设备"><a href="#基础设备" class="headerlink" title="基础设备"></a>基础设备</h2><h3 id="basler设备的查找"><a href="#basler设备的查找" class="headerlink" title="basler设备的查找"></a>basler设备的查找</h3><h3 id="第一个设备的操作"><a href="#第一个设备的操作" class="headerlink" title="第一个设备的操作"></a>第一个设备的操作</h3><pre class="line-numbers language-none"><code class="language-none"> //声明一个设备  PYLON_DEVICE_HANDLE hDev = new PYLON_DEVICE_HANDLE();          /* Handle for the pylon device. */  try            {                uint numDevices;    /* Number of devices available. */#if DEBUG                /* This is a special debug setting needed only for GigE cameras.                See 'Building Applications with pylon' in the programmer's guide. */                Environment.SetEnvironmentVariable("PYLON_GIGE_HEARTBEAT", "300000" /*ms*/);#endif                /* Before using any pylon methods, the pylon runtime must be initialized. */                //Pylon初始化                Pylon.Initialize();                /* Enumerate all camera devices. You must call                Pylon.EnumerateDevices() before creating a device.                  枚举设备获得设备数量*/                numDevices = Pylon.EnumerateDevices();                if (0 == numDevices)                {                    throw new Exception("No devices found.");                }                /*hDev设为第一个设备的引用 Get a handle for the first device found.  */                hDev = Pylon.CreateDeviceByIndex(0);                /*在使用设备前打开此设备                 cPylonAccessModeControl==1 Write access to device features is allowed.                cPylonAccessModeStream = 2 Stream grabber access is allowed.                 ´Ë´¦Ê¹ÓÃÎ»»òÔËËã£¬¸ù¾ÝÔËËãµÄ½á¹ûµÃµ½ÏàÓ¦µÄÄ£Ê½¡£                PYLONC_ACCESS_MODE_CONTROL - Allows to read or write camera parameters to configure the camera.                 PYLONC_ACCESS_MODE_STREAM - Allows to read image data from the camera's stream grabber object.                 PYLONC_ACCESS_MODE_EVENT - Allows to read event data from the camera's stream grabber object.                 PYLONC_ACCESS_MODE_EXCLUSIVE - Allows exclusive access. When this flag is specified no other application may access the camera.                 PYLONC_ACCESS_MODE_MONITOR - Allows only read access. This flag cannot be combined with any other flags.                 It is typically used in Multicast/Broadcast applications with GigE cameras. You can pass one or more flags.                 If you pass more than one flag you can combine them using the 'or' operator.                 Before using the device, it must be opened. Open it for configuring                parameters and for grabbing images. */                Pylon.DeviceOpen(hDev, Pylon.cPylonAccessModeControl | Pylon.cPylonAccessModeStream);                /* Print out the name of the camera we are using. */                {                    bool isReadable;                    isReadable = Pylon.DeviceFeatureIsReadable(hDev, "DeviceModelName");                    if (isReadable)                    {                        string name = Pylon.DeviceFeatureToString(hDev, "DeviceModelName");                        Console.WriteLine("Using camera {0}", name);                    }                }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多个设备的批量设置"><a href="#多个设备的批量设置" class="headerlink" title="多个设备的批量设置"></a>多个设备的批量设置</h3><pre class="line-numbers language-none"><code class="language-none">        const uint MAX_NUM_DEVICES = 2;        const uint NUM_BUFFERS = 1;        /* Number of buffers used for grabbing. */        const uint GIGE_PACKET_SIZE = 1500; /* Size of one Ethernet packet. */        const uint GIGE_PROTOCOL_OVERHEAD = 36;   /* Total number of bytes of protocol overhead. */        const uint AllGroupMask = 0xffffffff;       /// &lt;summary&gt;        /// The main entry point for the application.        /// &lt;/summary&gt;        static void Main()        {            /* Use a random number as the device key. */            uint DeviceKey = (uint)(new Random()).Next(int.MaxValue);            /* In this sample all cameras belong to the same group. */            const uint GroupKey = 0x24;            PYLON_DEVICE_HANDLE[] hDev = new PYLON_DEVICE_HANDLE[MAX_NUM_DEVICES];        /* Handles for the pylon devices. */            for (int deviceIndex = 0; deviceIndex &lt; MAX_NUM_DEVICES; ++deviceIndex)            {                hDev[deviceIndex] = new PYLON_DEVICE_HANDLE();            }            try            {                uint numDevicesEnumerated;    /* Number of the devices connected to this PC. */                uint numDevicesToUse;         /* Number of the devices to use in this sample. */                bool isAvail;                 /* Used for checking feature availability. */                bool isReady;                 /* Used as an output parameter. */                int i;                        /* Counter. */                uint deviceIndex;             /* Index of device used in the following variables. */                PYLON_WAITOBJECTS_HANDLE wos; /* Wait objects. */                /* These are camera specific variables: */                PYLON_STREAMGRABBER_HANDLE[] hGrabber = new PYLON_STREAMGRABBER_HANDLE[MAX_NUM_DEVICES]; /* Handle for the pylon stream grabber. */                PYLON_WAITOBJECT_HANDLE[]    hWait = new PYLON_WAITOBJECT_HANDLE[MAX_NUM_DEVICES];       /* Handle used for waiting for a grab to be finished. */                uint[]                       payloadSize = new uint[MAX_NUM_DEVICES];                    /* Size of an image frame in bytes. */                uint[]                       nStreams = new uint[MAX_NUM_DEVICES];                       /* The number of streams provided by the device. */                PYLON_STREAMBUFFER_HANDLE[]  hBuffer = new PYLON_STREAMBUFFER_HANDLE[MAX_NUM_DEVICES];                PylonBuffer&lt;Byte&gt;[]          buffer = new PylonBuffer&lt;Byte&gt;[MAX_NUM_DEVICES];#if DEBUG                /* This is a special debug setting needed only for GigE cameras.                See 'Building Applications with pylon' in the Programmer's Guide. */                Environment.SetEnvironmentVariable("PYLON_GIGE_HEARTBEAT", "300000" /*ms*/);#endif                /* Before using any pylon methods, the pylon runtime must be initialized. */                Pylon.Initialize();                /* Enumerate all camera devices. You must call                PylonEnumerateDevices() before creating a device. */                numDevicesEnumerated = Pylon.EnumerateDevices();                if (numDevicesEnumerated == 0)                {                    Pylon.Terminate();                    Console.Error.WriteLine("No devices found!");                    Console.Error.WriteLine("\nPress enter to exit.");                    Console.ReadLine();                    return;                }                /* Create wait objects. This must be done outside of the loop. */                wos = Pylon.WaitObjectsCreate();                /* Open cameras and set parameter */                deviceIndex = 0;                for (uint enumeratedDeviceIndex = 0; enumeratedDeviceIndex &lt; numDevicesEnumerated; ++enumeratedDeviceIndex)                {                    /* only open GigE devices */                    PYLON_DEVICE_INFO_HANDLE hDI = Pylon.GetDeviceInfoHandle(enumeratedDeviceIndex);                    if (Pylon.DeviceInfoGetPropertyValueByName(hDI, Pylon.cPylonDeviceInfoDeviceClassKey) != "BaslerGigE")                    {                        continue;                    }                    /* Get handles for the devices. */                    hDev[deviceIndex] = Pylon.CreateDeviceByIndex((uint)enumeratedDeviceIndex);                    /* Before using the device, it must be opened. Open it for configuring                    parameters and for grabbing images. */                    Pylon.DeviceOpen(hDev[deviceIndex], Pylon.cPylonAccessModeControl | Pylon.cPylonAccessModeStream);                    /* Print out the name of the camera we are using. */                    Console.WriteLine("Using camera '{0}'", Pylon.DeviceInfoGetPropertyValueByName(hDI, Pylon.cPylonDeviceInfoModelNameKey));                    isAvail = Pylon.DeviceFeatureIsReadable(hDev[deviceIndex], "ActionControl");                    if (!isAvail)                    {                        throw new Exception("Device doesn't support the Action Command");                    }                    /* Configure the first action */                    Pylon.DeviceSetIntegerFeature(hDev[deviceIndex], "ActionSelector", 1);                    Pylon.DeviceSetIntegerFeature(hDev[deviceIndex], "ActionDeviceKey", DeviceKey);                    Pylon.DeviceSetIntegerFeature(hDev[deviceIndex], "ActionGroupKey", GroupKey);                    Pylon.DeviceSetIntegerFeature(hDev[deviceIndex], "ActionGroupMask", AllGroupMask);                    /* Set the pixel format to Mono8, where gray values will be output as 8 bit values for each pixel. */                    /* ... Check first to see if the device supports the Mono8 format. */                    isAvail = Pylon.DeviceFeatureIsAvailable(hDev[deviceIndex], "EnumEntry_PixelFormat_Mono8");                    if (!isAvail)                    {                        /* Feature is not available. */                        throw new Exception("Device doesn't support the Mono8 pixel format.");                    }                    /* ... Set the pixel format to Mono8. */                    Pylon.DeviceFeatureFromString(hDev[deviceIndex], "PixelFormat", "Mono8");                    /* Disable acquisition start trigger if available */                    isAvail = Pylon.DeviceFeatureIsAvailable(hDev[deviceIndex], "EnumEntry_TriggerSelector_AcquisitionStart");                    if (isAvail)                    {                        Pylon.DeviceFeatureFromString(hDev[deviceIndex], "TriggerSelector", "AcquisitionStart");                        Pylon.DeviceFeatureFromString(hDev[deviceIndex], "TriggerMode", "Off");                    }                    /* Disable line1 trigger if available */                    isAvail = Pylon.DeviceFeatureIsAvailable(hDev[deviceIndex], "EnumEntry_TriggerSelector_Line1");                    if (isAvail)                    {                        Pylon.DeviceFeatureFromString(hDev[deviceIndex], "TriggerSelector", "Line1");                        Pylon.DeviceFeatureFromString(hDev[deviceIndex], "TriggerMode", "Off");                    }                    /* Enable frame start trigger with first action */                    Pylon.DeviceFeatureFromString(hDev[deviceIndex], "TriggerSelector", "FrameStart");                    Pylon.DeviceFeatureFromString(hDev[deviceIndex], "TriggerMode", "On");                    Pylon.DeviceFeatureFromString(hDev[deviceIndex], "TriggerSource", "Action1");                    /* For GigE cameras, we recommend increasing the packet size for better                        performance. When the network adapter supports jumbo frames, set the packet                        size to a value &gt; 1500, e.g., to 8192. In this sample, we only set the packet size                        to 1500.                        We also set the Inter-Packet and the Frame Transmission delay                        so the switch can line up packets better.                    */                    Pylon.DeviceSetIntegerFeature(hDev[deviceIndex], "GevSCPSPacketSize", GIGE_PACKET_SIZE);                    Pylon.DeviceSetIntegerFeature(hDev[deviceIndex], "GevSCPD", (GIGE_PACKET_SIZE + GIGE_PROTOCOL_OVERHEAD) * (MAX_NUM_DEVICES - 1));                    Pylon.DeviceSetIntegerFeature(hDev[deviceIndex], "GevSCFTD", (GIGE_PACKET_SIZE + GIGE_PROTOCOL_OVERHEAD) * deviceIndex);                    /* one device opened */                    ++deviceIndex;                }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="显示设备名称"><a href="#显示设备名称" class="headerlink" title="显示设备名称"></a>显示设备名称</h3><p> 显示设备的名称</p><pre class="line-numbers language-none"><code class="language-none">/* Print out the name of the camera we are using. */               {                   bool isReadable;                   isReadable = Pylon.DeviceFeatureIsReadable(hDev, "DeviceModelName");                   if (isReadable)                   {                       string name = Pylon.DeviceFeatureToString(hDev, "DeviceModelName");                       Console.WriteLine("Using camera {0}", name);                   }               }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置拍摄图片模式"><a href="#设置拍摄图片模式" class="headerlink" title="设置拍摄图片模式"></a>设置拍摄图片模式</h3><pre class="line-numbers language-none"><code class="language-none">/* Set the pixel format to Mono8, where gray values will be output as 8 bit values for each pixel. */                /* ... Check first to see if the device supports the Mono8 format. */                isAvail = Pylon.DeviceFeatureIsAvailable(hDev, "EnumEntry_PixelFormat_Mono8");                if (!isAvail)                {                    /* Feature is not available. */                    throw new Exception("Device doesn't support the Mono8 pixel format.");                }                /* ... Set the pixel format to Mono8. */                Pylon.DeviceFeatureFromString(hDev, "PixelFormat", "Mono8");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置拍摄采集模式"><a href="#设置拍摄采集模式" class="headerlink" title="设置拍摄采集模式"></a>设置拍摄采集模式</h3><pre class="line-numbers language-none"><code class="language-none">/* Check the available camera trigger mode(s) to select the appropriate one: acquisition start trigger mode (used by previous cameras;                do not confuse with acquisition start command) or frame start trigger mode (equivalent to previous acquisition start trigger mode). */                isAvailAcquisitionStart = Pylon.DeviceFeatureIsAvailable(hDev, "EnumEntry_TriggerSelector_AcquisitionStart");                isAvailFrameStart = Pylon.DeviceFeatureIsAvailable(hDev, "EnumEntry_TriggerSelector_FrameStart");                /* Check to see if the camera implements the acquisition start trigger mode only.                优先是frame start （此时只有在半双工的时候才能打开frame burst帧突发），其次选择Acquisition Start。两种模式不能并存                */                if (isAvailAcquisitionStart &amp;&amp; !isAvailFrameStart)                {                    /* Camera uses the acquisition start trigger as the only trigger mode. */                    Pylon.DeviceFeatureFromString(hDev, "TriggerSelector", "AcquisitionStart");                    Pylon.DeviceFeatureFromString(hDev, "TriggerMode", "On");                    triggerSelectorValue = "AcquisitionStart";                }                else                {                    /* Camera may have the acquisition start trigger mode and the frame start trigger mode implemented.                    In this case, the acquisition trigger mode must be switched off. */                    if (isAvailAcquisitionStart)                    {                        Pylon.DeviceFeatureFromString(hDev, "TriggerSelector", "AcquisitionStart");                        Pylon.DeviceFeatureFromString(hDev, "TriggerMode", "Off");                    }                    /* Disable frame burst start trigger if available */                    isAvail = Pylon.DeviceFeatureIsAvailable(hDev, "EnumEntry_TriggerSelector_FrameBurstStart");                    if (isAvail)                    {                        Pylon.DeviceFeatureFromString(hDev, "TriggerSelector", "FrameBurstStart");                        Pylon.DeviceFeatureFromString(hDev, "TriggerMode", "Off");                    }                    /* To trigger each single frame by software or external hardware trigger: Enable the frame start trigger mode. */                    Pylon.DeviceFeatureFromString(hDev, "TriggerSelector", "FrameStart");                    Pylon.DeviceFeatureFromString(hDev, "TriggerMode", "On");                }                /* Note: the trigger selector must be set to the appropriate trigger mode                before setting the trigger source or issuing software triggers.                Frame start trigger mode for newer cameras, acquisition start trigger mode for previous cameras.                 软件触发*/                Pylon.DeviceFeatureFromString(hDev, "TriggerSelector", triggerSelectorValue);                /* Enable software triggering.                 持续采集*/                /* ... Select the software trigger as the trigger source. */                Pylon.DeviceFeatureFromString(hDev, "TriggerSource", "Software");                /* When using software triggering, the Continuous frame mode should be used. Once                   acquisition is started, the camera sends one image each time a software trigger is                   issued. */                Pylon.DeviceFeatureFromString(hDev, "AcquisitionMode", "Continuous");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置拍摄数据包大小"><a href="#设置拍摄数据包大小" class="headerlink" title="设置拍摄数据包大小"></a>设置拍摄数据包大小</h3><pre class="line-numbers language-none"><code class="language-none">/* For GigE cameras, we recommend increasing the packet size for better   performance. If the network adapter supports jumbo frames, set the packet   size to a value &gt; 1500, e.g., to 8192. In this sample, we only set the packet size   to 1500. *//* ... Check first to see if the GigE camera packet size parameter is supported and if it is writable. */isAvail = Pylon.DeviceFeatureIsWritable(hDev, "GevSCPSPacketSize");if (isAvail){    /* ... The device supports the packet size feature. Set a value. */    Pylon.DeviceSetIntegerFeature(hDev, "GevSCPSPacketSize", 1500);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置拍摄块"><a href="#设置拍摄块" class="headerlink" title="设置拍摄块"></a>设置拍摄块</h3><p>摄像机可以生成关于每个图像的特定信息，例如帧</p><p>计数器、时间戳和CRC校验和，作为数据“块”附加到图像数据。此示例演示了如何启用块功能，以及如何获取</p><p>以及如何处理附加数据。当相机处于块模式时，它传输数据块</p><p>其被划分成块。第一块总是图像数据。当块特征被启用时，</p><p>图像数据块之后是包含由块特征生成的信息的块。<br>本示例还演示了如何使用软件触发器。使用两个缓冲器。一旦缓冲器被填充，</p><p>在处理接收到的缓冲器之前触发下一帧的获取。这种方法允许：</p><p>在前一图像的处理进行的同时执行图像获取。</p><pre class="line-numbers language-none"><code class="language-none">/* Before enabling individual chunks, the chunk mode in general must be activated. */isAvail = Pylon.DeviceFeatureIsWritable(hDev, "ChunkModeActive");if (!isAvail){    throw new Exception("The device doesn't support the chunk mode.");}/* Activate the chunk mode. */Pylon.DeviceSetBooleanFeature(hDev, "ChunkModeActive", true);/* Enable some individual chunks... *//* ... The frame counter chunk feature. *//* Is the chunk feature available? */isAvail = Pylon.DeviceFeatureIsAvailable(hDev, "EnumEntry_ChunkSelector_Framecounter");if (isAvail){    /* Select the frame counter chunk feature. */    Pylon.DeviceFeatureFromString(hDev, "ChunkSelector", "Framecounter");    /* Can the chunk feature be activated? */    isAvail = Pylon.DeviceFeatureIsWritable(hDev, "ChunkEnable");    if (isAvail)    {        /* Activate the chunk feature. */        Pylon.DeviceSetBooleanFeature(hDev, "ChunkEnable", true);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="设置块chunks的内容"><a href="#设置块chunks的内容" class="headerlink" title="设置块chunks的内容"></a>设置块chunks的内容</h4><pre class="line-numbers language-none"><code class="language-none">//设置循环冗余校验（Cyclic Redundancy Check， CRC）是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种信道编码技术，主要用来检测或校验数据传输或者保存后可能出现的错误。它是利用除法及余数的原理来作错误侦测的。                /* ... The CRC checksum chunk feature. */                /*  Note: Enabling the CRC checksum chunk feature is not a prerequisite for using                   chunks. Chunks can also be handled when the CRC checksum chunk feature is disabled. */                isAvail = Pylon.DeviceFeatureIsAvailable(hDev, "EnumEntry_ChunkSelector_PayloadCRC16");                if (isAvail)                {                    /* Select the CRC checksum chunk feature. */                    Pylon.DeviceFeatureFromString(hDev, "ChunkSelector", "PayloadCRC16");                    /* Can the chunk feature be activated? */                    isAvail = Pylon.DeviceFeatureIsWritable(hDev, "ChunkEnable");                    if (isAvail)                    {                        /* Activate the chunk feature. */                        Pylon.DeviceSetBooleanFeature(hDev, "ChunkEnable", true);                    }                }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="设置块解析器chunk-parser"><a href="#设置块解析器chunk-parser" class="headerlink" title="设置块解析器chunk parser"></a>设置块解析器chunk parser</h4><pre class="line-numbers language-none"><code class="language-none">/* The data block containing the image chunk and the other chunks has a self-descriptive layout.   A chunk parser is used to extract the appended chunk data from the grabbed image frame.   Create a chunk parser. */hChunkParser = Pylon.DeviceCreateChunkParser(hDev);if (!hChunkParser.IsValid){    /* The transport layer doesn't provide a chunk parser. */    throw new Exception("No chunk parser available.");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="设置并分配拍摄流与缓冲区"><a href="#设置并分配拍摄流与缓冲区" class="headerlink" title="设置并分配拍摄流与缓冲区"></a>设置并分配拍摄流与缓冲区</h4><pre class="line-numbers language-none"><code class="language-none">/* Image grabbing is done using a stream grabber.                  A device may be able to provide different streams. A separate stream grabber must                  be used for each stream. In this sample, we create a stream grabber for the default                  stream, i.e., the first stream ( index == 0 ).                  */                /* Get the number of streams supported by the device and the transport layer. */                nStreams = Pylon.DeviceGetNumStreamGrabberChannels(hDev);                if (nStreams &lt; 1)                {                    throw new Exception("The transport layer doesn't support image streams.");                }                /* Create and open a stream grabber for the first channel. */                hGrabber = Pylon.DeviceGetStreamGrabber(hDev, 0);                Pylon.StreamGrabberOpen(hGrabber);                /* Get a handle for the stream grabber's wait object. The wait object                   allows waiting for buffers to be filled with grabbed data. */                hWait = Pylon.StreamGrabberGetWaitObject(hGrabber);                /* Determine the required size of the grab buffer. Since activating chunks will increase the                   payload size and thus the required buffer size, do this after enabling the chunks. */                payloadSize = checked((uint)Pylon.DeviceGetIntegerFeature(hDev, "PayloadSize"));                /* We must tell the stream grabber the number and size of the buffers                    we are using. */                /* .. We will not use more than NUM_BUFFERS for grabbing. */                Pylon.StreamGrabberSetMaxNumBuffer(hGrabber, NUM_BUFFERS);                /* .. We will not use buffers bigger than payloadSize bytes. */                Pylon.StreamGrabberSetMaxBufferSize(hGrabber, payloadSize);                /*  Allocate the resources required for grabbing. After this, critical parameters                    that impact the payload size must not be changed until FinishGrab() is called. */                Pylon.StreamGrabberPrepareGrab(hGrabber);                 /*                将缓冲区输入流抓取器的输入队列。对于每个缓冲区，API允许传递整数作为附加上下文信息。                抓取完成后，该整数将返回不变。在我们的示例中，我们使用缓冲区的索引作为上下文信息。                Before using the buffers for grabbing, they must be registered at                   the stream grabber. For each registered buffer, a buffer handle                   is returned. After registering, these handles are used instead of the                   buffer objects pointers. The buffer objects are held in a dictionary,                   that provides access to the buffer using a handle as key.                 */                buffers = new Dictionary&lt;PYLON_STREAMBUFFER_HANDLE, PylonBuffer&lt;Byte&gt;&gt;();                for (i = 0; i &lt; NUM_BUFFERS; ++i)                {                    PylonBuffer&lt;Byte&gt; buffer = new PylonBuffer&lt;byte&gt;(payloadSize, true);                    PYLON_STREAMBUFFER_HANDLE handle = Pylon.StreamGrabberRegisterBuffer(hGrabber, ref buffer);                    buffers.Add(handle, buffer);                }                /* Feed the buffers into the stream grabber's input queue. For each buffer, the API                   allows passing in an integer as additional context information. This integer                   will be returned unchanged when the grab is finished. In our example, we use the index of the                   buffer as context information. */                i = 0;                foreach (KeyValuePair&lt;PYLON_STREAMBUFFER_HANDLE, PylonBuffer&lt;Byte&gt;&gt; pair in buffers)                {                    Pylon.StreamGrabberQueueBuffer(hGrabber, pair.Key, i++);                }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> -Basler -.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -basler -.NET -c# -基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#基础学习-1</title>
      <link href="/2022/09/04/c-ji-chu-xue-xi-1/"/>
      <url>/2022/09/04/c-ji-chu-xue-xi-1/</url>
      
        <content type="html"><![CDATA[<p>前言：<br>自己真正的编写自己的学习博客</p><h1 id="方法的类型"><a href="#方法的类型" class="headerlink" title="方法的类型"></a>方法的类型</h1><h2 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h2><p>方法就是函数。普通方法就是函数。在类中就是对于方法的“行为”进行描述。<br></p><h3 id="普通方法的语法格式"><a href="#普通方法的语法格式" class="headerlink" title="普通方法的语法格式"></a>普通方法的语法格式</h3><p>访问修饰符 返回值 方法名（参数列表）<br><br>{<br>    方法的具体功能<br>}  </p><p>class Person<br>{<br>    private string name;<br>    private int age;<br>    public string Name<br>    {<br>        get{return name};<br>        set{name=value};<br>    }<br>    //后面都可以使用Name进行取值与赋值<br>}<br>Person p1=new Person();<br>p1.Name=”zhangsan”;<br>name2=p1.Name;</p><pre class="line-numbers language-none"><code class="language-none">## 构造方法构造方法可以队实例化出来的对象进行初始化&lt;br&gt;### 构造方法的语法格式public 类名()&lt;br&gt;{  构造函数代码  }  1. 构造方法要用public修饰  2. 构造方法没有返回值，切连void也不能写  3. 构造方法的方法名必须与类名一样  4. 构造方法可以有重载  5. 构造方法如果没有编写过会自动增加一个空的构造方法，但是手动编写有参或者无参数的构造方法后就不会自动添加了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>class Person<br>{<br>    //无参数的构造方法<br>    public Person()<br>    {<br>        zhanwei<br>    }<br>    //两个参数的构造方法<br>    public Person(string name,int age)<br>    {<br>        this.name=name;<br>        this.age=atge;<br>    }<br>}<br>//如何使用<br>Person p2=new Person();<br>Person p3=new Person(“monkey”,18);</p><pre class="line-numbers language-none"><code class="language-none">### This关键字this 表示类内部的那个变量## 析构方法析构方法是常常用于清理一个对象与构造方法差不多是相反的东西### 析构方法的语法～类名()  {  析构方法代码体;  }  1. 析构方法没有任何参数2. 析构方法没有返回值与访问修饰符3. 析构方法由系统自动调用4. 析构方法可以不屑。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>//构造语法<br>//以后补充</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> -C# -日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -C# -基础学习 -类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>diyi</title>
      <link href="/2022/08/21/diyi/"/>
      <url>/2022/08/21/diyi/</url>
      
        <content type="html"><![CDATA[<p>自己完成的第一篇博客的认证<br>下面来测试一下各种markdown的基本语法</p><h1 id="第一部分-level-1"><a href="#第一部分-level-1" class="headerlink" title="第一部分 level 1"></a>第一部分 level 1</h1><p>输入 “mdi + tab” 会自动插入下面的图片标记<br>输入 “mdl + tab” 会自动生成下面的链接标记<br>是需要自己保存才会用自动改变吧  </p><p>怎么感觉使用有点卡顿吧<br>能够确定是需要保存才会展现出来,<br><br>两边的反应速度好像基本一致  </p><h2 id="倾斜-level-2"><a href="#倾斜-level-2" class="headerlink" title="倾斜 level 2"></a>倾斜 level 2</h2><p>展现<em>新的</em>一行<br></p><h2 id="加粗-level-2"><a href="#加粗-level-2" class="headerlink" title="加粗 level 2"></a>加粗 level 2</h2><p>新的<strong>展现</strong>一行</p><h2 id="引用语法-level-2"><a href="#引用语法-level-2" class="headerlink" title="引用语法 level 2"></a>引用语法 level 2</h2><blockquote><p>yinyong<br>deiwfh</p><blockquote><p>bfejsbf</p><blockquote><p>kdfe<br>dwad<br>fkefb<br>fbrehk<br>dfbjhwe</p></blockquote></blockquote></blockquote><h2 id="代码块展示-level-2"><a href="#代码块展示-level-2" class="headerlink" title="代码块展示 level 2"></a>代码块展示 level 2</h2><p>`</p>            nishuoyiwoshuoyi    `  <h2 id="围栏式代码块展示-level-2"><a href="#围栏式代码块展示-level-2" class="headerlink" title="围栏式代码块展示 level 2"></a>围栏式代码块展示 level 2</h2><pre class="line-numbers language-none"><code class="language-none">&lt;html&gt;    &lt;head&gt;    nishuoyiwoshuoyi    &lt;/head&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>这是一类分割线前</p><hr><p>这是一类分割线后，二类分割线后</p><hr><p>二类分割线后</p><h2 id="列表语法"><a href="#列表语法" class="headerlink" title="列表语法"></a>列表语法</h2><ol><li>Cheiese</li><li>English</li><li>France</li></ol><h2 id="链接语法"><a href="#链接语法" class="headerlink" title="链接语法"></a>链接语法</h2><p>这是一个链接<a href="https://zh.wikipedia.org/zh-tw/%E5%88%9D%E9%9F%B3%E6%9C%AA%E4%BE%86" title="miku殿下来了">守护最好的殿下</a></p><h2 id="图片语法"><a href="#图片语法" class="headerlink" title="图片语法"></a>图片语法</h2><p>一个带链接的图片（!<a href="%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5" title="图片title">图片alt</a>）<br><a href="https://markdown.com.cn/"><img src="/assets/img/shiprock.jpg" alt="沙漠中的岩石图片" title="Shiprock"></a></p><p>##最后友情提示可以直接使用html的语法</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
