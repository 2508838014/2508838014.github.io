<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C#-PadLeft（）,PadRight（）用法</title>
      <link href="/2022/10/27/c-padleft-padright-yong-fa/"/>
      <url>/2022/10/27/c-padleft-padright-yong-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="C-中PadLeft（）、PadRight（）的用法"><a href="#C-中PadLeft（）、PadRight（）的用法" class="headerlink" title="C#中PadLeft（）、PadRight（）的用法"></a>C#中PadLeft（）、PadRight（）的用法</h1><p>PS\n<br>简单来说就是给字符串实现补位。\n<br>PadRight：固定长度输出，左对齐\n<br>PadLeft：固定长度输出，右对齐\n<br>参数不同，表示含义不同\n</p><h2 id="1-PadLeft-Int32-n"><a href="#1-PadLeft-Int32-n" class="headerlink" title="1).PadLeft(Int32)\n"></a>1).PadLeft(Int32)\n</h2><p>返回一个新字符串，该字符串通过在此实例中的字符左侧填充空格来达到指定的总长度，从而实现右对齐。\n</p><h2 id="2-PadLeft-Int32-Char-n"><a href="#2-PadLeft-Int32-Char-n" class="headerlink" title="2).PadLeft(Int32, Char)\n"></a>2).PadLeft(Int32, Char)\n</h2><p>返回一个新字符串，该字符串通过在此实例中的字符左侧填充指定的 Unicode 字符来达到指定的总长度，从而使这些字符右对齐。\n<br>实例：string num=12 num.PadLeft(4, ‘0’); //结果为为 ‘0012’ //看字符串长度是否满足4位,不满足则在字符串左边以”0”补足)\n<br>PadLeft(int totalWidth, char paddingChar) //在字符串左边用 paddingChar 补足 totalWidth 长度\n<br>PadRight(int totalWidth, char paddingChar) //在字符串右边用 paddingChar 补足 totalWidth 长度\n</p><h2 id="例：-n"><a href="#例：-n" class="headerlink" title="例：\n"></a>例：\n</h2><p>示例：\n</p><ol><li>假如想输出AAAAA，可以用string.Empty.PadLeft(5,‘A’);</li><li>假如想输出：<br>可以用PadLeft实现：<pre class="line-numbers language-none"><code class="language-none">for(int i=1;i&lt;=4;i++)\n{Console.WriteLine(string.Empty.PadLeft(i,’*’));}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>转载自：<br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.string.padleft?redirectedfrom=MSDN&amp;view=netframework-4.8#System_String_PadLeft_System_Int32">https://docs.microsoft.com/zh-cn/dotnet/api/system.string.padleft?redirectedfrom=MSDN&amp;view=netframework-4.8#System_String_PadLeft_System_Int32</a>_<br><a href="https://blog.csdn.net/xtfnpgy/article/details/24919145">https://blog.csdn.net/xtfnpgy/article/details/24919145</a></p>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> toString </tag>
            
            <tag> PadLeft() </tag>
            
            <tag> PadRight() </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Form操作-程序功能保活</title>
      <link href="/2022/10/27/form-cao-zuo-cheng-xu-gong-neng-bao-huo/"/>
      <url>/2022/10/27/form-cao-zuo-cheng-xu-gong-neng-bao-huo/</url>
      
        <content type="html"><![CDATA[<p>偶尔有的功能因为处理的事件过长。\n<br>需要进行延时处理，来确保进行功能不被后台直接回收\n<br>所以引用了一下函数，作用主要是界面保活\n</p><pre class="line-numbers language-none"><code class="language-none">public static bool Delay(int delayTime){    DateTime now = DateTime.Now;    int s;    do    {        TimeSpan spand = DateTime.Now - now;        s = spand.Seconds;        Application.DoEvents();    }    while (s &lt; delayTime);    return true;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Form </tag>
            
            <tag> 程序保活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#-字节流与图片转换</title>
      <link href="/2022/10/27/c-zi-jie-liu-yu-tu-pian-zhuan-huan/"/>
      <url>/2022/10/27/c-zi-jie-liu-yu-tu-pian-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<p>有的时候数据传输会使用字节流的模式进行传输。\n<br>字节流到达本地之后需要进行转换来进行对应的操作。\n</p><pre class="line-numbers language-none"><code class="language-none">            byte[] tempImgData= Encoding.Unicode.GetBytes(img.ToString());            MemoryStream stmBLOBData = new MemoryStream(tempImgData);//上面是将某种烈性转换成对应的字节流，//下面是将字节流转换成bitmap类型，并且保存。            Bitmap bt = new Bitmap，(stmBLOBData);            bt.Save($"D:\\image\\1_{DateTime.Now}.png", System.Drawing.Imaging.ImageFormat.Jpeg);            bt.Dispose();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
          <category> 字节流与图片转换 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 图片转化 </tag>
            
            <tag> 字节流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win服务start失败</title>
      <link href="/2022/10/26/win-fu-wu-start-shi-bai/"/>
      <url>/2022/10/26/win-fu-wu-start-shi-bai/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>试图加载格式不正确的程序\n</p><h1 id="出错场景"><a href="#出错场景" class="headerlink" title="出错场景"></a>出错场景</h1><p>Visual Studio 2019\n<br>尝试运行自己的win服务。\n<br>中间使用了其他人的dll-64位。\n</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>在每个项目的属性界面，将它们的目标平台都设置成为64位，于dll保持一致。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有的时候win服务需要引用其他dll来实现某些功能。\n<br>但是在一般的情况下64位的程序与32位的程序不能只能引用对应位数的dll文件。\n<br>如果不做设置，那样win服务就是默认是32位的，在面对64位程序就会出现错误\n<br>错误提示：<br>解决方案：切换成对应的x64或者x86程序。\n<br>win服务的要求更多一些。因为目前是有三个项目，分别负责form窗口，core，service创建\n<br>这三个项目都要统一设置成x64，或者是x86.\n<br>如果有一个没有设置，那样就会运行出错。\n</p>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> win服务 </tag>
            
            <tag> 文件解决 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>string转坐标点</title>
      <link href="/2022/10/26/string-zhuan-zuo-biao-dian/"/>
      <url>/2022/10/26/string-zhuan-zuo-biao-dian/</url>
      
        <content type="html"><![CDATA[<p>有的时候需要将string转换成自己想要的格式。最常见的比如我需要一个点，但是用户可能输入类似[1,2,3,4,5,6]这样的格式，我们就需要将这个string类型转换成对应的点的格式。\n<br>示例代码如下：\n</p><pre class="line-numbers language-none"><code class="language-none">public HTuple StringToHTuplePose(string PointString){    string[] array = PointString.Split(new char[] { ',', '[', ']' }, StringSplitOptions.RemoveEmptyEntries);    HTuple res = new HTuple(Convert.ToDouble(array[0]) / 1000, Convert.ToDouble(array[1]) / 1000, Convert.ToDouble(array[2]) / 1000,        Convert.ToDouble(array[3]), Convert.ToDouble(array[4]), Convert.ToDouble(array[5]), 0);    return res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该行为可以更容易地用逗号分隔值 (CSV) 文件之类的格式表示表格数据。 连续的逗号表示空白列。\n<br>可传递可选 StringSplitOptions.RemoveEmptyEntries 参数来排除返回数组中的任何空字符串。 \n要对返回的集合进行更复杂的处理，可使用 LINQ 来处理结果序列。\n</p>]]></content>
      
      
      <categories>
          
          <category> 工作技巧 </category>
          
          <category> string操作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> string </tag>
            
            <tag> 坐标点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>config文件使用</title>
      <link href="/2022/10/26/config-wen-jian-shi-yong/"/>
      <url>/2022/10/26/config-wen-jian-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>工作技巧\n<br>config由于原本文件会自动生成一个.config文件，所以在使用的时候往往直接可以进行使用\n<br>为了方便对于config文件进行操作，这里创建一个ConfigHelper的类进行一些操作的示例，见代码1\n<br>代码1\n</p><pre class="line-numbers language-none"><code class="language-none">using System;using System.Collections.Generic;using System.Configuration;using System.Linq;using System.Text;using System.Text.RegularExpressions;using System.Threading.Tasks;namespace XmlRpcCore{    public static class ConfigHelper    {        public static string GetAppConfig(string FilePath, string strKey)        {            Configuration val = ConfigurationManager.OpenExeConfiguration(FilePath);            string[] allKeys = val.AppSettings.Settings.AllKeys;            foreach (string a in allKeys)            {                if (a == strKey)                {                    return val.AppSettings.Settings[strKey].Value.ToString();                }            }            return null;        }        public static void UpdateAppConfig(string FilePath, string newKey, string newValue)        {            Configuration val = ConfigurationManager.OpenExeConfiguration(FilePath);            bool flag = false;            string[] allKeys = val.AppSettings.Settings.AllKeys;            foreach (string a in allKeys)            {                if (a == newKey)                {                    flag = true;                }            }            if (flag)            {                val.AppSettings.Settings.Remove(newKey);            }            val.AppSettings.Settings.Add(newKey, newValue);            val.Save(ConfigurationSaveMode.Modified);            ConfigurationManager.RefreshSection("appSettings");        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>filepath：</p><pre class="line-numbers language-none"><code class="language-none">private string appPath = $"{Application.ExecutablePath}";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用示例：\n<br>第一步获取对应的路径\n</p><pre class="line-numbers language-none"><code class="language-none">string xmlPath = $"{AppDomain.CurrentDomain.BaseDirectory}machines.xml";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第二步，获得数据，获得的类型都是string类型。\n<br>此处使用了上面代码1中的方法。\n</p><pre class="line-numbers language-none"><code class="language-none">parameters.IP = ConfigHelper.GetAppConfig(configFile, "IP");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 工作技巧 </category>
          
          <category> 类库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> config </tag>
            
            <tag> Hepler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XML使用</title>
      <link href="/2022/10/26/xml-shi-yong/"/>
      <url>/2022/10/26/xml-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>在框架中使用XML几种方案。\n<br>首先是自己创建一个xml文档，注意要有一个父节点，此处的父节点名称machine\n<br>节点模样参考\n</p><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;machine&gt;&lt;/machine&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>自己编写xmlhelper，需要后续进行修改。见代码1</p><p>代码1</p><pre class="line-numbers language-none"><code class="language-none">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Xml;namespace XmlRpcCore{    public static class XmlHelper    {        public static bool ElementIsNotExist(string FilePath, string machineNum)        {            XmlDocument xmlDocument = new XmlDocument();            xmlDocument.Load(FilePath);            XmlElement xmlElement = (XmlElement)xmlDocument.SelectSingleNode("machine/" + machineNum);            if (xmlElement == null)                return true;            return false;        }        public static string GetAppXmlAttribute(string FilePath, string machineNum, string strKey)        {            XmlDocument xmlDocument = new XmlDocument();            xmlDocument.Load(FilePath);            XmlElement xmlElement = (XmlElement)xmlDocument.SelectSingleNode("machine/" + machineNum);            string res = xmlElement.GetAttribute(strKey);            return res;        }        /// &lt;summary&gt;        /// 修改对应xml的特性若key存在，则修改，不存在则增添        /// &lt;/summary&gt;        /// &lt;param name="FilePath"&gt;&lt;/param&gt;        /// &lt;param name="machineNum"&gt;&lt;/param&gt;        /// &lt;param name="newKey"&gt;&lt;/param&gt;        /// &lt;param name="newValue"&gt;&lt;/param&gt;        public static void UpdateAppXmlAttribute(string FilePath, string machineNum, string newKey, string newValue)        {            XmlDocument xmlDocument = new XmlDocument();            xmlDocument.Load(FilePath);            XmlElement xmlElement = (XmlElement)xmlDocument.SelectSingleNode("machine/" + machineNum);            string res = xmlElement.GetAttribute(newKey);            xmlElement.SetAttribute(newKey, newValue);            xmlDocument.Save(FilePath);        }        public static void UpdateCameraOne(string FilePath, string machineNum, string HeightCameraOne, string MovingDirectionCameraOne,            string DataFileCameraOne, string ImageFileCameraOne, string ModelFileCameraOne, string PositionCameraOne)        {            XmlDocument xmlDocument = new XmlDocument();            xmlDocument.Load(FilePath);            XmlElement xmlElement = (XmlElement)xmlDocument.SelectSingleNode("machine/" + machineNum);            xmlElement.SetAttribute("HeightCameraOne", HeightCameraOne);            xmlElement.SetAttribute("MovingDirectionCameraOne", MovingDirectionCameraOne);            xmlElement.SetAttribute("DataFileCameraOne", DataFileCameraOne);            xmlElement.SetAttribute("ImageFileCameraOne", ImageFileCameraOne);            xmlElement.SetAttribute("ModelFileCameraOne", ModelFileCameraOne);            xmlElement.SetAttribute("PositionCameraOne", PositionCameraOne);            xmlDocument.Save(FilePath);        }        public static void UpdateCameraTwo(string FilePath, string machineNum, string HeightCameraTwo, string MovingDirectionCameraTwo,    string DataFileCameraTwo, string ImageFileCameraTwo, string ModelFileCameraTwo, string PositionCameraTwo)        {            XmlDocument xmlDocument = new XmlDocument();            xmlDocument.Load(FilePath);            XmlElement xmlElement = (XmlElement)xmlDocument.SelectSingleNode("machine/" + machineNum);            xmlElement.SetAttribute("HeightCameraTwo", HeightCameraTwo);            xmlElement.SetAttribute("MovingDirectionCameraTwo", MovingDirectionCameraTwo);            xmlElement.SetAttribute("DataFileCameraTwo", DataFileCameraTwo);            xmlElement.SetAttribute("ImageFileCameraTwo", ImageFileCameraTwo);            xmlElement.SetAttribute("ModelFileCameraTwo", ModelFileCameraTwo);            xmlElement.SetAttribute("PositionCameraTwo", PositionCameraTwo);            xmlDocument.Save(FilePath);        }        public static void ReadCameraTwo(string FilePath, string machineNum, out string HeightCameraTwo, out string MovingDirectionCameraTwo,out string DataFileCameraTwo, out string ImageFileCameraTwo, out string ModelFileCameraTwo, out string PositionCameraTwo)        {            XmlDocument xmlDocument = new XmlDocument();            xmlDocument.Load(FilePath);            XmlElement xmlElement = (XmlElement)xmlDocument.SelectSingleNode("machine/" + machineNum);            HeightCameraTwo = xmlElement.GetAttribute("HeightCameraTwo");            MovingDirectionCameraTwo = xmlElement.GetAttribute("MovingDirectionCameraTwo");            DataFileCameraTwo = xmlElement.GetAttribute("DataFileCameraTwo");            ImageFileCameraTwo = xmlElement.GetAttribute("ImageFileCameraTwo");            ModelFileCameraTwo = xmlElement.GetAttribute("ModelFileCameraTwo");            PositionCameraTwo = xmlElement.GetAttribute("PositionCameraTwo");        }        public static void ReadCameraOne(string FilePath, string machineNum, out string HeightCameraOne, out string MovingDirectionCameraOne,out string DataFileCameraOne, out string ImageFileCameraOne, out string ModelFileCameraOne, out string PositionCameraOne)        {            XmlDocument xmlDocument = new XmlDocument();            xmlDocument.Load(FilePath);            XmlElement xmlElement = (XmlElement)xmlDocument.SelectSingleNode("machine/" + machineNum);            HeightCameraOne = xmlElement.GetAttribute("HeightCameraOne");            MovingDirectionCameraOne = xmlElement.GetAttribute("MovingDirectionCameraOne");            DataFileCameraOne = xmlElement.GetAttribute("DataFileCameraOne");            ImageFileCameraOne = xmlElement.GetAttribute("ImageFileCameraOne");            ModelFileCameraOne = xmlElement.GetAttribute("ModelFileCameraOne");            PositionCameraOne = xmlElement.GetAttribute("PositionCameraOne");        }        public static void RemoveAppXmlElement(string FilePath, string machineNum)        {            XmlDocument xmlDocument = new XmlDocument();            xmlDocument.Load(FilePath);            XmlElement rootElement = (XmlElement)xmlDocument.SelectSingleNode("machine");            XmlElement xmlElement = (XmlElement)xmlDocument.SelectSingleNode("machine/" + machineNum);            rootElement.RemoveChild(xmlElement);            xmlDocument.Save(FilePath);        }        public static void AddAppXmlElement(string FilePath, string machineNum)        {            XmlDocument xmlDocument = new XmlDocument();            xmlDocument.Load(FilePath);            XmlElement rootElement = (XmlElement)xmlDocument.SelectSingleNode("machine");            XmlElement xmlElement = xmlDocument.CreateElement(machineNum);            rootElement.AppendChild(xmlElement);            xmlDocument.Save(FilePath);        }        public static XmlNodeList AppXmlElementCount(string FilePath)        {            XmlDocument xmlDocument = new XmlDocument();            xmlDocument.Load(FilePath);            XmlElement rootElement = (XmlElement)xmlDocument.SelectSingleNode("machine");            XmlNodeList childNodes = rootElement.ChildNodes;            return childNodes;        }        public static void CopyAppXmlElement(string FilePath, string oldmachineNum, string newmachineNum)        {            XmlDocument xmlDocument = new XmlDocument();            xmlDocument.Load(FilePath);            XmlElement rootElement = (XmlElement)xmlDocument.SelectSingleNode("machine");            XmlElement oldElement = (XmlElement)xmlDocument.SelectSingleNode("machine/" + oldmachineNum);            XmlElement newElement = xmlDocument.CreateElement(newmachineNum);            foreach (XmlAttribute att in oldElement.Attributes)            {                newElement.SetAttribute(att.Name, att.Value);                            }                        rootElement.AppendChild(newElement);            xmlDocument.Save(FilePath);        }    }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 工作技巧 </category>
          
          <category> 类库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> XML </tag>
            
            <tag> Helper </tag>
            
            <tag> class </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XML命名空间</title>
      <link href="/2022/10/26/xml-ming-ming-kong-jian/"/>
      <url>/2022/10/26/xml-ming-ming-kong-jian/</url>
      
        <content type="html"><![CDATA[<p>先说结论，两种命名空间，\n<br>一种默认命名空间，没有前缀。\n<br>二、显式名称空间声明，有前缀。\n<br>默认命名空间，无前缀的都使用\n</p><pre class="line-numbers language-none"><code class="language-none">&lt;根元素 xmlns = “http://xugang.cnblogs.com” &gt;           &lt;子元素 attName =“myname” /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>显式名称控件声明\n</p><pre class="line-numbers language-none"><code class="language-none">&lt;根元素 xmlns: xg = “http://xugang.cnblogs.com” &gt;           &lt;xg:子元素  attName = “myname” /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意：尽量只在根元素声明默认名称空间。若默认名称空间声明在非根元素，则容易被用户误解或忽略成没有名称空间的元素。所以，非根元素尽量不使用默认名称空间声明（推荐使用显式名称空间声明）。\n<br>名称空间的声明注意：\n<br>    * 双引号内必须是一个URI；<br>    * XML区分大小写，前缀名也不例外；<br>    * 前缀名建议采用英文缩写，也可以用中文（但不推荐用中文）；<br>    * 尽量避免同名前缀却对应不同URI的名称空间的情况，它将容易误导用户；<br>    * 尽量在根元素中声明所有的名称空间；<br>    * 如果一个属性所在的元素属于某显式声明的名称空间，一般就不需要为该属性添加前缀。<br>xml前缀的使用示例，两个xml文件合并成为一个xml文件，使用前缀进行区分。\n<br>IT部门\n</p><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version="1.0" encoding="GB2312" standalone="yes"?&gt;&lt;资料&gt;   &lt;设备 编号="联想6515b"&gt;      &lt;生产商&gt;联想集团&lt;/生产商&gt;      &lt;地址&gt;北京市中关村127号&lt;/地址&gt;   &lt;/设备&gt;&lt;/资料&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>建筑部门\n</p><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version="1.0" encoding="GB2312" standalone="yes" ?&gt;&lt;资料&gt;   &lt;设备 编号="中联F001"&gt;      &lt;生产商&gt;中联重科&lt;/生产商&gt;      &lt;地址&gt;湖南省长沙市新开铺113号&lt;/地址&gt;   &lt;/设备&gt;&lt;/资料&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正确合并\n</p><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version="1.0" encoding="GB2312" standalone="yes"?&gt;&lt;资料 xmlns:IT="http://www.lenovo.com" xmlns:建筑="myURN:中联"&gt;   &lt;设备 IT:编号="联想6515b" 建筑:编号="中联F001"&gt;      &lt;IT:设备名&gt;笔记本&lt;/IT:设备名&gt;      &lt;IT:生产商&gt;联想集团&lt;/IT:生产商&gt;      &lt;IT:地址&gt;北京市中关村127号&lt;/IT:地址&gt;      &lt;建筑:设备名&gt;起重机&lt;/建筑:设备名&gt;      &lt;建筑:生产商&gt;中联重科&lt;/建筑:生产商&gt;      &lt;建筑:地址&gt;湖南省长沙市新开铺113号&lt;/建筑:地址&gt;   &lt;/设备&gt;&lt;/资料&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>错误合并\n</p><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version="1.0" encoding="GB2312" standalone="yes"?&gt;&lt;资料&gt;   &lt;设备 编号="联想6515b" 编号="中联F001"&gt;      &lt;设备名&gt;笔记本&lt;/设备名&gt;      &lt;生产商&gt;联想集团&lt;/生产商&gt;      &lt;地址&gt;北京市中关村127号&lt;/地址&gt;      &lt;设备名&gt;起重机&lt;/设备名&gt;      &lt;生产商&gt;中联重科&lt;/生产商&gt;      &lt;地址&gt;湖南省长沙市新开铺113号&lt;/地址&gt;   &lt;/设备&gt;&lt;/资料&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相关知识，在复制节点的时候如果需要的话可以将对应的节点的命名空间一起复制\n</p><pre class="line-numbers language-none"><code class="language-none">XmlAttribute newAttribute = (XmlAttribute)sourceAttribute.CloneNode(true);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> XML </tag>
            
            <tag> 命名空间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XML命名规则</title>
      <link href="/2022/10/26/xml-ming-ming-gui-ze/"/>
      <url>/2022/10/26/xml-ming-ming-gui-ze/</url>
      
        <content type="html"><![CDATA[<p>问题表现\n<br>XML节点元素不可以以数字和特殊符号，如“.”开头，否则用XMLDOMDocument写入将会出现Bug。\n<br>具体规则\n<br>• 名称可以含字母、数字以及其他的字符<br>• 名称不能以数字或者标点符号开始<br>• 名称不能以字符 “xml”（或者 XML、Xml）开始<br>• 名称不能包含空格<br>注意，名称不能包括，并不是说value不能包括。name与value不同的\n</p>]]></content>
      
      
      <categories>
          
          <category> 基础学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> XML </tag>
            
            <tag> 命名规则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取当前程序路径</title>
      <link href="/2022/10/26/huo-qu-dang-qian-cheng-xu-lu-jing/"/>
      <url>/2022/10/26/huo-qu-dang-qian-cheng-xu-lu-jing/</url>
      
        <content type="html"><![CDATA[<p>获取路径的原因可以是很多。\n<br>需要获得当前文件的config文件中的属性\n<br>有些信息被写在xml文件之中\n<br>用户需要打开窗口选取文件，我们要获得用户打开的文件。\n<br>创建service服务的时候需要知道service服务的路径才可以进行对应的install or uninstall\n<br>当前最常使用的几种路径的获取方案如下。\n<br>这个是获得当前运行程序的目录，是一个exe文件。<br>在读取config文件的时候经常使用</p><pre class="line-numbers language-none"><code class="language-none">private string appPath = $"{Application.ExecutablePath}";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个是获取到当前运行的exe文件的目录\n<br>获取启动了应用程序的可执行文件的路径，不包括可执行文件的名称。\n<br>这个方法也是可靠的获取程序路径的方法。不过返回的路径最末并没有”"结尾。另外因为是Forms命名空间的。因此如果使用WPF还是不用的好。\n</p><pre class="line-numbers language-none"><code class="language-none">private String serviceFilePath= $"{Application.StartupPath}\\XmlRpcUR.exe";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个也是获得当前运行的exe文件的目录\n<br>获取当前 Thread\n<br>的当前应用程序域的基目录，它由程序集冲突解决程序用来探测程序集。\n<br>这个方法是以”"结尾\n</p><pre class="line-numbers language-none"><code class="language-none">string xmlPath = $"{AppDomain.CurrentDomain.BaseDirectory}\\machines.xml";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此处有一些我的路径实例用作参考  </p><pre class="line-numbers language-none"><code class="language-none">private void DataFile_Click(object sender, EventArgs e){    OpenFileDialog dialog = new OpenFileDialog();    if (File.Exists(DataFileTextBox.Text))    {        int lastIndex = DataFileTextBox.Text.LastIndexOf("\\");//获取双斜杠所在的最后的一个索引位置        string filePath = DataFileTextBox.Text.Substring(0, lastIndex);        dialog.InitialDirectory = filePath;    }    else if (Directory.Exists(DataFileTextBox.Text))    {        dialog.InitialDirectory = DataFileTextBox.Text;    }    dialog.Multiselect = false;//该值确定是否可以选择多个文件    dialog.Title = "请选择文件";    //过滤器，根据后缀过滤文件，文件夹保留。此处分为两个部分，前者只显示txt文档与文件夹，后者显示全部文件与文件夹    dialog.Filter = "hed格式（*.hed）|*.hed|所有文件|*.*";    if (dialog.ShowDialog() == System.Windows.Forms.DialogResult.OK)    {        string file = dialog.FileName;        DataFileTextBox.Text = file;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下内容来源于网络。\n<br>获取启动了应用程序的可执行文件的路径及文件名。\n<br>这个方法获取的是执行程序的完整文件名。是最可靠的方式，只需要去掉程序文件名就可以获得路径。\n</p><pre class="line-numbers language-none"><code class="language-none">System.Windows.Forms.Application.ExecutablePath<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取当前应用程序所在目录的路径，最后包含“\”。\n</p><pre class="line-numbers language-none"><code class="language-none">System.Threading.Thread.GetDomain().BaseDirectory<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参考文章\n</p><pre class="line-numbers language-none"><code class="language-none">http://t.zoukankan.com/zhzhx-p-3115102.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 工作技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 程序路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日期格式文件名</title>
      <link href="/2022/10/26/ri-qi-ge-shi-wen-jian-ming/"/>
      <url>/2022/10/26/ri-qi-ge-shi-wen-jian-ming/</url>
      
        <content type="html"><![CDATA[<p>因为是自动化，需要批量保存的时候文件名就会依据日期来命名\n<br>需要进行格式转换的原因有：文件命名不能有冒号\n<br>可以创建依据月份，具体到某一天的文件夹来对于文件进行分类。\n</p><pre class="line-numbers language-none"><code class="language-none">strFileName=Format(System.DateTime.Now,"yyyyMMdd_hhmmss");精确到毫秒级别名称＝DateTime.Now.ToString("yyyyMMddhhmmss") + DateTime.Now.Millisecond.ToString() + "上传文件的后缀名";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不同的日期表达形式</p><pre class="line-numbers language-none"><code class="language-none">//2007年4月24日  this.TextBox1.Text = System.DateTime.Now.ToString("D");  //2007/4/24  this.TextBox2.Text = System.DateTime.Now.ToString("d");  //2007年4月24日 16:30:15  this.TextBox3.Text = System.DateTime.Now.ToString("F");  //2007年4月24日 16:30  this.TextBox4.Text = System.DateTime.Now.ToString("f");  //2007/4/24 16:30:15  this.TextBox5.Text = System.DateTime.Now.ToString("G");  //2007/4/24 16:30         this.TextBox6.Text = System.DateTime.Now.ToString("g");  //16:30:15  this.TextBox7.Text = System.DateTime.Now.ToString("T");  //16:30  this.TextBox8.Text = System.DateTime.Now.ToString("t");  //2007年4月24日 8:30:15  this.TextBox9.Text = System.DateTime.Now.ToString("U");  //2007-04-24 16:30:15Z  this.TextBox10.Text = System.DateTime.Now.ToString("u");  //4月24日      this.TextBox11.Text = System.DateTime.Now.ToString("m");  this.TextBox12.Text = System.DateTime.Now.ToString("M");  //Tue, 24 Apr 2007 16:30:15 GMT    this.TextBox13.Text = System.DateTime.Now.ToString("r");  this.TextBox14.Text = System.DateTime.Now.ToString("R");  //2007年4月   this.TextBox15.Text = System.DateTime.Now.ToString("y");  this.TextBox16.Text = System.DateTime.Now.ToString("Y");  //2007-04-24T15:52:19.1562500+08:00  this.TextBox17.Text = System.DateTime.Now.ToString("o");  this.TextBox18.Text = System.DateTime.Now.ToString("O");  //2007-04-24T16:30:15  this.TextBox19.Text = System.DateTime.Now.ToString("s");  //2007-04-24 15:52:19:9889  this.TextBox20.Text = System.DateTime.Now.ToString("yyyy-MM-dd HH：mm：ss：ffff");  //2007年04月24 15时56分48秒  this.TextBox21.Text = System.DateTime.Now.ToString("yyyy年MM月dd HH时mm分ss秒");  //星期二, 四月 24 2007  this.TextBox22.Text = System.DateTime.Now.ToString("dddd, MMMM dd yyyy");  //周三, 十二月 7 '11  this.TextBox23.Text = System.DateTime.Now.ToString("ddd, MMM d \"'\"yy");  //星期二, 四月 24  this.TextBox24.Text = System.DateTime.Now.ToString("dddd, MMMM dd");  //4/07  this.TextBox25.Text = System.DateTime.Now.ToString("M/yy");  //07-12-11  this.TextBox26.Text = System.DateTime.Now.ToString("dd-MM-yy");    string[] Day = new string[] { "星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六" };  //2011/12/6 昨天  this.TextBox1.Text = System.DateTime.Now.AddDays(-1).ToShortDateString();  //2011/12/8 明天  this.TextBox2.Text = DateTime.Now.AddDays(1).ToShortDateString();  //2011/12/4 本周星期天  this.TextBox3.Text = DateTime.Now.AddDays(Convert.ToDouble((0 - Convert.ToInt16(DateTime.Now.DayOfWeek)))).ToShortDateString();  //2011/12/10 本周星期六  this.TextBox4.Text = DateTime.Now.AddDays(Convert.ToDouble((6 - Convert.ToInt16(DateTime.Now.DayOfWeek)))).ToShortDateString();  //星期三 今天周几  this.TextBox5.Text = Day[Convert.ToInt16(DateTime.Now.DayOfWeek)];  //2011/11/27 上周日  this.TextBox6.Text = DateTime.Now.AddDays(Convert.ToDouble((0 - Convert.ToInt16(DateTime.Now.DayOfWeek))) - 7).ToShortDateString();  //2011/12/3 上周六  this.TextBox7.Text = DateTime.Now.AddDays(Convert.ToDouble((6 - Convert.ToInt16(DateTime.Now.DayOfWeek))) - 7).ToShortDateString();  //2011/12/11 下周日  this.TextBox8.Text = DateTime.Now.AddDays(Convert.ToDouble((0 - Convert.ToInt16(DateTime.Now.DayOfWeek))) + 7).ToShortDateString();  //2011/12/17 下周六  this.TextBox9.Text = DateTime.Now.AddDays(Convert.ToDouble((6 - Convert.ToInt16(DateTime.Now.DayOfWeek))) + 7).ToShortDateString();  //2011-12-01 本月一号  this.TextBox10.Text =DateTime.Now.ToString("yyyy-MM-01");  //2011/12/31 本月最后一天  this.TextBox11.Text=DateTime.Parse(DateTime.Now.ToString("yyyy-MM-01")).AddMonths(1).AddDays(-1).ToShortDateString();  //2011/11/1 上个月一号  this.TextBox12.Text=System.DateTime.Parse(DateTime.Now.ToString("yyyy-MM-01")).AddMonths(-1).ToShortDateString();  //2012/1/1 下个月一号  this.TextBox13.Text=System.DateTime.Parse(DateTime.Now.ToString("yyyy-MM-01")).AddMonths(1).ToShortDateSring();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 工作技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> DateTime </tag>
            
            <tag> 文件名称 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Form操作-打开文件弹窗</title>
      <link href="/2022/10/26/form-cao-zuo-da-kai-wen-jian-dan-chuang/"/>
      <url>/2022/10/26/form-cao-zuo-da-kai-wen-jian-dan-chuang/</url>
      
        <content type="html"><![CDATA[<p>有的时候需要让用户选择文件，我们获取文件路径，用于读取相对应的文件。<br>因此有了这个弹窗按钮。\n</p><pre class="line-numbers language-none"><code class="language-none">private void DataFile_Click(object sender, EventArgs e){    OpenFileDialog dialog = new OpenFileDialog();    if (File.Exists(DataFileTextBox.Text))    {        int lastIndex = DataFileTextBox.Text.LastIndexOf("\\");//获取双斜杠所在的最后的一个索引位置        string filePath = DataFileTextBox.Text.Substring(0, lastIndex);        dialog.InitialDirectory = filePath;    }    else if (Directory.Exists(DataFileTextBox.Text))    {        dialog.InitialDirectory = DataFileTextBox.Text;    }    dialog.Multiselect = false;//该值确定是否可以选择多个文件    dialog.Title = "请选择文件";    //过滤器，根据后缀过滤文件，文件夹保留。此处分为两个部分，前者只显示txt文档与文件夹，后者显示全部文件与文件夹    dialog.Filter = "hed格式（*.hed）|*.hed|所有文件|*.*";    if (dialog.ShowDialog() == System.Windows.Forms.DialogResult.OK)    {        string file = dialog.FileName;        DataFileTextBox.Text = file;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Form操作 </category>
          
          <category> 工作技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Form操作 </tag>
            
            <tag> 获得文件路径 </tag>
            
            <tag> 文件弹窗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志创建</title>
      <link href="/2022/10/26/ri-zhi-chuang-jian/"/>
      <url>/2022/10/26/ri-zhi-chuang-jian/</url>
      
        <content type="html"><![CDATA[<p>目前有两个方案。<br>一个布置简单，就是直接写入到一个txt文档之中。<br>另一个是比较专业looger4的使用</p><h1 id="直接写入文档"><a href="#直接写入文档" class="headerlink" title="直接写入文档"></a>直接写入文档</h1><p>相关代码如下：</p><pre class="line-numbers language-none"><code class="language-none">private static string filePath = @"C:\Users\Nestar\Desktop\Xml.txt";public static void WriteInfo(string info){    using (FileStream stream = new FileStream(filePath, FileMode.Append))    {        using (StreamWriter writer = new StreamWriter(stream))        {            writer.WriteLine($"{DateTime.Now},{info}");        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>filepath可以根据自己的想要生成的路径任意设置。\n</p><h1 id="创建logger日志"><a href="#创建logger日志" class="headerlink" title="创建logger日志"></a>创建logger日志</h1><p>比较专业logger4的使用\n</p><ol><li>在引用的位置通过Nuggert安装logger4</li><li>手动创建log4net.config文件,将下面的代码2拷入文件中</li><li>在对应项目的.cs(常见问文件命名时AssemblyInfo.cs)，中最下面添加代码3内容</li><li>（可选项）添加LoggerHelper方便对于logger日志的操作，相关代码见代码4</li></ol><h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><pre class="line-numbers language-none"><code class="language-none">&lt;log4net&gt;  &lt;root&gt;    &lt;level value="ALL" /&gt;    &lt;appender-ref ref="infoAppender" /&gt;    &lt;appender-ref ref="errorAppender" /&gt;    &lt;appender-ref ref="debugAppender" /&gt;  &lt;/root&gt;  &lt;!-- 日志的等级，它们由高到底分别为： OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; ALL --&gt;  &lt;!--信息日志配置--&gt;  &lt;appender name="infoAppender" type="log4net.Appender.RollingFileAppender"&gt;    &lt;param name="File" value="Logs\Info\info.log" /&gt;    &lt;param name="AppendToFile" value="true" /&gt;    &lt;param name="MaxFileSize" value="10240" /&gt;    &lt;param name="MaxSizeRollBackups" value="100" /&gt;    &lt;param name="PreserveLogFileNameExtension" value="true" /&gt;    &lt;param name="StaticLogFileName" value="false" /&gt;    &lt;param name="DatePattern" value="yyyyMMdd" /&gt;    &lt;param name="RollingStyle" value="Date" /&gt;    &lt;layout type="log4net.Layout.PatternLayout"&gt;      &lt;conversionPattern value="%date [%thread] %-5level %logger - %message%newline" /&gt;    &lt;/layout&gt;    &lt;filter type="log4net.Filter.LevelRangeFilter"&gt;      &lt;param name="LevelMin" value="INFO" /&gt;      &lt;param name="LevelMax" value="INFO" /&gt;    &lt;/filter&gt;  &lt;/appender&gt;  &lt;!--调试日志配置--&gt;  &lt;appender name="debugAppender" type="log4net.Appender.RollingFileAppender"&gt;    &lt;param name="File" value="Logs\Debug\debug.log" /&gt;    &lt;param name="AppendToFile" value="true" /&gt;    &lt;param name="MaxFileSize" value="10240" /&gt;    &lt;param name="MaxSizeRollBackups" value="100" /&gt;    &lt;param name="PreserveLogFileNameExtension" value="true" /&gt;    &lt;param name="StaticLogFileName" value="false" /&gt;    &lt;param name="DatePattern" value="yyyyMMdd" /&gt;    &lt;param name="RollingStyle" value="Date" /&gt;    &lt;layout type="log4net.Layout.PatternLayout"&gt;      &lt;conversionPattern value="%date [%thread] %-5level %logger - %message%newline" /&gt;    &lt;/layout&gt;    &lt;filter type="log4net.Filter.LevelRangeFilter"&gt;      &lt;param name="LevelMin" value="DEBUG" /&gt;      &lt;param name="LevelMax" value="DEBUG" /&gt;    &lt;/filter&gt;  &lt;/appender&gt;  &lt;!--错误日志配置--&gt;  &lt;appender name="errorAppender" type="log4net.Appender.RollingFileAppender"&gt;    &lt;param name="File" value="Logs\Error\Err.log" /&gt;    &lt;param name="AppendToFile" value="true" /&gt;    &lt;param name="MaxFileSize" value="10240" /&gt;    &lt;param name="MaxSizeRollBackups" value="100" /&gt;    &lt;param name="PreserveLogFileNameExtension" value="true" /&gt;    &lt;param name="StaticLogFileName" value="false" /&gt;    &lt;param name="DatePattern" value="yyyyMMdd" /&gt;    &lt;param name="RollingStyle" value="Date" /&gt;    &lt;layout type="log4net.Layout.PatternLayout"&gt;      &lt;conversionPattern value="%date [%thread] %-5level %logger - %message%newline" /&gt;    &lt;/layout&gt;    &lt;filter type="log4net.Filter.LevelRangeFilter"&gt;      &lt;param name="LevelMin" value="ERROR" /&gt;      &lt;param name="LevelMax" value="ERROR" /&gt;    &lt;/filter&gt;  &lt;/appender&gt;&lt;/log4net&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要反应的是，虽然此处没有明写Log，但是root是作为所有的父节点，默认是Log的名称。\n</p><pre class="line-numbers language-none"><code class="language-none">1.主要是log实例化有变化。通过GetLogger方法获取xml配种中gdLog4net的Logger2.xml中定义了logger，关于logger和root，可以参考文章：https://www.cnblogs.com/zhangchenliang/p/4546352.html 的后面部分内容，大概意思就是说root其实就是一个顶级的logger，所有其他logger都默认继承这个root。如果需要让logger阻断和root的联系，可以将logger的additivity设置为false。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>示例代码：</p><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;log4net&gt;  &lt;appender name="AccesssService_Err" type="log4net.Appender.RollingFileAppender"&gt;    &lt;!--日志路径--&gt;    &lt;param name="File" value="Errors\log.log" /&gt;    &lt;!--是否是向文件中追加日志--&gt;    &lt;param name="AppendToFile" value="true" /&gt;    &lt;!--log保留个数--&gt;    &lt;param name="MaxSizeRollBackups" value="200" /&gt;    &lt;!--单个日志文件大小--&gt;    &lt;param name="MaximumFileSize" value="5MB" /&gt;    &lt;!--日志文件名是否是固定不变的--&gt;    &lt;param name="StaticLogFileName" value="false" /&gt;    &lt;!--日志文件名格式为:2008-08-31.log--&gt;    &lt;DatePattern value="yyyy-MM-dd HH'时.log'"&gt;&lt;/DatePattern&gt;    &lt;lockingModel type="log4net.Appender.FileAppender+MinimalLock" /&gt;    &lt;!--按照何种方式产生多个日志文件(日期[Date],文件大小[Size],混合[Composite])--&gt;    &lt;param name="RollingStyle" value="Size" /&gt;    &lt;layout type="log4net.Layout.PatternLayout"&gt;      &lt;param name="ConversionPattern" value="记录时间：%date%n线程ID:[%thread] %n日志级别：%-5level%n记录位置：%location%n消息描述：%property{Message}%n异常：%exception%n消息：%message%newline%n------------------------------------------%n" /&gt;    &lt;/layout&gt;    &lt;filter type="log4net.Filter.LevelRangeFilter"&gt;      &lt;levelMin value="WARN" /&gt;      &lt;levelMax value="FATAL" /&gt;    &lt;/filter&gt;    &lt;filter type="log4net.Filter.DenyAllFilter" /&gt;  &lt;/appender&gt;  &lt;appender name="AccesssService_info" type="log4net.Appender.RollingFileAppender"&gt;    &lt;!--日志路径--&gt;    &lt;param name="File" value="MyLogs\log.log" /&gt;    &lt;!--是否是向文件中追加日志--&gt;    &lt;param name="AppendToFile" value="true" /&gt;    &lt;!--log保留个数--&gt;    &lt;param name="MaxSizeRollBackups" value="200" /&gt;    &lt;!--单个日志文件大小--&gt;    &lt;param name="MaximumFileSize" value="5MB" /&gt;    &lt;!--日志文件名是否是固定不变的--&gt;    &lt;param name="StaticLogFileName" value="false" /&gt;    &lt;!--日志文件名格式为:2008-08-31.log--&gt;    &lt;DatePattern value="yyyy-MM-dd HH'时.log'"&gt;&lt;/DatePattern&gt;    &lt;lockingModel type="log4net.Appender.FileAppender+MinimalLock" /&gt;    &lt;!--按照何种方式产生多个日志文件(日期[Date],文件大小[Size],混合[Composite])--&gt;    &lt;param name="RollingStyle" value="Size" /&gt;    &lt;layout type="log4net.Layout.PatternLayout"&gt;      &lt;param name="ConversionPattern" value="记录时间：%date%n线程ID:[%thread] %n日志级别：%-5level%n记录位置：%location%n消息描述：%property{Message}%n异常：%exception%n消息：%message%newline%n------------------------------------------%n" /&gt;    &lt;/layout&gt;    &lt;filter type="log4net.Filter.LevelRangeFilter"&gt;      &lt;levelMin value="DEBUG" /&gt;      &lt;levelMax value="INFO" /&gt;    &lt;/filter&gt;    &lt;filter type="log4net.Filter.DenyAllFilter" /&gt;  &lt;/appender&gt;  &lt;logger name="gdLog4net" additivity="false"&gt;    &lt;level value="DEBUG" /&gt;    &lt;appender-ref ref="AccesssService_Err" /&gt;    &lt;appender-ref ref="AccesssService_info" /&gt;  &lt;/logger&gt;&lt;/log4net&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">public class LogHelper{    private static ILog log = null;    public static ILog Log    {        get        {            if (log == null)            {                //log4.config表示log4的配置文件                string fileName = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "config", "log4.config");                log4net.Config.XmlConfigurator.ConfigureAndWatch(new FileInfo(fileName));                log = LogManager.GetLogger("gdLog4net");            }            return log;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码3"><a href="#代码3" class="headerlink" title="代码3"></a>代码3</h2><pre class="line-numbers language-none"><code class="language-none">[assembly: log4net.Config.XmlConfigurator(ConfigFile = "log4net.config", ConfigFileExtension = "config", Watch = true)]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>相关属性讲解，<br>ConfigFile:<br>ConfigFileExtension:根据类型加载<br>Watch</p><h2 id="代码4"><a href="#代码4" class="headerlink" title="代码4"></a>代码4</h2><pre class="line-numbers language-none"><code class="language-none">using log4net;using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace XmlRpcApp{    internal class Logger    {        private static readonly ILog loginfo = LogManager.GetLogger("Log");//这里的 loginfo 和 log4net.config 里的名字要一样        public static void WriteLog(string info)        {            if (loginfo.IsInfoEnabled)            {                loginfo.Info(info);            }        }        public static void WriteLog(string info, Exception ex)        {            if (loginfo.IsErrorEnabled)            {                loginfo.Error(info, ex);            }        }        public static void DebugLog(string info)        {            if (loginfo.IsDebugEnabled)            {                loginfo.Debug(info);            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 工作技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> log4net </tag>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Visual_Studio快捷键</title>
      <link href="/2022/10/26/visual-studio-kuai-jie-jian/"/>
      <url>/2022/10/26/visual-studio-kuai-jie-jian/</url>
      
        <content type="html"><![CDATA[<p>很多时候快捷键能够很大层次的简化自己的双手，方便自己。所以在网上找到了一些VS相关的快捷键<br>具体内容如下<br>快速构建构造函数<br>输入 ctor 然后按 TAB 键</p><p>快速构建自动属性<br>在变量那里，右击鼠标，点“重构”–“封装字段”</p><p>Visual Studio快捷键 [VS2008/VS2005]</p><hr><p>“cw” + Tab + Tab - Console.WriteLine();</p><p>“mbox” + Tab + Tab - Messagebox.Show();</p><p>“prop” + Tab + Tab - 含有Get、Set访问器的属性块</p><p>“propg” + Tab + Tab - 只读属性快</p><p>“propfull” + Tabl + Tab - 具有完整get、set访问器的属性快</p><p>封装属性的快捷键：ctrl+R+E<br>快速属性： 输入prop 两下TAB</p><p>VS系统通用快捷键：<br>比如#region的快捷键是：ctrl + k,s</p><p>1、自动排版(类似VC6中的Alt+F8）<br>编辑.格式化选定内容 Ctrl + K，Ctrl + F 根据周围的代码行，正确缩进选定的代码行。</p><p>2、注释与去掉注释功能。</p><p>编辑.注释选定内容 Ctrl + K，Ctrl + C 使用编程语言的正确注释语法将代码的当前行标记为注释。</p><p>编辑.取消注释选定内容 Ctrl + K，Ctrl + U 从代码的当前行中移除注释语法。</p><p>将插入点移动到文档中的下一个大括号处。<br>编辑.转到大括号 Ctrl + ] 将插入点移动到文档中的下一个大括号处。</p><p>编辑.向下滚动一行 Ctrl + 向下键 将文本向下滚动一行。仅可用于文本编辑器。<br>编辑.向上滚动一行 Ctrl + 向上键 将文本向上滚动一行。仅可用于文本编辑器。</p><p>怎么找到解决方案<br>视图.解决方案资源管理器 Ctrl + Alt + L 显示解决方案资源管理器，它列出当前解决方案中的项目和文件</p><p>显示“工具箱”<br>视图.工具箱 Ctrl + Alt + X 显示“工具箱”，其中包含可包括在代码中或与代码一起使用的控件和其他项。</p><p>清除项目中的所有断点<br>调试.删除所有断点 Ctrl + Shift + F9 清除项目中的所有断点。</p><p>调试.反汇编 Ctrl + Alt + D 显示“反汇编”窗口。<br>调试.切换断点 F9 在当前行设置或移除断点。</p><p>VS2008 快捷键<br>新建项目 Ctrl+shift+N<br>新建网站 shift+Alt+N<br>文件 Ctrl+N<br>打开项目/解决方案 Ctrl+shift+O<br>打开网站 shift+Alt+O<br>打开文件 Ctrl+O<br>保存当前文件 Ctrl+S<br>全部保存 Ctrl+Shift+S<br>添加新项 Ctrl+Shift+A<br>添加现有项 Shift+Alt+A<br>添加类 Shift+Alt+C<br>撤消 Ctrl+Z<br>重复 Ctrl+Y<br>转到 Ctrl+G<br>循环应用剪贴板中的复制项Ctrl+Shift+V<br>设置文档的格式 Ctrl+E，D<br>设置选定内容的格式Ctrl+E，F<br>转换为大写 Ctrl+Shift+U<br>转换为小写 Ctrl+U<br>删除水平空白Ctrl+E，<br>查看空白Ctrl+E,S<br>自动换行Ctrl+E,W<br>渐进式搜索Ctrl+I<br>注释选定内容Ctrl+E,C<br>取消注释选定内容Ctrl+E,U<br>快速查找 Ctrl+F<br>快速替换 Ctrl+H<br>在文件中查找 Ctrl+Shift+F<br>查找下一个 F3<br>查找上一个 Shift+F3<br>在文件中替换 Ctrl+Shift+H<br>查找符号 Alt+F12<br>切换书签 Ctrl+B，T<br>启用书签 Ctrl+B，E<br>上一书签 Ctrl+B，P<br>下一书签 Ctrl+B，N<br>清除书签 Ctrl+B，C<br>添加任务列表快捷方式Ctrl+E，T<br>切换大纲显示展开Ctrl+M，M<br>切换所有大纲显示Ctrl+M，L<br>停止大纲显示 Ctrl+M，P<br>折叠到定义 Ctrl+M，O<br>生产方法存根 Ctrl+K，M<br>列出成员 Ctrl+K，L<br>参数信息 Ctrl+K，P<br>快速信息 Ctrl+K，I<br>完成单词 Ctrl+K，W<br>插入代码段 Ctrl+K，X<br>外侧代码 Ctrl+K，S—–就是可选#region<br>代码 F7<br>设计器 Shift+F7<br>服务器资源管理器 Ctrl+W，L<br>解决方案资源管理器 Ctrl+W，S<br>类视图 Ctrl+W，c<br>代码定义窗口Ctrl+W，D<br>对象浏览器 Ctrl+W，J<br>错误列表 Ctrl+W，E<br>输出 Ctrl+W，O<br>属性窗口 Ctrl+W，P<br>任务列表 Ctrl+W，T<br>工具箱 Ctrl+W，X<br>全屏显示shift+Alt+Enter<br>向后定位 Ctrl+-<br>向前定位 Ctrl+Shift+-<br>属性页 Shift+F4<br>查找符号结果 Ctrl+W，Q<br>书签窗口 Ctrl+W，B<br>命令窗口 Ctrl+W，A<br>文档大纲 Ctrl+W，U<br>资源视图 Ctrl+W，R<br>宏资源管理器 Alt+F8<br>Web浏览器 Ctrl+W，W<br>重命名 F2<br>提取方法 Ctrl+R，M<br>封装字段 Ctrl+R，E<br>提取接口 Ctrl+R，I<br>将局部变量提升为参数 Ctrl+R,P<br>移除参数 Ctrl+R，V<br>重新排列参数 Ctrl+R，O<br>生成解决方案 F6<br>生成当前项目 Shift+F6<br>启动调试 F5<br>继续 F5<br>全部中断 Ctrl+Alt+Break<br>停止调试 Shift+F5<br>重新启动 Ctrl+Shift+F5<br>开始执行（不调试）Ctrl+F5<br>异常 Ctrl+D，E<br>逐语句 F11<br>跳出 Shift+F11<br>逐过程 F10<br>切换断点 F9<br>删除所有断点 Ctrl+Shift+F9<br>断点 Ctrl+D，B<br>即时 Ctrl+D，I<br>快速监视 Ctrl+D，Q<br>监视1 Ctrl+D，W<br>监视2 Ctrl+D+W，2<br>监视3 Ctrl+D+W，3<br>监视4 Ctrl+D+W，4<br>自动窗口Ctrl+D，A<br>局部变量 Ctrl+D，L<br>调用堆栈 Ctrl+D，C<br>线程 Ctrl+D，T<br>切换当前线程标志状态 Ctrl+8<br>仅显示标志的线程 Ctrl+9<br>模块 Ctrl+D，M<br>进程 Ctrl+D，P<br>反编译 Ctrl+Alt+D<br>寄存器 Ctrl+D，R<br>内存1 Ctrl+D，Y<br>内存2 Ctrl+Alt+M，2<br>内存3 Ctrl+Alt+M，3<br>内存4 Ctrl+Alt+M，4<br>附加到进程 Ctrl+Alt+P<br>代码段管理器 Ctrl+K，Ctrl+B<br>运行当前宏 Ctrl+Shift+P<br>记录当前宏 Ctrl+Shift+R<br>宏IDE Alt+F11<br>当前上下文中的测试 Ctrl+R，T<br>解决方案中的所有测试 Ctrl+R，A<br>如何实现 Ctrl+F1，H<br>搜索 Ctrl+F1,S<br>目录 Ctrl+F1，C<br>索引 Ctrl+F1，I<br>帮助收藏夹 Ctrl+F1，F<br>动态帮助 Ctrl+F1，D<br>索引结果 Ctrl+F1，T</p><hr><p>VS2005 常用快捷键<br>调试快捷键</p><p>F6: 生成解决方案<br>Ctrl+F6: 生成当前项目<br>F7: 查看代码<br>Shift+F7: 查看窗体设计器<br>F5: 启动调试<br>Ctrl+F5: 开始执行(不调试)<br>Shift+F5: 停止调试<br>Ctrl+Shift+F5: 重启调试<br>F9: 切换断点<br>Ctrl+F9: 启用/停止断点<br>Ctrl+Shift+F9: 删除全部断点<br>F10: 逐过程<br>Ctrl+F10: 运行到光标处<br>F11: 逐语句</p><p>编辑快捷键</p><p>Shift+Alt+Enter: 切换全屏编辑<br>Ctrl+B,T / Ctrl+K,K: 切换书签开关<br>Ctrl+B,N / Ctrl+K,N: 移动到下一书签<br>Ctrl+B,P: 移动到上一书签<br>Ctrl+B,C: 清除全部标签</p><p>Ctrl+I: 渐进式搜索<br>Ctrl+Shift+I: 反向渐进式搜索<br>Ctrl+F: 查找<br>Ctrl+Shift+F: 在文件中查找<br>F3: 查找下一个<br>Shift+F3: 查找上一个<br>Ctrl+H: 替换<br>Ctrl+Shift+H: 在文件中替换<br>Alt+F12: 查找符号(列出所有查找结果)<br>Ctrl+Shift+V: 剪贴板循环</p><p>Ctrl+左右箭头键: 一次可以移动一个单词<br>Ctrl+上下箭头键: 滚动代码屏幕，但不移动光标位置。<br>Ctrl+Shift+L: 删除当前行<br>Ctrl+M,M: 隐藏或展开当前嵌套的折叠状态<br>Ctrl+M,L: 将所有过程设置为相同的隐藏或展开状态<br>Ctrl+M,P: 停止大纲显示<br>Ctrl+E,S: 查看空白<br>Ctrl+E,W: 自动换行<br>Ctrl+G: 转到指定行<br>Shift+Alt+箭头键: 选择矩形文本<br>Alt+鼠标左按钮: 选择矩形文本<br>Ctrl+Shift+U: 全部变为大写<br>Ctrl+U: 全部变为小写</p><p>代码快捷键</p><p>Ctrl+J / Ctrl+K,L: 列出成员<br>Ctrl+Shift+空格键 / Ctrl+K,P: 参数信息<br>Ctrl+K,I: 快速信息<br>Ctrl+E,C / Ctrl+K,C: 注释选定内容<br>Ctrl+E,U / Ctrl+K,U: 取消选定注释内容</p><p>Ctrl+K,M: 生成方法存根<br>Ctrl+K,X: 插入代码段<br>Ctrl+K,S: 插入外侧代码</p><p>F12: 转到所调用过程或变量的定义</p><p>窗口快捷键</p><p>Ctrl+W,W: 浏览器窗口<br>Ctrl+W,S: 解决方案管理器<br>Ctrl+W,C: 类视图<br>Ctrl+W,E: 错误列表<br>Ctrl+W,O: 输出视图<br>Ctrl+W,P: 属性窗口<br>Ctrl+W,T: 任务列表<br>Ctrl+W,X: 工具箱<br>Ctrl+W,B: 书签窗口<br>Ctrl+W,U: 文档大纲</p><p>Ctrl+D,B: 断点窗口<br>Ctrl+D,I: 即时窗口<br>Ctrl+Tab: 活动窗体切换<br>Ctrl+Shift+N: 新建项目<br>Ctrl+Shift+O: 打开项目<br>Ctrl+Shift+S: 全部保存<br>Shift+Alt+C: 新建类<br>Ctrl+Shift+A: 新建项</p>]]></content>
      
      
      <categories>
          
          <category> 工作技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Visual Studio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>定期清理文件与文件夹</title>
      <link href="/2022/10/26/ding-qi-qing-li-wen-jian-yu-wen-jian-jia/"/>
      <url>/2022/10/26/ding-qi-qing-li-wen-jian-yu-wen-jian-jia/</url>
      
        <content type="html"><![CDATA[<h1 id="定期清理某种类型文件"><a href="#定期清理某种类型文件" class="headerlink" title="定期清理某种类型文件"></a>定期清理某种类型文件</h1><p>有的时候需要定期清理图片等。\n</p><pre class="line-numbers language-none"><code class="language-none">/// &lt;summary&gt;/// 定期清除文件/// &lt;/summary&gt;/// &lt;param name="fileDirect"&gt;文件夹&lt;/param&gt;/// &lt;param name="postFix"&gt;文件后缀&lt;/param&gt;/// &lt;param name="saveDay"&gt;保存天数&lt;/param&gt;private static void DeleteFile(string fileDirect, string postFix, int saveDay){    DateTime nowtime = DateTime.Now; //获取当前时间    string[] files = Directory.GetFiles(fileDirect, postFix, SearchOption.AllDirectories);  //获取该目录下所有 .txt文件    foreach (string file in files)    {        FileInfo fileInfo = new FileInfo(file);        TimeSpan t = nowtime - fileInfo.CreationTime;  //当前时间  减去 文件创建时间        int day = t.Days;        if (day &gt; saveDay)   //保存的时间 ；  单位：天        {            File.Delete(file);  //删除超过时间的文件        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用方式–异步使用"><a href="#使用方式–异步使用" class="headerlink" title="使用方式–异步使用"></a>使用方式–异步使用</h2><pre class="line-numbers language-none"><code class="language-none">private static void RegularDeleteImage(){    int saveDays = 0; //保存天数，可根据实际需求定义    string path = @"C:\Users\Nestar\Pictures\Saved Pictures"; //保存数据的路径    //开启一个异步线程定期检查是否可以删除文件    Task.Run(() =&gt;    {        while (true)        {            DeleteFile(path, "*.jpg", saveDays);            Thread.Sleep(1000 * 60 * 60 * 24); //每隔24H检查一遍        }    });}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="“yyMMdd”-命名的文件夹进行删除"><a href="#“yyMMdd”-命名的文件夹进行删除" class="headerlink" title="(“yyMMdd”)命名的文件夹进行删除"></a>(“yyMMdd”)命名的文件夹进行删除</h1><p>补充一个保留文件夹名称，删除其他文件夹的方法。\n<br>本来还想说这个方案好蠢，没想到蠢人竟是我自己。\n<br>在上面使用被驳回之后，立马用到了下面的删除文件夹以及子文件夹。\n<br>上面的方案是将文件根据创建的日期进行删除，这里是根据不同日期的图片放在依据日期命名的文件夹中。\n<br>然后依据日期命名的文件夹进行删除。\n</p><pre class="line-numbers language-none"><code class="language-none">public static void RegularCleanFile(){    int saveDays = 0; //保存天数，可根据实际需求定义    string path = @"C:\Users\Nestar\Pictures\Saved Pictures"; //保存数据的路径    var saveFileFolderList = new List&lt;string&gt;(); //保存哪些文件夹    for (int i = 0; i &lt; saveDays; i++)    {        var saveFile = DateTime.Now.AddDays(-i).ToString("yyyyMMdd");//这部分需要根据需要自己定制        saveFileFolderList.Add(saveFile);    }    //开启一个异步线程定期检查是否可以删除文件    Task.Run(() =&gt;    {        while (true)        {            if (Directory.Exists(path))            {                DirectoryInfo di = new DirectoryInfo(path);                var fsiArr = di.GetFileSystemInfos(); //获取所有的文件、文件夹                foreach (var fsi in fsiArr)                {                    if (fsi is DirectoryInfo) //判断是否文件夹                    {                        //判断是否在删除范畴内                        if (!saveFileFolderList.Exists(o =&gt; fsi.Name.Contains(o)))                        {                            DirectoryInfo delDi = new DirectoryInfo(fsi.FullName);                            delDi.Delete(true); //删除文件夹及文件                        }                    }                }            }            Thread.Sleep(1000 * 60 * 60 * 6); //每隔6H检查一遍        }    });    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>既然有删除，那自然也要有创建文件夹，经过测试\n</p><ol><li>可以一次性创建多层目录，</li><li>创建的文件夹如果已经存在不会报错，也不会删除之前的文件夹重新创建，而是没有任何动作。<pre class="line-numbers language-none"><code class="language-none">DirectoryInfo directoryInfo = new DirectoryInfo($"C:\\image\\{DateTime.Now.ToString("yyMMdd")}");directoryInfo.Create();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
          <category> 工作技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 文件夹 </tag>
            
            <tag> 定期清理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C-连接SQLServer</title>
      <link href="/2022/10/23/c-lian-jie-sqlserver/"/>
      <url>/2022/10/23/c-lian-jie-sqlserver/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库的连接"><a href="#数据库的连接" class="headerlink" title="数据库的连接"></a>数据库的连接</h1><p>万一有的时候需要我去连接SQL Server，这边提前准备\n</p><p>相关的代码如下\n</p><pre class="line-numbers language-none"><code class="language-none">static void Main(string[] args){    // 声明一个SqlConnectionStringBuilder对象    SqlConnectionStringBuilder scsb = new SqlConnectionStringBuilder();    scsb.DataSource = "DESKTOP-BR0Q3FS\\SQLEXPRESS";    // 设置数据源服务器，注意这里的单斜线变双斜线了    //scsb.UserID = "sa";     // 设置用户名    //scsb.Password = "mima"; // 设置密码    scsb.InitialCatalog = "xiaoxieDatabase"; // 设置要访问的数据库    //scsb.ConnectionString = "SSPI";    scsb.IntegratedSecurity = true;    // 创建连接    SqlConnection SqlCon = new SqlConnection(scsb.ToString());    // 打开数据库    SqlCon.Open();    // 1、创建要执行的SQL查询语句    string str = "select Name from Teachers where Gender = 'man'";    // 2、创建用于执行SQL查询语句的对象    SqlCommand SqlCom = new SqlCommand(str, SqlCon);// 参数1：SQL语句字符串。参数2：已经打开的数据库    // 3、执行对象的SQL查询语句并接受结果    SqlDataReader Sdr = SqlCom.ExecuteReader();    // 4、读取结果的数据    while (Sdr.Read())    {        Console.WriteLine("姓名：" + Sdr["Name"].ToString());    }    Console.ReadLine();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 工作技巧 </category>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 数据库 </tag>
            
            <tag> SQL Server </tag>
            
            <tag> 连接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Form操作-TextBox仅数字等输入，离开检测</title>
      <link href="/2022/10/09/form-cao-zuo-textbox-jin-shu-zi-deng-shu-ru-chi-kai-jian-ce/"/>
      <url>/2022/10/09/form-cao-zuo-textbox-jin-shu-zi-deng-shu-ru-chi-kai-jian-ce/</url>
      
        <content type="html"><![CDATA[<h1 id="仅支持数字等输入"><a href="#仅支持数字等输入" class="headerlink" title="仅支持数字等输入"></a>仅支持数字等输入</h1><p>有的时候我们对于一些控件，希望它仅仅支持部分文档的输入。比如端口号应该只有数字或者分隔符。因此在有了在界面中设置仅支持某种输入的方法。</p><pre class="line-numbers language-none"><code class="language-none">/// &lt;summary&gt;/// 设置Port只能输入数字与回车/// &lt;/summary&gt;/// &lt;param name="sender"&gt;&lt;/param&gt;/// &lt;param name="e"&gt;&lt;/param&gt;private void PortTextBox_KeyPress(object sender, KeyPressEventArgs e){    if (!((e.KeyChar &gt;= 48 &amp;&amp; e.KeyChar &lt;= 57) || e.KeyChar == 8))    {        e.Handled = true;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="离开或者输入时的检测"><a href="#离开或者输入时的检测" class="headerlink" title="离开或者输入时的检测"></a>离开或者输入时的检测</h1><p>想了下好像没有必要<br>那就提一嘴，主要就是在控件的事件，在可视化界面中，放在属性旁边的选项，能够帮助实现部分的功能。<br>比如离开，进入，按键等。</p>]]></content>
      
      
      <categories>
          
          <category> Form操作 </category>
          
          <category> 工作技巧 </category>
          
          <category> TextBox </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Form操作 </tag>
            
            <tag> 日常学习 </tag>
            
            <tag> TextBox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XML-RPC</title>
      <link href="/2022/10/09/xml-rpc/"/>
      <url>/2022/10/09/xml-rpc/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">https://blog.csdn.net/qq_39024280/article/details/120861419?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-120861419-blog-95950589.pc_relevant_multi_platform_whitelistv3&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-120861419-blog-95950589.pc_relevant_multi_platform_whitelistv3&amp;utm_relevant_index=1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个博客内容可以直接使用<br>一些使用心得<br>尝试了一下封装在系统类中，完全可以  </p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> XML-RPC </category>
          
          <category> 工作技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 工作技巧 </tag>
            
            <tag> XML-RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Form操作-MessageBox</title>
      <link href="/2022/10/09/form-cao-zuo-messagebox/"/>
      <url>/2022/10/09/form-cao-zuo-messagebox/</url>
      
        <content type="html"><![CDATA[<p>参考文章<br><a href="https://blog.csdn.net/qq_44793656/article/details/124509495">https://blog.csdn.net/qq_44793656/article/details/124509495</a></p><pre class="line-numbers language-none"><code class="language-none">https://blog.csdn.net/qq_44793656/article/details/124509495<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Form操作 </category>
          
          <category> 工作技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Form操作 </tag>
            
            <tag> MessageBox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Form操作-二次确认弹窗</title>
      <link href="/2022/10/09/form-cao-zuo-er-ci-que-ren-dan-chuang/"/>
      <url>/2022/10/09/form-cao-zuo-er-ci-que-ren-dan-chuang/</url>
      
        <content type="html"><![CDATA[<p>在一些比较关键的功能上可以让进行二次确认，避免因为误操作而导致的损失。<br>示例代码是用于二次确认用户的界面关闭，可以在此基础上进行修改。 </p><pre class="line-numbers language-none"><code class="language-none">private void frmMain_FormClosing(object sender, FormClosingEventArgs e){    DialogResult Result = MessageBox.Show("程序将被关闭，请确认是否继续","警告", MessageBoxButtons.OKCancel);    if (Result == DialogResult.Cancel)    {        e.Cancel = true;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Form操作 </category>
          
          <category> 工作技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作技巧 </tag>
            
            <tag> Form操作 </tag>
            
            <tag> 二次确认 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP设置</title>
      <link href="/2022/10/09/ip-she-zhi/"/>
      <url>/2022/10/09/ip-she-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="IP校验"><a href="#IP校验" class="headerlink" title="IP校验"></a>IP校验</h1><p>检查输入是否符合IP格式，建议与IP是否未空混合使用</p><pre class="line-numbers language-none"><code class="language-none">public static bool IPCheck(string IP){    return Regex.IsMatch(IP, @"^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="获取设备当前IP"><a href="#获取设备当前IP" class="headerlink" title="获取设备当前IP"></a>获取设备当前IP</h1><p>获取当前设备的ip</p><pre class="line-numbers language-none"><code class="language-none">public string GetAddressIP(){    string AddressIP = string.Empty;    foreach (IPAddress _IPAddress in Dns.GetHostEntry(Dns.GetHostName()).AddressList)    {        if (_IPAddress.AddressFamily.ToString() == "InterNetwork")        {            AddressIP = _IPAddress.ToString();        }    }    return AddressIP;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> 工作技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 工作技巧 </tag>
            
            <tag> IP设置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Form操作-菜单栏与下拉框</title>
      <link href="/2022/10/09/form-cao-zuo-cai-dan-lan-yu-xia-la-kuang/"/>
      <url>/2022/10/09/form-cao-zuo-cai-dan-lan-yu-xia-la-kuang/</url>
      
        <content type="html"><![CDATA[<p>窗口上端的菜单栏<br>MenuItemInstallService<br>记得添加一个menuScrip属性的控件<br>设置之后依次添加，见天click事件也是可以的。<br>下拉框<br>combox<br>Combox.selectIndex表示当前所选择的值的编号<br>combox.index表示编号从0开始计数，0，1，2，3，4…  </p>]]></content>
      
      
      <categories>
          
          <category> Form操作 </category>
          
          <category> 工作技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Form操作 </tag>
            
            <tag> 菜单栏 </tag>
            
            <tag> 下拉框 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Form操作-TextBox显示服务状态</title>
      <link href="/2022/10/09/form-cao-zuo-textbox-xian-shi-fu-wu-zhuang-tai/"/>
      <url>/2022/10/09/form-cao-zuo-textbox-xian-shi-fu-wu-zhuang-tai/</url>
      
        <content type="html"><![CDATA[<h1 id="TextBox显示状态（status）"><a href="#TextBox显示状态（status）" class="headerlink" title="TextBox显示状态（status）"></a>TextBox显示状态（status）</h1><p>在界面张添加timer控件，<br>设置enable=true这个属性是是否启用，<br>interval=1000此处单位为毫秒，这个属性是时间间隔<br>然后在事件中选择tick，绑定需要执行的方法。<br>状态文本可以显示在TextBox。Text中，可以将TextBox.Enable=false这样界面中文本框就不能显示了。</p>]]></content>
      
      
      <categories>
          
          <category> Form操作 </category>
          
          <category> 工作技巧 </category>
          
          <category> TextBox </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Form操作 </tag>
            
            <tag> 日常学习 </tag>
            
            <tag> TextBox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>管理员权限运行程序</title>
      <link href="/2022/10/09/guan-li-yuan-quan-xian-yun-xing-cheng-xu/"/>
      <url>/2022/10/09/guan-li-yuan-quan-xian-yun-xing-cheng-xu/</url>
      
        <content type="html"><![CDATA[<p>在工作中由于使用的系统进程，这个需要管理员权限才可以实现对于进程的访问。因此打包出来的程序也是需要系统权限的验证。  </p><h1 id="两种方案"><a href="#两种方案" class="headerlink" title="两种方案"></a>两种方案</h1><h2 id="方案1-通过应用程序服务清单进行权限设置"><a href="#方案1-通过应用程序服务清单进行权限设置" class="headerlink" title="方案1-通过应用程序服务清单进行权限设置"></a>方案1-通过应用程序服务清单进行权限设置</h2><p>这个设置会在exe上有管理员标志。运行程序时会索取管理员权限。需要注意的的是添加应用程序服务清单是在你的启动program，如果在别的program中添加不起作用。  </p><pre class="line-numbers language-none"><code class="language-none">&lt;!-- UAC 清单选项     如果想要更改 Windows 用户帐户控制级别，请使用     以下节点之一替换 requestedExecutionLevel 节点。n&lt;requestedExecutionLevel  level="asInvoker" uiAccess="false" /&gt;&lt;requestedExecutionLevel  level="requireAdministrator" uiAccess="false" /&gt;&lt;requestedExecutionLevel  level="highestAvailable" uiAccess="false" /&gt;    指定 requestedExecutionLevel 元素将禁用文件和注册表虚拟化。    如果你的应用程序需要此虚拟化来实现向后兼容性，则删除此    元素。--&gt;&lt;requestedExecutionLevel level="requireAdministrator" uiAccess="false" /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方案2-手动索取管理员权限"><a href="#方案2-手动索取管理员权限" class="headerlink" title="方案2-手动索取管理员权限"></a>方案2-手动索取管理员权限</h2><p>此方案是在程序启动时检查是否管理员权限启动，如果不是就提示用户需要管理员权限启动，然后关闭程序。如果时管理员权限启动，则正常启动程序。<br>这里提供了一种如何在程序即将运行时，申请管理员权限的方案。  </p><pre class="line-numbers language-none"><code class="language-none">using System;using System.Collections.Generic;using System.Diagnostics;using System.Linq;using System.Reflection;using System.Security.Principal;using System.ServiceProcess;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;namespace XmlRpcApp{    static class Program    {        [STAThread]        static void Main()        {            var wi = WindowsIdentity.GetCurrent();            var wp = new WindowsPrincipal(wi);            bool runAsAdmin = wp.IsInRole(WindowsBuiltInRole.Administrator);            if (!runAsAdmin)            {                // It is not possible to launch a ClickOnce app as administrator directly,                // so instead we launch the app as administrator in a new process.                var processInfo = new ProcessStartInfo(Assembly.GetExecutingAssembly().CodeBase);                // The following properties run the new process as administrator                processInfo.UseShellExecute = true;                processInfo.Verb = "runas";                // Start the new process                try                {                    Process.Start(processInfo);                }                catch (Exception)                {                    // The user did not allow the application to run as administrator                    MessageBox.Show("This program requires administrator privileges to run");                }                // Shut down the current process                Application.Exit();            }            else            {                // We are running as administrator                Application.EnableVisualStyles();                Application.SetCompatibleTextRenderingDefault(false);                Application.Run(new ClientApp());            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考文章链接如下所示</p>]]></content>
      
      
      <categories>
          
          <category> 工作技巧 </category>
          
          <category> 管理员权限 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 工作技巧 </tag>
            
            <tag> 管理员权限程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改命名空间</title>
      <link href="/2022/10/09/xiu-gai-ming-ming-kong-jian/"/>
      <url>/2022/10/09/xiu-gai-ming-ming-kong-jian/</url>
      
        <content type="html"><![CDATA[<p>参考链接<br><a href="https://www.jb51.net/article/252677.htm">https://www.jb51.net/article/252677.htm</a></p><pre class="line-numbers language-none"><code class="language-none">https://www.jb51.net/article/252677.htm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 工作技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 修改命名空间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>批处理.bat返回上一层目录</title>
      <link href="/2022/10/09/pi-chu-li-bat-fan-hui-shang-yi-ceng-mu-lu/"/>
      <url>/2022/10/09/pi-chu-li-bat-fan-hui-shang-yi-ceng-mu-lu/</url>
      
        <content type="html"><![CDATA[<p>批处理目前看到的应用只有win的。bat文件中<br>这次遇见的问题是我文件自动导出到下一层，但是我需要使用上一层的某个exe，这个就是需要对于批处理文件的路径有一定的认识<br>我需要C：\ batch \路径。我如何才能获得这条道路？ 它工作正常如果我给绝对路径 -  </p><pre class="line-numbers language-none"><code class="language-none">%windir%\Microsoft.NET\Framework\v4.0.30319\InstallUtil.exe C:\batch\bin\ERecruitGenerateReportsWindowsService.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>您尝试使用%<del>1在目录结构中上升一级是创造性的并且语法完全无效。正确的语法同样简单 - 使用..\。 由于%</del>dp0以\结尾，因此不需要前导\。</p><pre class="line-numbers language-none"><code class="language-none">%windir%\Microsoft.NET\Framework\v4.0.30319\InstallUtil.exe %~dp0..\bin\ERecruitGenerateReportsWindowsService.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> 工作技巧 </category>
          
          <category> 批处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 工作技巧 </tag>
            
            <tag> 批处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AutoResetEvent与Waitone与set</title>
      <link href="/2022/10/09/autoresetevent-yu-waitone-yu-set/"/>
      <url>/2022/10/09/autoresetevent-yu-waitone-yu-set/</url>
      
        <content type="html"><![CDATA[<p>AutoResetEvent a1 = new AutoResetEvent(false);<br>不传入false默认为true，不会阻塞线程，所以必须传false。<br>WaitOne(int)； WaitOne(int,bool)； WaitOne(timespan,bool)；<br>第二个参数传true代表超时后由set()设置不阻塞线程，如果传入false，如:WaitOne(2000,false);当超过两秒后线程就解除阻塞了，也就是等第二次在进入此线程时候会直接执行并不会阻塞线程。<br>WaitOne返回值为true代表当前线程不阻塞，返回为false代表当前线程被阻塞。<br>WaitOne第二个参数：如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它(需要其他地方调用Set方法)，则为 true；否则为 false。<br>原文链接：<a href="https://blog.csdn.net/Liumotor/article/details/107085239">https://blog.csdn.net/Liumotor/article/details/107085239</a>  </p><pre class="line-numbers language-none"><code class="language-none">https://blog.csdn.net/Liumotor/article/details/107085239<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>仔细想了下为什么会用到这个知识。应该是面对不能够确定处理时间，但是事件的触发又是不受到控制的。在用户去手动处理一些内容的时候，避免用户再次接到新的弹窗，影响用户的操作。因此需要阻塞当前线程，然后去处理之前线程提出的问题，等到问题处理完毕之后，恢复线程的运行。很巧妙的设定。  </p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> AutoResetEvent </category>
          
          <category> waitone </category>
          
          <category> set </category>
          
          <category> 工作技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> AutoResetEvent </tag>
            
            <tag> waitone </tag>
            
            <tag> set </tag>
            
            <tag> 工作技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何获取列的构造方法以及对应的参数列表</title>
      <link href="/2022/10/09/ru-he-huo-qu-lie-de-gou-zao-fang-fa-yi-ji-dui-ying-de-can-shu-lie-biao/"/>
      <url>/2022/10/09/ru-he-huo-qu-lie-de-gou-zao-fang-fa-yi-ji-dui-ying-de-can-shu-lie-biao/</url>
      
        <content type="html"><![CDATA[<p>顾名思义，仅仅知道类的名字的时候去构造函数会很困难，通过这种方法可以获取对应的构造函数。</p><pre class="line-numbers language-none"><code class="language-none">Type type = typeof(MethodTest);// 输入参数：BindingFlags.Public，获取所有公开的构造函数Console.WriteLine("输入参数：BindingFlags.Public | BindingFlags.NonPublic，获取所有公开yu的构造函数：");ConstructorInfo[] infoArray2 = type.GetConstructors(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);foreach (ConstructorInfo info in infoArray2){    Console.WriteLine("这是一个公开的构造方法{0}", info.IsPublic);    Console.WriteLine("这是一个静态的构造方法{0}", info.IsStatic);    foreach(ParameterInfo a in info.GetParameters())    {        Console.WriteLine(a.ParameterType.ToString());    }    }Console.WriteLine();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面是对应的关键代码，下面是完整代码，演示如何去实现。</p><pre class="line-numbers language-none"><code class="language-none">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Reflection;using System.Runtime.InteropServices;using System.Threading.Tasks;using UnderAutomation.UniversalRobots.XmlRpc;namespace ReflectMethod{    class Program    {        static void Main(string[] args)        {            Type type = typeof(MethodTest);            // 输入参数：BindingFlags.Public，获取所有公开的构造函数            Console.WriteLine("输入参数：BindingFlags.Public | BindingFlags.NonPublic，获取所有公开yu的构造函数：");            ConstructorInfo[] infoArray2 = type.GetConstructors(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);            foreach (ConstructorInfo info in infoArray2)            {                Console.WriteLine("这是一个公开的构造方法{0}", info.IsPublic);                Console.WriteLine("这是一个静态的构造方法{0}", info.IsStatic);                foreach(ParameterInfo a in info.GetParameters())                {                    Console.WriteLine(a.ParameterType.ToString());                }                            }            Console.WriteLine();            //// 输入参数：BindingFlags.Public，获取所有公开的构造函数            //Console.WriteLine("输入参数：BindingFlags.Public | BindingFlags.Instance，获取所有公开的构造函数：");            //ConstructorInfo[] infoArray3 = type.GetConstructors(BindingFlags.Public | BindingFlags.Instance);            //foreach (ConstructorInfo info in infoArray3)            //{            //    Console.Write(info.IsStatic);            //    Console.Write(info.GetParameters().ToString());            //}            //Console.WriteLine();            //Console.WriteLine("输入参数：BindingFlags.Static | BindingFlags.NonPublic，获取所有静态的构造函数：");            //ConstructorInfo[] infoArray4 = type.GetConstructors(BindingFlags.Static | BindingFlags.NonPublic);            //foreach (ConstructorInfo info in infoArray4)            //{            //    Console.Write(info.IsStatic);            //    Console.Write(info.GetParameters().ToString());            //}            //Console.WriteLine();            //Console.WriteLine("输入参数：BindingFlags.NonPublic | BindingFlags.Instance，获取所有非公开的构造函数：");            //ConstructorInfo[] infoArray5 = type.GetConstructors(BindingFlags.NonPublic | BindingFlags.Instance);            //foreach (ConstructorInfo info in infoArray5)            //{            //    Console.Write(info.IsStatic);            //    Console.Write(info.GetParameters().ToString());            //}            Console.ReadKey();                    ////反射获取 命名空间+类名            //string className = "ReflectMethod.MethodTest";            //string methodName = "Sleep";            //int a;            //a = 10;            ////Type[] types = { typeof(string), typeof(string) };            //Type[] types = new Type[a];            ////传递参数            //Object[] paras = new Object[] { "name","18" };            //Type t = Type.GetType(className);            //object obj = Activator.CreateInstance(t);            ////直接调用            //MethodInfo method = t.GetMethod(methodName,types);            //method.Invoke(obj, paras);        }    }    class MethodTest    {        string name;        public MethodTest(string name)        {            this.name = name;        }        int age;        public MethodTest(int age)        {            this.age = age;        }        public void Sleep(string name,int age)        {            Console.WriteLine($"You have bean man,you must sleep alone,{name}");        }        public void Sleep(string name, string age)        {            Console.WriteLine($"You have bean {age} old,you must sleep alone,{name}");        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一些参数的说明<br>暂时掠过<br>通过方法名与参数获取对应的方法，不调用  </p><pre class="line-numbers language-none"><code class="language-none">//传递参数string className = "ConsoleApp2.ClassSample";string methodName = request.MethodName;var t = Type.GetType(className);object obj = Activator.CreateInstance(t);try{    #region 查找对应方法    MethodInfo[] info = t.GetMethods();    for (int i = 0; i &lt; info.Length; i++)    {        var md = info[i];        //方法名        string mothodName = md.Name;        //参数集合        ParameterInfo[] paramInfos = md.GetParameters();        //方法名相同且参数个数一样        if (mothodName == methodName &amp;&amp; paramInfos.Length == paras.Length)        {            md.Invoke(obj, paras);        }    }    #endregion}catch (Exception ex){    throw ex;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> 工作技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 工作技巧 </tag>
            
            <tag> 类的构造函数与参数列表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win服务的创建与卸载</title>
      <link href="/2022/10/09/win-fu-wu-de-chuang-jian-yu-xie-zai/"/>
      <url>/2022/10/09/win-fu-wu-de-chuang-jian-yu-xie-zai/</url>
      
        <content type="html"><![CDATA[<p>win服务的创建，参考链接  </p><pre class="line-numbers language-none"><code class="language-none">https://www.cnblogs.com/xiketang/p/16518053.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://www.cnblogs.com/xiketang/p/16518053.html">https://www.cnblogs.com/xiketang/p/16518053.html</a><br>可以参考这个链接中的环境配置  </p><pre class="line-numbers language-none"><code class="language-none">https://blog.csdn.net/weixin_43783990/article/details/123001345<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://blog.csdn.net/weixin_43783990/article/details/123001345">https://blog.csdn.net/weixin_43783990/article/details/123001345</a><br>win服务的删除，参考方法<br>第一种：通过Dos命令来 删除/卸载服务  </p><ol><li>开始 - 运行 -“cmd”。  </li><li>进入Dos命令行，输入命令：<br>sc delete VMUSBArbService<br>注意：VMUSBArbService是服务名称。<br>当然：也可以通过：sc –help 查看sc命令参数等信息等。<br>第二种方法：直接修改注册表 删除/卸载服务  </li><li>开始 - 运行 - “regedit”。  </li><li>在“HKEY_LOCAL_MACHINESYSTEMCurrentControlSetServices”中删除相应的 键值   即可！<br>额外的小tips<br>win+r cmd  services.msc<br>查看目前正在运行的服务<br>安装的目录文件路径<br>C:\Windows\Microsoft.NET\Framework\v4.0.30319</li></ol><p>在新建项目中选择，Windows服务<br>在service.cs中添加两个服务，一个serviceProcessInstaller<br>一个是serviceInstall,<br>然后设置他们对应的属性。<br>servicePrcessInstaller主要是设置Account，设置成为LocalSystem<br>这个比较重要<br>serviceInstall设置ServiceName，这个是服务名称<br>DisplayName，这个是展示的名称<br>StartType这个是触发方式<br>1.Description：表示服务说明（描述服务是干什么的）；<br>2.DisplayName：表示友好名称，可以理解为服务名的别名；<br>3.ServiceName：表示服务名，此为真正的服务名，与DisplayName是有区别的哦，是系统识别的依据；<br>这三个属性在WIN7及更高版本操作系统中，同属性但表示却不同：<br>本地服务列表中：（即：services.msc）<br>名称列显示的是DisplayName，<br>描述列显示的是Description。  </p><p>在WINDOWS任务管理器中的服务选项卡列表中：<br>名称列显示的是ServiceName，<br>描述列显示的是DisplayName。<br>本人之前就是被这三个属性给搞混了，出现安装成功，在任务管理器的服务列表中可以看到，但在服务列表中怎么也找不到，其实是将ServiceName与DisplayName搞错了。  </p><p>在生成的Onstart与Onclose中填入你想要开始与结束的时候触发的方法。<br>tips：服务需要结合管理员权限一节，这样运行不会出现因为管理员权限方面的问题。<br>还有如果是在path地方出现问题，考虑是因为自己的运行的城西x64或者x86的环境的问题。  </p>]]></content>
      
      
      <categories>
          
          <category> 工作技巧 </category>
          
          <category> Win服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作技巧 </tag>
            
            <tag> Win服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>根据方法名与参数列表调用对应方法</title>
      <link href="/2022/10/09/gen-ju-fang-fa-ming-yu-can-shu-lie-biao-diao-yong-dui-ying-fang-fa/"/>
      <url>/2022/10/09/gen-ju-fang-fa-ming-yu-can-shu-lie-biao-diao-yong-dui-ying-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>顾名思义，有的时候会使用RPC技术来实现一些方法的远程调用。有时候因为是使用其他人编写好的方法，让自己不能像xmlrpc.net描述的那种进行直接调用，但是可以获得需要调用的方法名称与参数列表，以及对应的值。面对这样的情况，就有了以下的代码。<br>这里是主要的实现方法<br>值得注意的点有  </p><ol><li>getmethod后面如果不设置types那样如果面对有重载的函数就会直接报错</li><li>activator。createInstanc（），第一个参数是类的名称，后面的参数是实例化类所需要的参数。<pre class="line-numbers language-none"><code class="language-none">//反射获取 命名空间+类名string className = "ReflectMethod.MethodTest";string methodName = "Sleep";Type[] types = { typeof(string), typeof(string) };//Type[] types = new Type[a];//传递参数Object[] paras = new Object[] { "name", "18" };Type t = Type.GetType(className);object obj = Activator.CreateInstance(t,1);//直接调用MethodInfo method = t.GetMethod(methodName, types);method.Invoke(obj, paras);Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>下面是用于验证的方法。<br>验证上面的方案是否成功。<pre class="line-numbers language-none"><code class="language-none">class MethodTest{    string name;    public MethodTest(string name)    {        this.name = name;    }    int age;    public MethodTest(int age)    {        this.age = age;    }    public void Sleep(string name,int age)    {        Console.WriteLine($"You have bean man,you must sleep alone,{name}");    }    public void Sleep(string name, string age)    {        Console.WriteLine($"You have bean {age} old,you must sleep alone,{name}");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 实用小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 部分内容的总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Navicat破解</title>
      <link href="/2022/10/09/navicat-po-jie/"/>
      <url>/2022/10/09/navicat-po-jie/</url>
      
        <content type="html"><![CDATA[<p>参考文档：<br><a href="https://www.cnblogs.com/wjdzh/p/16523956.html#_label1">https://www.cnblogs.com/wjdzh/p/16523956.html#_label1</a><br>安装包我的百度网盘，经过实际体验可以破解。  </p>]]></content>
      
      
      <categories>
          
          <category> 破解软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 破解软件 </tag>
            
            <tag> Navicat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OFFICE破解</title>
      <link href="/2022/10/09/office-po-jie/"/>
      <url>/2022/10/09/office-po-jie/</url>
      
        <content type="html"><![CDATA[<p>可以用过OFFICE tools进行下载office<br>然后通过HEUkms这个软件进行破解升级<br>实际效果win11升级激活码激活成功。</p>]]></content>
      
      
      <categories>
          
          <category> 破解软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 破解软件 </tag>
            
            <tag> OFFICE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无法启动计算机上的服务</title>
      <link href="/2022/10/09/wu-fa-qi-dong-ji-suan-ji-shang-de-fu-wu/"/>
      <url>/2022/10/09/wu-fa-qi-dong-ji-suan-ji-shang-de-fu-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述1"><a href="#问题描述1" class="headerlink" title="问题描述1"></a>问题描述1</h1><p>无法启动计算机”.”上的服务****<br>内部异常<br>Win32Exception:服务没有及时响应启动或控制请求。  </p><h2 id="问题发生场景"><a href="#问题发生场景" class="headerlink" title="问题发生场景"></a>问题发生场景</h2><p>创建win服务，安装与卸载正常，一旦点开start就会报错。<br>今天遇见了这个问题。花了两天时间排查了一遍。经过排查，寻找到了原因。<br>主要的原因就是系统类的start的时候首先要加载类本身。但是因为类本身具有的某个变量，实例化了，但是实例化的过程有错误。这就导致类的加载失败，引起启动服务异常。  </p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>将类中的实例改成仅仅声明，而不去实例。============觉得是符合代码规范的。实际上错误还在。需要结合下面的方案一起使用。</li><li>将原本的错误进行修改，实例化类的错误原因进行找出并修改，问题很有可能是空赋值即对于null属性进行操作而导致的问题。</li></ol><h1 id="问题描述2"><a href="#问题描述2" class="headerlink" title="问题描述2"></a>问题描述2</h1><p>Win服务start的时候快速打开然后立刻关闭。  </p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>这个与上面原因基本一致，只不过这个实例变量存在于start方法中，方法响应快速，将原本应该打开的实例化的类因为原来的代码错误，快速被清理掉，引起服务的快速关闭。</p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><p>将原本的错误进行修改，实例化类的错误原因进行找出并修改，问题很有可能是空赋值即对于null属性进行操作而导致的问题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>需要养成良好的编码习惯，在class中仅仅声明而不去实例化。<br>注意初始化类时的一些基本变量的赋值是否会为null，是否支持null。</li><li>初始化为空的问题一种表现形式：在开始的时候因为赋值为空，不能够执行，或者执行报错。<br>再经过某些操作后，如赋值等。问题不出现，程序运行正常。<br>再重新生成解决方案后，问题依旧存在。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> 平时学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 事件 </tag>
            
            <tag> 工作问题 </tag>
            
            <tag> 解决问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#事件学习-学习日志（1）</title>
      <link href="/2022/09/21/c-shi-jian-xue-xi-xue-xi-ri-zhi-1/"/>
      <url>/2022/09/21/c-shi-jian-xue-xi-xue-xi-ri-zhi-1/</url>
      
        <content type="html"><![CDATA[<h2 id="事件模型的五个组成部分"><a href="#事件模型的五个组成部分" class="headerlink" title="事件模型的五个组成部分"></a>事件模型的五个组成部分</h2><ol><li>事件的拥有者（event source,对象）</li><li>事件成员（event，成员）</li><li>事件的响应者（event subscriber，对象）</li><li>事件处理器（event handle，成员）——-本质上是一个回调方法</li><li>事件订阅–把事件处理器与事件关联在一起，本质上是一种以委托类型为基础的“约定”。</li></ol><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>事件处理器是成员方法</li><li>挂接事件处理器的时候，可以使用委托实例，也可以直接使用方法名，这是个“语法糖”</li><li>事件处理器对事件的订阅不是随意的，匹配与否由生命事件时所使用的委托类型来检测</li><li>事件可以是同步调用也可以是异步调用。</li></ol><p>事件的几种情况</p><h1 id="当时间的拥有者与事件的响应者不同的时候"><a href="#当时间的拥有者与事件的响应者不同的时候" class="headerlink" title="当时间的拥有者与事件的响应者不同的时候"></a>当时间的拥有者与事件的响应者不同的时候</h1><p>示例代码<br>这个代码主要是使用了Timer类中的timer.elapsed作为事件的成员，作用是在一定的事件后触发事件处理器<br>最后需要加一个ReadLine不然会直接退出。<br>Intercal属性的作用是设置事件触发的间隔时间，这里设置的一秒钟。<br>主体部分</p><pre class="line-numbers language-none"><code class="language-none">internal class Program{    static void Main(string[] args)    {        Timer timer = new Timer();        timer.Interval = 1000;        Boy boy = new Boy();        timer.Elapsed += Boy.Action;        timer.Start();        Console.ReadLine();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Boy类</p><pre class="line-numbers language-none"><code class="language-none">internal class Boy{    public Boy()    {    }    internal static void Action(object sender, ElapsedEventArgs e)    {        Console.WriteLine("jack");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一种的形式的实现</p><pre class="line-numbers language-none"><code class="language-none">static void Main(string[] args){    //# region 事件的拥有者与响应者不同    //Timer timer = new Timer();    //timer.Interval = 1000;    //Boy boy = new Boy();    //timer.Elapsed += Boy.Action;    //timer.Start();    //Console.ReadLine();    //# endregion    #region 事件的处理者是事件的拥有者字段    Form form = new Form();    Controller controller = new Controller(form);    form.ShowDialog();    #endregion}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>事件的拥有者</p><pre class="line-numbers language-none"><code class="language-none">class Controller {    private Form from;    public Controller(Form form)    {        if (form != null)        {            from = form;            this.from.Click += this.fromClicked;        }    }    private void fromClicked(object sender, EventArgs e)    {        this.from.Text = DateTime.Now.ToString();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="当事件的处理者与事件的拥有者是同一个"><a href="#当事件的处理者与事件的拥有者是同一个" class="headerlink" title="当事件的处理者与事件的拥有者是同一个"></a>当事件的处理者与事件的拥有者是同一个</h1><pre class="line-numbers language-none"><code class="language-none">static void Main(string[] args){    #region 事件的处理者是事件的拥有者字段    MyForm form = new MyForm();    form.Click += form.FormClicked;    form.ShowDialog();    #endregion}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>事件的拥有者与响应者都是form，此处选择继承的原因是form类是微软写死的，自己无法构成事件的相应，<br>但是你可以通过将继承，然后修改自己继承后的类，实现之前没有实现的功能。</p><pre class="line-numbers language-none"><code class="language-none">internal class Program{    static void Main(string[] args)    {        //# region 事件的拥有者与响应者不同        //Timer timer = new Timer();        //timer.Interval = 1000;        //Boy boy = new Boy();        //timer.Elapsed += Boy.Action;        //timer.Start();        //Console.ReadLine();        //# endregion        #region 事件的处理者是事件的拥有者字段        MyForm form = new MyForm();        form.Click += form.FormClicked;        form.ShowDialog();        #endregion    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="事件的响应者是事件的拥有者某个成员"><a href="#事件的响应者是事件的拥有者某个成员" class="headerlink" title="事件的响应者是事件的拥有者某个成员"></a>事件的响应者是事件的拥有者某个成员</h1><p>此处的例子中事件的响应者是按钮，事件的拥有者是form</p><pre class="line-numbers language-none"><code class="language-none">static void Main(string[] args){    #region 事件的处理者是事件的拥有者字段    MyForm form = new MyForm();    form.Click += form.FormClicked;    form.ShowDialog();    #endregion}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是对应的form的设计</p><pre class="line-numbers language-none"><code class="language-none">internal class MyForm:Form{    private TextBox textBox;    private Button button;    public MyForm()    {        this.textBox = new TextBox();        this.button = new Button();        this.Controls.Add(this.textBox);        this.Controls.Add(this.button);        this.button.Click += this.ButtonCliked;        this.button.Top = 20;    }    private void ButtonCliked(object sender, EventArgs e)    {        this.Text = DateTime.Now.ToString();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">```<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>```</p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 基础学习 </tag>
            
            <tag> 事件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>耦合与内聚学习-学习日志（4）</title>
      <link href="/2022/09/14/c-yu-fa-xue-xi-xue-xi-ri-zhi-4/"/>
      <url>/2022/09/14/c-yu-fa-xue-xi-xue-xi-ri-zhi-4/</url>
      
        <content type="html"><![CDATA[<p>软件要做到高内聚，低耦合。<br>内聚就是一个模块内部各成分之间相关联的成都的度量<br>耦合就是程序结构中哥哥模块的相互关联的度量  </p><h2 id="内聚的分类：由高到低"><a href="#内聚的分类：由高到低" class="headerlink" title="内聚的分类：由高到低"></a>内聚的分类：由高到低</h2><p>内聚的分类：由高到低<br>功能内聚：知模块内的所有元素共同作用完成一个功能，缺一不可。<br>顺序内聚：一个模块中的哥哥处理元素都密切像关于同一个功能且必须顺序执行，迁移功能元素的输出就是下一个功能元素的输入。<br>通信内聚：模块内所有处理元素都在同一个数据结构中。<br>过程内聚：一个模块完成多个任务，这些任务必须按照指定的过程执行。<br>瞬时内聚：把需要同时执行的任务或者动作组合在一起（例如初始化模块）<br>逻辑内聚：模块完成逻辑上相关的一组任务。<br>偶然内聚：一个模块内的各个处理元素之间没有任何联系或者有松散的联系  </p><h2 id="耦合的分类：由高到低"><a href="#耦合的分类：由高到低" class="headerlink" title="耦合的分类：由高到低"></a>耦合的分类：由高到低</h2><p>耦合的分类：由高到低<br>内容耦合：一个模块直接使用另一个模块的内部数据，或者通过非正常入口转入另个一模块内部是，这种耦合关系叫做内容耦合<br>公共耦合:一组模块访问一个公共的数据环境，如全局数据变量<br>外部耦合：一组模块访问一个公共变量，这里指的是基本数据类型而不是数据结构躲着说是对象。<br>控制耦合：一个模块调用另一个模块的时候，传递的是控制变量，被调用模块通过该控制变量的值选择执行模块内莫伊功能，那么也就是说被调用的模块应该具有多个功能。<br>标记耦合：耦合模块之间以数据结构传递（比如在java中，传递就是一个对象）<br>数据耦合：耦合模块之间有调用关系，传递的是简单数据类型的值。<br>无直接耦合：两个模块之间没有直接的关系，他们从属于不同模块的控制与调用，它们之间不传递任何信息。  </p>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础学习 </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> 内聚 </tag>
            
            <tag> 耦合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#语法学习-学习日志（3）</title>
      <link href="/2022/09/12/c-yu-fa-xue-xi-xue-xi-ri-zhi-3/"/>
      <url>/2022/09/12/c-yu-fa-xue-xi-xue-xi-ri-zhi-3/</url>
      
        <content type="html"><![CDATA[<p>前言，此处代码使用VS2022，。net6的模式，全部都是在主函数的个实例，所以可以直接实例化一些类。<br>一些工作中遇见的不懂得语法进行学习<br>主要分为1.反射，2.特性，3.委托，4.？？与？。等，5.where<br>6.class类一些基础特点，7.as的作用。</p><h1 id="一、委托"><a href="#一、委托" class="headerlink" title="一、委托"></a>一、委托</h1><p>委托两类：C#类提供的，自定义委托</p><h2 id="C-提供的委托（参数可有可无与返回值一定没有）action"><a href="#C-提供的委托（参数可有可无与返回值一定没有）action" class="headerlink" title="C#提供的委托（参数可有可无与返回值一定没有）action"></a>C#提供的委托（参数可有可无与返回值一定没有）action</h2><p>自定义个类与方法</p><pre class="line-numbers language-none"><code class="language-none">class Calculator{public void Report(){Console.WriteLinr("I have 3 methods");}public int ADD(int a,int b){int result = a+b;return result;}public int SUB(int a,int b){int result = a-b;return result;}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用方法<br>三种调用结果相同<br>第一种没有使用委托<br>后两种可以是基本相同</p><pre class="line-numbers language-none"><code class="language-none">static void Main(string {} args){Calulator calculator new Calculator();//acton只想方法Action action = new Action(calculator.Report);//以下三种方法调用结果相同//直接调用calculator.Report();//使用委托间接调用action.Invoke();//Invoke也可以省略掉action();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C-提供的委托（有参数与返回值）function"><a href="#C-提供的委托（有参数与返回值）function" class="headerlink" title="C#提供的委托（有参数与返回值）function"></a>C#提供的委托（有参数与返回值）function</h2><p>调用方法</p><pre class="line-numbers language-none"><code class="language-none">static void Main(string {} args){Calulator calculator new Calculator();Func&lt;int,int,int&gt; fun1 = new Fun&lt;int,int,int&gt;(calculator.ADD);Func&lt;int,int,int&gt; fun2 = new Fun&lt;int,int,int&gt;(calculator.AUB);int x=100;int y = 200;int z = 0;z = fun1(x,y);Console.WriteLine(z);z=fun2(x,y);Console.WriteLine(z);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C-自定义委托"><a href="#C-自定义委托" class="headerlink" title="C#自定义委托"></a>C#自定义委托</h2><p>委托就是一种类<br>注意声明委托的位置（一般写在命名空间下），可能会引起嵌套类<br>委托与所封装的方法必须“类型兼容”<br>返回值与参数列表的数据类型需要一致<br>以下是委托的声明</p><pre class="line-numbers language-none"><code class="language-none">public delegate int Calc(int x, int y);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以下是实现委托的类  </p><pre class="line-numbers language-none"><code class="language-none">clas Calculator{public int Add(int a, int b){retutn a+b;}public int Sub(int a,int b){return a-b;}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下是委托的具体实现<br>具不具有Invoke都是一样的。 </p><pre class="line-numbers language-none"><code class="language-none">class Program{static void Main(string[] args){Calculator calculator = new Calculator():Calc calc1= new Calc(calculator.Add(int a,int b));Calc calc2= new Calc(calculator.Sub(int a,int b));int a=10;int b=30;int c=0;c=calc1.Invoke(a,b);Console.WriteLine(c);c=calc2.Invoke(a,b);Console.WriteLine(c);c=calc2(a,b);Console.WriteLine(c);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="委托的一般使用"><a href="#委托的一般使用" class="headerlink" title="委托的一般使用"></a>委托的一般使用</h2><p>一般使用方法把方法当作参数传给另一个方法<br>这又可以分为两种用法<br>方法1 模板方法<br>借用指定的外部方法来产生结果</p><ol><li>相当于“填空题”</li><li>常位于代码中部</li><li>常用于委托有返回值<br>方法2 回调方法（callback），调用指定的外部方法</li><li>相当于“流水线”</li><li>常位于代码末尾</li><li>常委托无返回值</li></ol><h3 id="模板方法的例子"><a href="#模板方法的例子" class="headerlink" title="模板方法的例子"></a>模板方法的例子</h3><pre class="line-numbers language-none"><code class="language-none">/*这个部分主要是对于委托的一些使用测试， * 四个类，产品类product-具有产品的名称属性 * 包装类box-将产品包装起来，返回一个产品类的参数 * 进行包装类warrybox-具有一个方法wProduct 参数（是一个返回类型为Product类型的，参数为空的方法），返回值是（box类型） * 产品工厂类ProductFactory-具有两个无参数，返回类型为product类型的方法； * 主函数中引用了两个func1，func2分别采用两个方法。 *///此处是实例化两个类的实例，他们都是一个非静态函数，需要实例化才能调用对应的方法。虽然好像没有真的使用，但是可能真的指示//也是需要的。WaryProduct a=new WaryProduct();ProductFactory b = new ProductFactory();Func&lt;Product&gt; fun1 = new Func&lt;Product&gt;(b.Pizza);Func&lt;Product&gt; fun2 = new Func&lt;Product&gt;(b.Cola);Box box1 = a.wProduct(fun1);Console.WriteLine(box1.product.name);Box box2 = a.wProduct(fun2);Console.WriteLine(box2.product.name);class Product{    public string name { get; set; }}class Box{    public Product product { get; set; }}class WaryProduct{    public Box wProduct(Func&lt;Product&gt; getProduct)    {        Product product = getProduct();        Box box = new Box();        box.product = product;        return box;    }}class ProductFactory{    public Product Pizza()    {        Product product = new Product();        product.name = "pizza";        return product;    }    public Product Cola()    {        Product product = new Product();        product.name = "Cola";        return product;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="回调方法的使用"><a href="#回调方法的使用" class="headerlink" title="回调方法的使用"></a>回调方法的使用</h3><p>对比上一种的使用，回调方法主要是在某种情况下的调用，例如pizza的价格大于50时，执行回调方法。</p><pre class="line-numbers language-none"><code class="language-none">// See https://aka.ms/new-console-template for more information/*这个部分主要是对于委托的一些使用测试， * 四个类，产品类product-具有产品的名称属性 * 包装类box-将产品包装起来，返回一个产品类的参数 * 进行包装类warrybox-具有一个方法wProduct 参数（是一个返回类型为Product类型的，参数为空的方法），返回值是（box类型） * 产品工厂类ProductFactory-具有两个无参数，返回类型为product类型的方法； * 主函数中引用了两个func1，func2分别采用两个方法。 *///此处是实例化两个类的实例，他们都是一个非静态函数，需要实例化才能调用对应的方法。虽然好像没有真的使用，但是可能真的指示//也是需要的。WaryProduct a=new WaryProduct();ProductFactory b = new ProductFactory();Logger c = new Logger();Func&lt;Product&gt; fun1 = new Func&lt;Product&gt;(b.Pizza);Func&lt;Product&gt; fun2 = new Func&lt;Product&gt;(b.Cola);Action&lt;Product&gt; fun3 = new Action&lt;Product&gt;(c.Log);Box box1 = a.wProduct(fun1, fun3);Console.WriteLine(box1.product.name);Box box2 = a.wProduct(fun2, fun3);Console.WriteLine(box2.product.name);class Product{    public string name { get; set; }    public int price { get; set; }}class Box{    public Product product { get; set; }}class Logger{    public void Log(Product product)    {        Console.WriteLine("Product {0} is created at {1} ,its price is {2}"            , product.name, DateTime.UtcNow, product.price);    }}class WaryProduct{    public Box wProduct(Func&lt;Product&gt; getProduct,Action&lt;Product&gt; LogCallBack)    {        Product product = getProduct();        Box box = new Box();        box.product = product;        if (box.product.price &gt; 50)            LogCallBack(box.product);        return box;    }}class ProductFactory{    public Product Pizza()    {        Product product = new Product();        product.name = "pizza";        product.price = 60;        return product;    }    public Product Cola()    {        Product product = new Product();        product.name = "Cola";        product.price=40;        return product;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="多播委托"><a href="#多播委托" class="headerlink" title="多播委托"></a>多播委托</h2><p>MulticastDelegate<br>多播委托就是用一个委托执行多个委托，执行顺序是根据添加顺序<br>单播委托就是普通形态<br>例如下面这种代码  </p><pre class="line-numbers language-none"><code class="language-none">// See https://aka.ms/new-console-template for more informationStudent stu1 = new Student() { Id = 1, PenColor = ConsoleColor.Yellow };Student stu2 = new Student() { Id = 2, PenColor = ConsoleColor.Green };Student stu3 = new Student() { Id = 3, PenColor = ConsoleColor.Red };Action action1 = new Action(stu1.DoHomeWork);Action action2 = new Action(stu2.DoHomeWork);Action action3 = new Action(stu3.DoHomeWork);action1.Invoke();action2.Invoke();action3.Invoke();class Student{    public int Id { get; set; }    public ConsoleColor PenColor { get; set; }    public void DoHomeWork()    {        Console.ForegroundColor = this.PenColor;        for(int i = 0; i &lt; 5; i++)        {            Console.WriteLine("Student {0} doing homework {1} hour(s)",this.Id,i);            Thread.Sleep(1000);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多播委托举例  </p><pre class="line-numbers language-none"><code class="language-none">// See https://aka.ms/new-console-template for more informationStudent stu1 = new Student() { Id = 1, PenColor = ConsoleColor.Yellow };Student stu2 = new Student() { Id = 2, PenColor = ConsoleColor.Green };Student stu3 = new Student() { Id = 3, PenColor = ConsoleColor.Red };Action action1 = new Action(stu1.DoHomeWork);Action action2 = new Action(stu2.DoHomeWork);Action action3 = new Action(stu3.DoHomeWork);action1 += action2;action1 += action3;action1();class Student{    public int Id { get; set; }    public ConsoleColor PenColor { get; set; }    public void DoHomeWork()    {        Console.ForegroundColor = this.PenColor;        for(int i = 0; i &lt; 5; i++)        {            Console.WriteLine("Student {0} doing homework {1} hour(s)",this.Id,i);            Thread.Sleep(1000);        }            }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="委托的高级使用-隐式异步调用"><a href="#委托的高级使用-隐式异步调用" class="headerlink" title="委托的高级使用-隐式异步调用"></a>委托的高级使用-隐式异步调用</h2><p>每一个运行的程序都是一个进程<br>每一个进程可以有一个或者多个线程（therd）<br>同步调用是在同一个线程内<br>异步调用的底层机理是多线程<br>串行==同步==单线程，并行==异步==多线程<br>同步调用可以是间接调用，也可以是直接调用。上面这个例子就是间接调用，属于同步调用。<br>BegunInvoke(param1,param2)<br>param1是回调函数，第二个参数通常为null<br>此处运行失败，好像是这个版本VS不支持隐式的异步调用。  </p><pre class="line-numbers language-none"><code class="language-none">Student stu1 = new Student() { Id = 1, PenColor = ConsoleColor.Yellow };Student stu2 = new Student() { Id = 2, PenColor = ConsoleColor.Green };Student stu3 = new Student() { Id = 3, PenColor = ConsoleColor.Red };Action action1 = new Action(stu1.DoHomeWork);Action action2 = new Action(stu2.DoHomeWork);Action action3 = new Action(stu3.DoHomeWork);action1.BeginInvoke(null,null);class Student{    public int Id { get; set; }    public ConsoleColor PenColor { get; set; }    public void DoHomeWork()    {        Console.ForegroundColor = this.PenColor;        for(int i = 0; i &lt; 5; i++)        {            Console.WriteLine("Student {0} doing homework {1} hour(s)",this.Id,i);            Thread.Sleep(1000);        }            }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="委托的高级使用-显式异步调用Thread"><a href="#委托的高级使用-显式异步调用Thread" class="headerlink" title="委托的高级使用-显式异步调用Thread"></a>委托的高级使用-显式异步调用Thread</h2><pre class="line-numbers language-none"><code class="language-none">// See https://aka.ms/new-console-template for more informationStudent stu1 = new Student() { Id = 1, PenColor = ConsoleColor.Yellow };Student stu2 = new Student() { Id = 2, PenColor = ConsoleColor.Green };Student stu3 = new Student() { Id = 3, PenColor = ConsoleColor.Red };Thread thread1 = new Thread(new ThreadStart(stu1.DoHomeWork));Thread thread2 = new Thread(new ThreadStart(stu2.DoHomeWork));Thread thread3 = new Thread(new ThreadStart(stu3.DoHomeWork));thread1.Start();thread2.Start();thread3.Start();class Student{    public int Id { get; set; }    public ConsoleColor PenColor { get; set; }    public void DoHomeWork()    {        Console.ForegroundColor = this.PenColor;        for(int i = 0; i &lt; 5; i++)        {            Console.WriteLine("Student {0} doing homework {1} hour(s)",this.Id,i);            Thread.Sleep(1000);        }            }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="委托的高级使用-显式异步调用Task"><a href="#委托的高级使用-显式异步调用Task" class="headerlink" title="委托的高级使用-显式异步调用Task"></a>委托的高级使用-显式异步调用Task</h2><pre class="line-numbers language-none"><code class="language-none">// See https://aka.ms/new-console-template for more informationStudent stu1 = new Student() { Id = 1, PenColor = ConsoleColor.Yellow };Student stu2 = new Student() { Id = 2, PenColor = ConsoleColor.Green };Student stu3 = new Student() { Id = 3, PenColor = ConsoleColor.Red };Task task1 = new Task(new Action(stu1.DoHomeWork));Task task2 = new Task(new Action(stu2.DoHomeWork));Task task3 = new Task(new Action(stu3.DoHomeWork));task1.Start();task2.Start();task3.Start();class Student{    public int Id { get; set; }    public ConsoleColor PenColor { get; set; }    public void DoHomeWork()    {        Console.ForegroundColor = this.PenColor;        for(int i = 0; i &lt; 5; i++)        {            Console.WriteLine("Student {0} doing homework {1} hour(s)",this.Id,i);            Thread.Sleep(1000);        }            }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h1><p>Datetime.now与Datetime.Utcnow的区别在于前一个带有时区  </p><h2 id="委托的缺陷"><a href="#委托的缺陷" class="headerlink" title="委托的缺陷"></a>委托的缺陷</h2><ol><li>方法级别的紧耦合，工作中要慎之又慎</li><li>使可读性下降，debug的难度增加</li><li>把委托回调，异步调用和多线程纠缠在一起，会让代码变得难以维护与阅读</li><li>委托使用不当有可能造成内存泄漏和程序性能下降</li></ol><h2 id="接口在一定的层次上代替委托"><a href="#接口在一定的层次上代替委托" class="headerlink" title="接口在一定的层次上代替委托"></a>接口在一定的层次上代替委托</h2><p>java没有委托，但是具有接口。依旧可以完成所有任务。接口比委托更加使用的上舒服  </p><h1 id="二、反射"><a href="#二、反射" class="headerlink" title="二、反射"></a>二、反射</h1><h1 id="三、特性"><a href="#三、特性" class="headerlink" title="三、特性"></a>三、特性</h1><p>delegate——-相当于函数指针的升级版</p><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="一、类class"><a href="#一、类class" class="headerlink" title="一、类class"></a>一、类class</h1><p>class.fun()———-这个是调用使用了方法<br>class.fun ———–指示到这个方法</p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 基础学习 </tag>
            
            <tag> 委托 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#继承学习-学习日志（2）</title>
      <link href="/2022/09/05/c-ji-cheng-xue-xi-xue-xi-ri-zhi-2/"/>
      <url>/2022/09/05/c-ji-cheng-xue-xi-xue-xi-ri-zhi-2/</url>
      
        <content type="html"><![CDATA[<p>学习继承<br>面向对象的三大特性，封装继承多态</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的好处"><a href="#继承的好处" class="headerlink" title="继承的好处"></a>继承的好处</h2><ol><li>优化代码结构</li><li>提高代码的复用性</li><li>为多态提供前提</li></ol><h2 id="继承语法格式"><a href="#继承语法格式" class="headerlink" title="继承语法格式"></a>继承语法格式</h2><p>子类继承父类，用用”：“冒号关键字符<br>class 子类：父类<br>{<br>    //类成员<br>}<br>This关键字表示当前类<br>Base是上传到父类来处理</p><pre class="line-numbers language-none"><code class="language-none">//父类class Hero{private string heroName;private inr attack;//父类的构造方法public Hero () {}public Hero (string m_heroName.int m_attack){this.heroName=m_heroName;this.attack=m_attack;}//父类的方法public string HeroName{get {return HeroName;}set {heroName=value;}}public int Attack{get {return Attack;}set {attack=value;}}}//子类class Luka:Hero{public Luka(){}public Luka(string m_heroName.int m_attack):base(string m_heroName.int m_attack){}public void Suishidaji(){Console.WriteLine("随时打击");}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="子类继承父类的关系"><a href="#子类继承父类的关系" class="headerlink" title="子类继承父类的关系"></a>子类继承父类的关系</h2><p>父类中的字段，用private修饰的字段，我们在子类中无法访问<br>public修饰，子类可以访问。通过<em>base.字段名</em>的方式访问<br>大部分（80%是private）<br>父类中的属性，用private修饰的属性，我们在子类中无法访问<br>public修饰，子类可以访问。通过<em>base.属性名</em>的方式访问<br>大部分（80%是public）<br>父类中的普通方法，用private修饰的普通方法，我们在子类中无法访问<br>public修饰，子类可以访问。通过<em>base.方法名</em>的方式访问  </p><p>父类中的构造方法，用private修饰的字段，我们在子类中无法访问<br>public修饰，子类可以访问。通过<em>base（）</em>的方式访问<br>大部分（99%是public）</p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 基础学习 </tag>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Basler语法学习</title>
      <link href="/2022/09/05/basler-yu-fa-xue-xi/"/>
      <url>/2022/09/05/basler-yu-fa-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>Basler语法学习</p><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="基础设备"><a href="#基础设备" class="headerlink" title="基础设备"></a>基础设备</h2><h3 id="basler设备的查找"><a href="#basler设备的查找" class="headerlink" title="basler设备的查找"></a>basler设备的查找</h3><h3 id="第一个设备的操作"><a href="#第一个设备的操作" class="headerlink" title="第一个设备的操作"></a>第一个设备的操作</h3><pre class="line-numbers language-none"><code class="language-none"> //声明一个设备  PYLON_DEVICE_HANDLE hDev = new PYLON_DEVICE_HANDLE();          /* Handle for the pylon device. */  try            {                uint numDevices;    /* Number of devices available. */#if DEBUG                /* This is a special debug setting needed only for GigE cameras.                See 'Building Applications with pylon' in the programmer's guide. */                Environment.SetEnvironmentVariable("PYLON_GIGE_HEARTBEAT", "300000" /*ms*/);#endif                /* Before using any pylon methods, the pylon runtime must be initialized. */                //Pylon初始化                Pylon.Initialize();                /* Enumerate all camera devices. You must call                Pylon.EnumerateDevices() before creating a device.                  枚举设备获得设备数量*/                numDevices = Pylon.EnumerateDevices();                if (0 == numDevices)                {                    throw new Exception("No devices found.");                }                /*hDev设为第一个设备的引用 Get a handle for the first device found.  */                hDev = Pylon.CreateDeviceByIndex(0);                /*在使用设备前打开此设备                 cPylonAccessModeControl==1 Write access to device features is allowed.                cPylonAccessModeStream = 2 Stream grabber access is allowed.                 ´Ë´¦Ê¹ÓÃÎ»»òÔËËã£¬¸ù¾ÝÔËËãµÄ½á¹ûµÃµ½ÏàÓ¦µÄÄ£Ê½¡£                PYLONC_ACCESS_MODE_CONTROL - Allows to read or write camera parameters to configure the camera.                 PYLONC_ACCESS_MODE_STREAM - Allows to read image data from the camera's stream grabber object.                 PYLONC_ACCESS_MODE_EVENT - Allows to read event data from the camera's stream grabber object.                 PYLONC_ACCESS_MODE_EXCLUSIVE - Allows exclusive access. When this flag is specified no other application may access the camera.                 PYLONC_ACCESS_MODE_MONITOR - Allows only read access. This flag cannot be combined with any other flags.                 It is typically used in Multicast/Broadcast applications with GigE cameras. You can pass one or more flags.                 If you pass more than one flag you can combine them using the 'or' operator.                 Before using the device, it must be opened. Open it for configuring                parameters and for grabbing images. */                Pylon.DeviceOpen(hDev, Pylon.cPylonAccessModeControl | Pylon.cPylonAccessModeStream);                /* Print out the name of the camera we are using. */                {                    bool isReadable;                    isReadable = Pylon.DeviceFeatureIsReadable(hDev, "DeviceModelName");                    if (isReadable)                    {                        string name = Pylon.DeviceFeatureToString(hDev, "DeviceModelName");                        Console.WriteLine("Using camera {0}", name);                    }                }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多个设备的批量设置"><a href="#多个设备的批量设置" class="headerlink" title="多个设备的批量设置"></a>多个设备的批量设置</h3><pre class="line-numbers language-none"><code class="language-none">        const uint MAX_NUM_DEVICES = 2;        const uint NUM_BUFFERS = 1;        /* Number of buffers used for grabbing. */        const uint GIGE_PACKET_SIZE = 1500; /* Size of one Ethernet packet. */        const uint GIGE_PROTOCOL_OVERHEAD = 36;   /* Total number of bytes of protocol overhead. */        const uint AllGroupMask = 0xffffffff;       /// &lt;summary&gt;        /// The main entry point for the application.        /// &lt;/summary&gt;        static void Main()        {            /* Use a random number as the device key. */            uint DeviceKey = (uint)(new Random()).Next(int.MaxValue);            /* In this sample all cameras belong to the same group. */            const uint GroupKey = 0x24;            PYLON_DEVICE_HANDLE[] hDev = new PYLON_DEVICE_HANDLE[MAX_NUM_DEVICES];        /* Handles for the pylon devices. */            for (int deviceIndex = 0; deviceIndex &lt; MAX_NUM_DEVICES; ++deviceIndex)            {                hDev[deviceIndex] = new PYLON_DEVICE_HANDLE();            }            try            {                uint numDevicesEnumerated;    /* Number of the devices connected to this PC. */                uint numDevicesToUse;         /* Number of the devices to use in this sample. */                bool isAvail;                 /* Used for checking feature availability. */                bool isReady;                 /* Used as an output parameter. */                int i;                        /* Counter. */                uint deviceIndex;             /* Index of device used in the following variables. */                PYLON_WAITOBJECTS_HANDLE wos; /* Wait objects. */                /* These are camera specific variables: */                PYLON_STREAMGRABBER_HANDLE[] hGrabber = new PYLON_STREAMGRABBER_HANDLE[MAX_NUM_DEVICES]; /* Handle for the pylon stream grabber. */                PYLON_WAITOBJECT_HANDLE[]    hWait = new PYLON_WAITOBJECT_HANDLE[MAX_NUM_DEVICES];       /* Handle used for waiting for a grab to be finished. */                uint[]                       payloadSize = new uint[MAX_NUM_DEVICES];                    /* Size of an image frame in bytes. */                uint[]                       nStreams = new uint[MAX_NUM_DEVICES];                       /* The number of streams provided by the device. */                PYLON_STREAMBUFFER_HANDLE[]  hBuffer = new PYLON_STREAMBUFFER_HANDLE[MAX_NUM_DEVICES];                PylonBuffer&lt;Byte&gt;[]          buffer = new PylonBuffer&lt;Byte&gt;[MAX_NUM_DEVICES];#if DEBUG                /* This is a special debug setting needed only for GigE cameras.                See 'Building Applications with pylon' in the Programmer's Guide. */                Environment.SetEnvironmentVariable("PYLON_GIGE_HEARTBEAT", "300000" /*ms*/);#endif                /* Before using any pylon methods, the pylon runtime must be initialized. */                Pylon.Initialize();                /* Enumerate all camera devices. You must call                PylonEnumerateDevices() before creating a device. */                numDevicesEnumerated = Pylon.EnumerateDevices();                if (numDevicesEnumerated == 0)                {                    Pylon.Terminate();                    Console.Error.WriteLine("No devices found!");                    Console.Error.WriteLine("\nPress enter to exit.");                    Console.ReadLine();                    return;                }                /* Create wait objects. This must be done outside of the loop. */                wos = Pylon.WaitObjectsCreate();                /* Open cameras and set parameter */                deviceIndex = 0;                for (uint enumeratedDeviceIndex = 0; enumeratedDeviceIndex &lt; numDevicesEnumerated; ++enumeratedDeviceIndex)                {                    /* only open GigE devices */                    PYLON_DEVICE_INFO_HANDLE hDI = Pylon.GetDeviceInfoHandle(enumeratedDeviceIndex);                    if (Pylon.DeviceInfoGetPropertyValueByName(hDI, Pylon.cPylonDeviceInfoDeviceClassKey) != "BaslerGigE")                    {                        continue;                    }                    /* Get handles for the devices. */                    hDev[deviceIndex] = Pylon.CreateDeviceByIndex((uint)enumeratedDeviceIndex);                    /* Before using the device, it must be opened. Open it for configuring                    parameters and for grabbing images. */                    Pylon.DeviceOpen(hDev[deviceIndex], Pylon.cPylonAccessModeControl | Pylon.cPylonAccessModeStream);                    /* Print out the name of the camera we are using. */                    Console.WriteLine("Using camera '{0}'", Pylon.DeviceInfoGetPropertyValueByName(hDI, Pylon.cPylonDeviceInfoModelNameKey));                    isAvail = Pylon.DeviceFeatureIsReadable(hDev[deviceIndex], "ActionControl");                    if (!isAvail)                    {                        throw new Exception("Device doesn't support the Action Command");                    }                    /* Configure the first action */                    Pylon.DeviceSetIntegerFeature(hDev[deviceIndex], "ActionSelector", 1);                    Pylon.DeviceSetIntegerFeature(hDev[deviceIndex], "ActionDeviceKey", DeviceKey);                    Pylon.DeviceSetIntegerFeature(hDev[deviceIndex], "ActionGroupKey", GroupKey);                    Pylon.DeviceSetIntegerFeature(hDev[deviceIndex], "ActionGroupMask", AllGroupMask);                    /* Set the pixel format to Mono8, where gray values will be output as 8 bit values for each pixel. */                    /* ... Check first to see if the device supports the Mono8 format. */                    isAvail = Pylon.DeviceFeatureIsAvailable(hDev[deviceIndex], "EnumEntry_PixelFormat_Mono8");                    if (!isAvail)                    {                        /* Feature is not available. */                        throw new Exception("Device doesn't support the Mono8 pixel format.");                    }                    /* ... Set the pixel format to Mono8. */                    Pylon.DeviceFeatureFromString(hDev[deviceIndex], "PixelFormat", "Mono8");                    /* Disable acquisition start trigger if available */                    isAvail = Pylon.DeviceFeatureIsAvailable(hDev[deviceIndex], "EnumEntry_TriggerSelector_AcquisitionStart");                    if (isAvail)                    {                        Pylon.DeviceFeatureFromString(hDev[deviceIndex], "TriggerSelector", "AcquisitionStart");                        Pylon.DeviceFeatureFromString(hDev[deviceIndex], "TriggerMode", "Off");                    }                    /* Disable line1 trigger if available */                    isAvail = Pylon.DeviceFeatureIsAvailable(hDev[deviceIndex], "EnumEntry_TriggerSelector_Line1");                    if (isAvail)                    {                        Pylon.DeviceFeatureFromString(hDev[deviceIndex], "TriggerSelector", "Line1");                        Pylon.DeviceFeatureFromString(hDev[deviceIndex], "TriggerMode", "Off");                    }                    /* Enable frame start trigger with first action */                    Pylon.DeviceFeatureFromString(hDev[deviceIndex], "TriggerSelector", "FrameStart");                    Pylon.DeviceFeatureFromString(hDev[deviceIndex], "TriggerMode", "On");                    Pylon.DeviceFeatureFromString(hDev[deviceIndex], "TriggerSource", "Action1");                    /* For GigE cameras, we recommend increasing the packet size for better                        performance. When the network adapter supports jumbo frames, set the packet                        size to a value &gt; 1500, e.g., to 8192. In this sample, we only set the packet size                        to 1500.                        We also set the Inter-Packet and the Frame Transmission delay                        so the switch can line up packets better.                    */                    Pylon.DeviceSetIntegerFeature(hDev[deviceIndex], "GevSCPSPacketSize", GIGE_PACKET_SIZE);                    Pylon.DeviceSetIntegerFeature(hDev[deviceIndex], "GevSCPD", (GIGE_PACKET_SIZE + GIGE_PROTOCOL_OVERHEAD) * (MAX_NUM_DEVICES - 1));                    Pylon.DeviceSetIntegerFeature(hDev[deviceIndex], "GevSCFTD", (GIGE_PACKET_SIZE + GIGE_PROTOCOL_OVERHEAD) * deviceIndex);                    /* one device opened */                    ++deviceIndex;                }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="显示设备名称"><a href="#显示设备名称" class="headerlink" title="显示设备名称"></a>显示设备名称</h3><p> 显示设备的名称</p><pre class="line-numbers language-none"><code class="language-none">/* Print out the name of the camera we are using. */               {                   bool isReadable;                   isReadable = Pylon.DeviceFeatureIsReadable(hDev, "DeviceModelName");                   if (isReadable)                   {                       string name = Pylon.DeviceFeatureToString(hDev, "DeviceModelName");                       Console.WriteLine("Using camera {0}", name);                   }               }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置拍摄图片模式"><a href="#设置拍摄图片模式" class="headerlink" title="设置拍摄图片模式"></a>设置拍摄图片模式</h3><pre class="line-numbers language-none"><code class="language-none">/* Set the pixel format to Mono8, where gray values will be output as 8 bit values for each pixel. */                /* ... Check first to see if the device supports the Mono8 format. */                isAvail = Pylon.DeviceFeatureIsAvailable(hDev, "EnumEntry_PixelFormat_Mono8");                if (!isAvail)                {                    /* Feature is not available. */                    throw new Exception("Device doesn't support the Mono8 pixel format.");                }                /* ... Set the pixel format to Mono8. */                Pylon.DeviceFeatureFromString(hDev, "PixelFormat", "Mono8");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置拍摄采集模式"><a href="#设置拍摄采集模式" class="headerlink" title="设置拍摄采集模式"></a>设置拍摄采集模式</h3><pre class="line-numbers language-none"><code class="language-none">/* Check the available camera trigger mode(s) to select the appropriate one: acquisition start trigger mode (used by previous cameras;                do not confuse with acquisition start command) or frame start trigger mode (equivalent to previous acquisition start trigger mode). */                isAvailAcquisitionStart = Pylon.DeviceFeatureIsAvailable(hDev, "EnumEntry_TriggerSelector_AcquisitionStart");                isAvailFrameStart = Pylon.DeviceFeatureIsAvailable(hDev, "EnumEntry_TriggerSelector_FrameStart");                /* Check to see if the camera implements the acquisition start trigger mode only.                优先是frame start （此时只有在半双工的时候才能打开frame burst帧突发），其次选择Acquisition Start。两种模式不能并存                */                if (isAvailAcquisitionStart &amp;&amp; !isAvailFrameStart)                {                    /* Camera uses the acquisition start trigger as the only trigger mode. */                    Pylon.DeviceFeatureFromString(hDev, "TriggerSelector", "AcquisitionStart");                    Pylon.DeviceFeatureFromString(hDev, "TriggerMode", "On");                    triggerSelectorValue = "AcquisitionStart";                }                else                {                    /* Camera may have the acquisition start trigger mode and the frame start trigger mode implemented.                    In this case, the acquisition trigger mode must be switched off. */                    if (isAvailAcquisitionStart)                    {                        Pylon.DeviceFeatureFromString(hDev, "TriggerSelector", "AcquisitionStart");                        Pylon.DeviceFeatureFromString(hDev, "TriggerMode", "Off");                    }                    /* Disable frame burst start trigger if available */                    isAvail = Pylon.DeviceFeatureIsAvailable(hDev, "EnumEntry_TriggerSelector_FrameBurstStart");                    if (isAvail)                    {                        Pylon.DeviceFeatureFromString(hDev, "TriggerSelector", "FrameBurstStart");                        Pylon.DeviceFeatureFromString(hDev, "TriggerMode", "Off");                    }                    /* To trigger each single frame by software or external hardware trigger: Enable the frame start trigger mode. */                    Pylon.DeviceFeatureFromString(hDev, "TriggerSelector", "FrameStart");                    Pylon.DeviceFeatureFromString(hDev, "TriggerMode", "On");                }                /* Note: the trigger selector must be set to the appropriate trigger mode                before setting the trigger source or issuing software triggers.                Frame start trigger mode for newer cameras, acquisition start trigger mode for previous cameras.                 软件触发*/                Pylon.DeviceFeatureFromString(hDev, "TriggerSelector", triggerSelectorValue);                /* Enable software triggering.                 持续采集*/                /* ... Select the software trigger as the trigger source. */                Pylon.DeviceFeatureFromString(hDev, "TriggerSource", "Software");                /* When using software triggering, the Continuous frame mode should be used. Once                   acquisition is started, the camera sends one image each time a software trigger is                   issued. */                Pylon.DeviceFeatureFromString(hDev, "AcquisitionMode", "Continuous");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置拍摄数据包大小"><a href="#设置拍摄数据包大小" class="headerlink" title="设置拍摄数据包大小"></a>设置拍摄数据包大小</h3><pre class="line-numbers language-none"><code class="language-none">/* For GigE cameras, we recommend increasing the packet size for better   performance. If the network adapter supports jumbo frames, set the packet   size to a value &gt; 1500, e.g., to 8192. In this sample, we only set the packet size   to 1500. *//* ... Check first to see if the GigE camera packet size parameter is supported and if it is writable. */isAvail = Pylon.DeviceFeatureIsWritable(hDev, "GevSCPSPacketSize");if (isAvail){    /* ... The device supports the packet size feature. Set a value. */    Pylon.DeviceSetIntegerFeature(hDev, "GevSCPSPacketSize", 1500);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置拍摄块"><a href="#设置拍摄块" class="headerlink" title="设置拍摄块"></a>设置拍摄块</h3><p>摄像机可以生成关于每个图像的特定信息，例如帧</p><p>计数器、时间戳和CRC校验和，作为数据“块”附加到图像数据。此示例演示了如何启用块功能，以及如何获取</p><p>以及如何处理附加数据。当相机处于块模式时，它传输数据块</p><p>其被划分成块。第一块总是图像数据。当块特征被启用时，</p><p>图像数据块之后是包含由块特征生成的信息的块。<br>本示例还演示了如何使用软件触发器。使用两个缓冲器。一旦缓冲器被填充，</p><p>在处理接收到的缓冲器之前触发下一帧的获取。这种方法允许：</p><p>在前一图像的处理进行的同时执行图像获取。</p><pre class="line-numbers language-none"><code class="language-none">/* Before enabling individual chunks, the chunk mode in general must be activated. */isAvail = Pylon.DeviceFeatureIsWritable(hDev, "ChunkModeActive");if (!isAvail){    throw new Exception("The device doesn't support the chunk mode.");}/* Activate the chunk mode. */Pylon.DeviceSetBooleanFeature(hDev, "ChunkModeActive", true);/* Enable some individual chunks... *//* ... The frame counter chunk feature. *//* Is the chunk feature available? */isAvail = Pylon.DeviceFeatureIsAvailable(hDev, "EnumEntry_ChunkSelector_Framecounter");if (isAvail){    /* Select the frame counter chunk feature. */    Pylon.DeviceFeatureFromString(hDev, "ChunkSelector", "Framecounter");    /* Can the chunk feature be activated? */    isAvail = Pylon.DeviceFeatureIsWritable(hDev, "ChunkEnable");    if (isAvail)    {        /* Activate the chunk feature. */        Pylon.DeviceSetBooleanFeature(hDev, "ChunkEnable", true);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="设置块chunks的内容"><a href="#设置块chunks的内容" class="headerlink" title="设置块chunks的内容"></a>设置块chunks的内容</h4><pre class="line-numbers language-none"><code class="language-none">//设置循环冗余校验（Cyclic Redundancy Check， CRC）是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种信道编码技术，主要用来检测或校验数据传输或者保存后可能出现的错误。它是利用除法及余数的原理来作错误侦测的。                /* ... The CRC checksum chunk feature. */                /*  Note: Enabling the CRC checksum chunk feature is not a prerequisite for using                   chunks. Chunks can also be handled when the CRC checksum chunk feature is disabled. */                isAvail = Pylon.DeviceFeatureIsAvailable(hDev, "EnumEntry_ChunkSelector_PayloadCRC16");                if (isAvail)                {                    /* Select the CRC checksum chunk feature. */                    Pylon.DeviceFeatureFromString(hDev, "ChunkSelector", "PayloadCRC16");                    /* Can the chunk feature be activated? */                    isAvail = Pylon.DeviceFeatureIsWritable(hDev, "ChunkEnable");                    if (isAvail)                    {                        /* Activate the chunk feature. */                        Pylon.DeviceSetBooleanFeature(hDev, "ChunkEnable", true);                    }                }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="设置块解析器chunk-parser"><a href="#设置块解析器chunk-parser" class="headerlink" title="设置块解析器chunk parser"></a>设置块解析器chunk parser</h4><pre class="line-numbers language-none"><code class="language-none">/* The data block containing the image chunk and the other chunks has a self-descriptive layout.   A chunk parser is used to extract the appended chunk data from the grabbed image frame.   Create a chunk parser. */hChunkParser = Pylon.DeviceCreateChunkParser(hDev);if (!hChunkParser.IsValid){    /* The transport layer doesn't provide a chunk parser. */    throw new Exception("No chunk parser available.");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="设置并分配拍摄流与缓冲区"><a href="#设置并分配拍摄流与缓冲区" class="headerlink" title="设置并分配拍摄流与缓冲区"></a>设置并分配拍摄流与缓冲区</h4><pre class="line-numbers language-none"><code class="language-none">/* Image grabbing is done using a stream grabber.                  A device may be able to provide different streams. A separate stream grabber must                  be used for each stream. In this sample, we create a stream grabber for the default                  stream, i.e., the first stream ( index == 0 ).                  */                /* Get the number of streams supported by the device and the transport layer. */                nStreams = Pylon.DeviceGetNumStreamGrabberChannels(hDev);                if (nStreams &lt; 1)                {                    throw new Exception("The transport layer doesn't support image streams.");                }                /* Create and open a stream grabber for the first channel. */                hGrabber = Pylon.DeviceGetStreamGrabber(hDev, 0);                Pylon.StreamGrabberOpen(hGrabber);                /* Get a handle for the stream grabber's wait object. The wait object                   allows waiting for buffers to be filled with grabbed data. */                hWait = Pylon.StreamGrabberGetWaitObject(hGrabber);                /* Determine the required size of the grab buffer. Since activating chunks will increase the                   payload size and thus the required buffer size, do this after enabling the chunks. */                payloadSize = checked((uint)Pylon.DeviceGetIntegerFeature(hDev, "PayloadSize"));                /* We must tell the stream grabber the number and size of the buffers                    we are using. */                /* .. We will not use more than NUM_BUFFERS for grabbing. */                Pylon.StreamGrabberSetMaxNumBuffer(hGrabber, NUM_BUFFERS);                /* .. We will not use buffers bigger than payloadSize bytes. */                Pylon.StreamGrabberSetMaxBufferSize(hGrabber, payloadSize);                /*  Allocate the resources required for grabbing. After this, critical parameters                    that impact the payload size must not be changed until FinishGrab() is called. */                Pylon.StreamGrabberPrepareGrab(hGrabber);                 /*                将缓冲区输入流抓取器的输入队列。对于每个缓冲区，API允许传递整数作为附加上下文信息。                抓取完成后，该整数将返回不变。在我们的示例中，我们使用缓冲区的索引作为上下文信息。                Before using the buffers for grabbing, they must be registered at                   the stream grabber. For each registered buffer, a buffer handle                   is returned. After registering, these handles are used instead of the                   buffer objects pointers. The buffer objects are held in a dictionary,                   that provides access to the buffer using a handle as key.                 */                buffers = new Dictionary&lt;PYLON_STREAMBUFFER_HANDLE, PylonBuffer&lt;Byte&gt;&gt;();                for (i = 0; i &lt; NUM_BUFFERS; ++i)                {                    PylonBuffer&lt;Byte&gt; buffer = new PylonBuffer&lt;byte&gt;(payloadSize, true);                    PYLON_STREAMBUFFER_HANDLE handle = Pylon.StreamGrabberRegisterBuffer(hGrabber, ref buffer);                    buffers.Add(handle, buffer);                }                /* Feed the buffers into the stream grabber's input queue. For each buffer, the API                   allows passing in an integer as additional context information. This integer                   will be returned unchanged when the grab is finished. In our example, we use the index of the                   buffer as context information. */                i = 0;                foreach (KeyValuePair&lt;PYLON_STREAMBUFFER_HANDLE, PylonBuffer&lt;Byte&gt;&gt; pair in buffers)                {                    Pylon.StreamGrabberQueueBuffer(hGrabber, pair.Key, i++);                }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Basler </category>
          
          <category> .Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basler </tag>
            
            <tag> .NET </tag>
            
            <tag> c# </tag>
            
            <tag> 基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#基础学习-1</title>
      <link href="/2022/09/04/c-ji-chu-xue-xi-1/"/>
      <url>/2022/09/04/c-ji-chu-xue-xi-1/</url>
      
        <content type="html"><![CDATA[<p>前言：<br>自己真正的编写自己的学习博客</p><h1 id="方法的类型"><a href="#方法的类型" class="headerlink" title="方法的类型"></a>方法的类型</h1><h2 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h2><p>方法就是函数。普通方法就是函数。在类中就是对于方法的“行为”进行描述。<br></p><h3 id="普通方法的语法格式"><a href="#普通方法的语法格式" class="headerlink" title="普通方法的语法格式"></a>普通方法的语法格式</h3><p>访问修饰符 返回值 方法名（参数列表）<br><br>{<br>    方法的具体功能<br>}  </p><p>class Person<br>{<br>    private string name;<br>    private int age;<br>    public string Name<br>    {<br>        get{return name};<br>        set{name=value};<br>    }<br>    //后面都可以使用Name进行取值与赋值<br>}<br>Person p1=new Person();<br>p1.Name=”zhangsan”;<br>name2=p1.Name;</p><pre class="line-numbers language-none"><code class="language-none">## 构造方法构造方法可以队实例化出来的对象进行初始化&lt;br&gt;### 构造方法的语法格式public 类名()&lt;br&gt;{  构造函数代码  }  1. 构造方法要用public修饰  2. 构造方法没有返回值，切连void也不能写  3. 构造方法的方法名必须与类名一样  4. 构造方法可以有重载  5. 构造方法如果没有编写过会自动增加一个空的构造方法，但是手动编写有参或者无参数的构造方法后就不会自动添加了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>class Person<br>{<br>    //无参数的构造方法<br>    public Person()<br>    {<br>        zhanwei<br>    }<br>    //两个参数的构造方法<br>    public Person(string name,int age)<br>    {<br>        this.name=name;<br>        this.age=atge;<br>    }<br>}<br>//如何使用<br>Person p2=new Person();<br>Person p3=new Person(“monkey”,18);</p><pre class="line-numbers language-none"><code class="language-none">### This关键字this 表示类内部的那个变量## 析构方法析构方法是常常用于清理一个对象与构造方法差不多是相反的东西### 析构方法的语法～类名()  {  析构方法代码体;  }  1. 析构方法没有任何参数2. 析构方法没有返回值与访问修饰符3. 析构方法由系统自动调用4. 析构方法可以不屑。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>//构造语法<br>//以后补充</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 基础学习 </tag>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>diyi</title>
      <link href="/2022/08/21/diyi/"/>
      <url>/2022/08/21/diyi/</url>
      
        <content type="html"><![CDATA[<p>自己完成的第一篇博客的认证<br>下面来测试一下各种markdown的基本语法</p><h1 id="第一部分-level-1"><a href="#第一部分-level-1" class="headerlink" title="第一部分 level 1"></a>第一部分 level 1</h1><p>输入 “mdi + tab” 会自动插入下面的图片标记<br>输入 “mdl + tab” 会自动生成下面的链接标记<br>是需要自己保存才会用自动改变吧  </p><p>怎么感觉使用有点卡顿吧<br>能够确定是需要保存才会展现出来,<br><br>两边的反应速度好像基本一致  </p><h2 id="倾斜-level-2"><a href="#倾斜-level-2" class="headerlink" title="倾斜 level 2"></a>倾斜 level 2</h2><p>展现<em>新的</em>一行<br></p><h2 id="加粗-level-2"><a href="#加粗-level-2" class="headerlink" title="加粗 level 2"></a>加粗 level 2</h2><p>新的<strong>展现</strong>一行</p><h2 id="引用语法-level-2"><a href="#引用语法-level-2" class="headerlink" title="引用语法 level 2"></a>引用语法 level 2</h2><blockquote><p>yinyong<br>deiwfh</p><blockquote><p>bfejsbf</p><blockquote><p>kdfe<br>dwad<br>fkefb<br>fbrehk<br>dfbjhwe</p></blockquote></blockquote></blockquote><h2 id="代码块展示-level-2"><a href="#代码块展示-level-2" class="headerlink" title="代码块展示 level 2"></a>代码块展示 level 2</h2><p>`</p>            nishuoyiwoshuoyi    `  <h2 id="围栏式代码块展示-level-2"><a href="#围栏式代码块展示-level-2" class="headerlink" title="围栏式代码块展示 level 2"></a>围栏式代码块展示 level 2</h2><pre class="line-numbers language-none"><code class="language-none">&lt;html&gt;    &lt;head&gt;    nishuoyiwoshuoyi    &lt;/head&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>这是一类分割线前</p><hr><p>这是一类分割线后，二类分割线后</p><hr><p>二类分割线后</p><h2 id="列表语法"><a href="#列表语法" class="headerlink" title="列表语法"></a>列表语法</h2><ol><li>Cheiese</li><li>English</li><li>France</li></ol><h2 id="链接语法"><a href="#链接语法" class="headerlink" title="链接语法"></a>链接语法</h2><p>这是一个链接<a href="https://zh.wikipedia.org/zh-tw/%E5%88%9D%E9%9F%B3%E6%9C%AA%E4%BE%86" title="miku殿下来了">守护最好的殿下</a></p><h2 id="图片语法"><a href="#图片语法" class="headerlink" title="图片语法"></a>图片语法</h2><p>一个带链接的图片（!<a href="%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5" title="图片title">图片alt</a>）<br><a href="https://markdown.com.cn/"><img src="/assets/img/shiprock.jpg" alt="沙漠中的岩石图片" title="Shiprock"></a></p><p>##最后友情提示可以直接使用html的语法</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
